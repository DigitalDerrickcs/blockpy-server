(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jQuery"), require("ko"));
	else if(typeof define === 'function' && define.amd)
		define("blockpy", ["jQuery", "ko"], factory);
	else if(typeof exports === 'object')
		exports["blockpy"] = factory(require("jQuery"), require("ko"));
	else
		root["blockpy"] = factory(root["jQuery"], root["ko"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_jquery__, __WEBPACK_EXTERNAL_MODULE_knockout__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/blockpy.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/blockpy.js":
/*!************************!*\
  !*** ./src/blockpy.js ***!
  \************************/
/*! exports provided: _IMPORTED_COMPLETE_DATASETS, _IMPORTED_DATASETS, BlockPy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPy", function() { return BlockPy; });
/* harmony import */ var _css_blockpy_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css/blockpy.css */ "./src/css/blockpy.css");
/* harmony import */ var _css_blockpy_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_blockpy_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./css/bootstrap_retheme.css */ "./src/css/bootstrap_retheme.css");
/* harmony import */ var _css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var skulpt_modules_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! skulpt_modules/image */ "./src/skulpt_modules/image.js");
/* harmony import */ var storage_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! storage.js */ "./src/storage.js");
/* harmony import */ var editors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! editors.js */ "./src/editors.js");
/* harmony import */ var editor_python_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! editor/python.js */ "./src/editor/python.js");
/* harmony import */ var server_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! server.js */ "./src/server.js");
/* harmony import */ var interface_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! interface.js */ "./src/interface.js");
/* harmony import */ var _files__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./files */ "./src/files.js");
/* harmony import */ var _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./editor/abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var engine_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! engine.js */ "./src/engine.js");
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./trace */ "./src/trace.js");
/* harmony import */ var _console__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./console */ "./src/console.js");
/* harmony import */ var feedback_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! feedback.js */ "./src/feedback.js");
/* harmony import */ var _dialog__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./dialog */ "./src/dialog.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
/* harmony import */ var _corgis__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./corgis */ "./src/corgis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_COMPLETE_DATASETS", function() { return _corgis__WEBPACK_IMPORTED_MODULE_17__["_IMPORTED_COMPLETE_DATASETS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_DATASETS", function() { return _corgis__WEBPACK_IMPORTED_MODULE_17__["_IMPORTED_DATASETS"]; });

/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./history */ "./src/history.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
/* harmony import */ var _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./editor/sample_submissions */ "./src/editor/sample_submissions.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @fileoverview Starting point of the BlockPy application, containing the main
 * BlockPy class.
 */



 //import {$builtinmodule as matplotlibModule} from "skulpt_modules/matplotlib2";





















var EDITOR_VERSION = "5.1.1";
/**
 * Major entry point for creating a BlockPy instance.
 * Two most important fields are `model` and `components`.
 * The `model` holds all the data about the interface.
 * The `components` are references to the disparate parts of BlockPy.
 *
 * Most of this classes definition is just initializing the model and updating
 * it on an assignment switch.
 */

var BlockPy = /*#__PURE__*/function () {
  /**
   * @param {Object} configuration - User level settings (e.g., what editor mode, whether to mute semantic errors, etc.)
   * @param {Object} assignment - Assignment level settings (data about the loaded assignment, user, submission, etc.)
   * @param {Object} submission - Includes the source code of any programs to be loaded
   */
  function BlockPy(configuration, assignment, submission) {
    _classCallCheck(this, BlockPy);

    this.initModel(configuration);

    if (assignment !== undefined) {
      this.setAssignment(configuration, assignment, submission);
    }

    this.initMain();
  }
  /**
   * Initializes the BlockPy object by initializing its interface,
   * model, and components.
   *
   */


  _createClass(BlockPy, [{
    key: "initMain",
    value: function initMain() {
      this.initUtilities();
      this.initModelMethods();
      this.turnOnHacks();
      this.initInterface();
      this.applyModel();
      this.initComponents();
      this.makeExtraSubscriptions();
      this.start();
    }
  }, {
    key: "getSetting",

    /**
     * Retrieves a default value or
     * @param {string} key - the key to look up a value for
     * @param {Object} defaultValue - if the key is not found anywhere, use this value
     */
    value: function getSetting(key, defaultValue) {
      if (key in this.initialConfiguration_) {
        return this.initialConfiguration_[key];
      } else if (this.localSettings_.has(key)) {
        return this.localSettings_.get(key);
      } else {
        return defaultValue;
      }
    }
    /**
     * Initializes the model to its defaults.
     *
     * Categories:
     *   * user: values for the current user (stored to server)
     *   * assignment: values for the current assignment (stored to server)
     *   * submission: values for the current submission (stored to server)
     *   * display: flags related to current visibility (stored to localSettings)
     *   * status: messages related to current status (not stored)
     *   * execution: values related to last run (not stored)
     *   * configuration: constant values related to setup (not stored)
     */

  }, {
    key: "initModel",
    value: function initModel(configuration) {
      // Connect to local storage
      this.localSettings_ = new storage_js__WEBPACK_IMPORTED_MODULE_4__["LocalStorageWrapper"]("localSettings");
      this.initialConfiguration_ = configuration;
      this.model = {
        user: {
          id: ko.observable(configuration["user.id"]),
          name: ko.observable(configuration["user.name"]),

          /**
           * Whether you are an Owner (can modify the assignment), Grader (can view
           * the assignments' information) or Student (can not see any instructor stuff).
           * @type {bool}
           */
          role: ko.observable(this.getSetting("user.role", "owner")),

          /**
           * Current course for this user
           */
          courseId: ko.observable(configuration["user.course_id"]),

          /**
           * Current assignment group that this user is inside
           */
          groupId: ko.observable(configuration["user.group_id"])
        },
        assignment: {
          id: ko.observable(null),
          name: ko.observable("Scratch Canvas"),
          instructions: ko.observable("Welcome to BlockPy. Try editing and running the code below."),

          /**
           * The human-friendly URL to use as a shortcut for this assignment
           */
          url: ko.observable(""),
          // TODO: warning message if maze
          type: ko.observable(""),
          startingCode: ko.observable(configuration["assignment.starting_code"] || ""),
          onRun: ko.observable(configuration["assignment.on_run"] || ""),
          onChange: ko.observable(configuration["assignment.on_change"] || null),
          onEval: ko.observable(configuration["assignment.on_eval"] || null),
          extraInstructorFiles: ko.observableArray([]),
          extraStartingFiles: ko.observableArray([]),
          forkedId: ko.observable(null),
          forkedVersion: ko.observable(null),
          ownerId: ko.observable(null),
          courseId: ko.observable(null),
          version: ko.observable(null),
          tags: ko.observableArray([]),
          sampleSubmissions: ko.observableArray([]),
          reviewed: ko.observable(configuration["assignment.reviewed"]),
          "public": ko.observable(configuration["assignment.public"]),
          hidden: ko.observable(configuration["assignment.hidden"]),
          ipRanges: ko.observable(configuration["assignment.ip_ranges"]),
          settings: Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_16__["makeAssignmentSettingsModel"])(configuration)
        },
        submission: {
          id: ko.observable(null),
          code: ko.observable(configuration["submission.code"] || ""),
          extraFiles: ko.observableArray([]),
          url: ko.observable(""),
          endpoint: ko.observable(""),
          score: ko.observable(0),
          correct: ko.observable(false),
          // assignmentId inferred from assignment.id
          // courseId inferred from user.courseId
          // userId inferred from user.id
          // assignmentVersion inferred from assignment.version
          version: ko.observable(0),
          submissionStatus: ko.observable("Started"),
          gradingStatus: ko.observable("NotReady"),
          ownerId: ko.observable(null)
        },
        display: {
          /**
           * Currently visible File, if applicable
           * @type {String}
           */
          filename: ko.observable(null),

          /**
           * Whether or not to be presented with the instructor settings and files
           * @type {bool}
           */
          instructor: ko.observable("" + this.getSetting("display.instructor", "false") === "true"),

          /**
           * Whether or not to prevent the printer from showing things
           */
          mutePrinter: ko.observable(false),

          /**
           * (Python Views) The current editor mode.
           * @type {DisplayModes}
           */
          pythonMode: ko.observable(this.getSetting("display.python.mode", editor_python_js__WEBPACK_IMPORTED_MODULE_6__["DisplayModes"].SPLIT)),

          /**
           * Whether or not History mode is engaged.
           * @type {bool}
           */
          historyMode: ko.observable(false),

          /**
           * Whether or not to be auto-saving changes in Python editor
           * If an integer, specifies the delay that should be used (microseconds).
           * This is never on in non-Python editors.
           * @type {bool|int}
           */
          autoSave: ko.observable(true),

          /**
           * Whether or not the console is full width and feedback is hidden
           */
          bigConsole: ko.observable(false),

          /**
           * The height to use for the console.
           *    If null, then let the height remain unchanged
           *    If a number, then the
           */
          previousConsoleHeight: ko.observable(null),
          currentConsoleHeight: ko.observable(null),

          /**
           * Which panel to show in the second row's second column
           * @type {SecondRowSecondPanelOptions}
           */
          secondRowSecondPanel: ko.observable(interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].FEEDBACK),

          /**
           * Whether or not to be tracing the code right now
           */
          traceExecution: ko.observable(false),

          /**
           * The list of promises to still resolve while loading datasets
           * @type {Array<Promise>}
           */
          loadingDatasets: ko.observableArray([]),

          /**
           * The temporary changed value of the instructions have been changed from what is in the assignment
           */
          changedInstructions: ko.observable(null),

          /**
           * A holder for the timer to trigger on-changes
           */
          triggerOnChange: null,

          /**
           * Whether the current feedback and output corresponds to the current submission.
           * This would be false if there is no feedback/output (i.e., code has not been run),
           * or if the user has modified the submission after the last run (e.g., by editing
           * the text).
           */
          dirtySubmission: ko.observable(true),

          /**
           *  Whether or not to make the BlockPy element in FULL SCREEN mode. Sadly, not fullscreen
           *  within the window, but FULL SCREEN. Very aggressive.
           */
          fullscreen: ko.observable(false),

          /**
           * User-supplied passcode to compare on the server against the current passcode.
           */
          passcode: ko.observable(""),

          /**
           * Whether or not to clear out inputs after a run/on_run cycle
           */
          clearInputs: ko.observable(true),
          editorVersion: EDITOR_VERSION,
          readOnly: ko.observable(this.getSetting("display.read_only", "false").toString() === "true")
        },
        status: {
          // @type {ServerStatus}
          loadAssignment: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          loadAssignmentMessage: ko.observable(""),
          // @type {ServerStatus}
          loadHistory: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          loadHistoryMessage: ko.observable(""),
          // @type {ServerStatus}
          loadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          loadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          loadDataset: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          loadDatasetMessage: ko.observable(""),
          // @type {ServerStatus}
          logEvent: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          logEventMessage: ko.observable(""),
          // @type {ServerStatus}
          saveImage: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          saveImageMessage: ko.observable(""),
          // @type {ServerStatus}
          saveFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          saveFileMessage: ko.observable(""),
          // @type {ServerStatus}
          saveAssignment: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          saveAssignmentMessage: ko.observable(""),
          // @type {ServerStatus}
          updateSubmission: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          updateSubmissionMessage: ko.observable(""),
          // @type {ServerStatus}
          updateSubmissionStatus: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          updateSubmissionStatusMessage: ko.observable(""),
          // @type {ServerStatus}
          onExecution: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY)
        },
        execution: {
          // Information about in-progress executions
          reports: {},
          // list of Output objects
          output: ko.observableArray([]),
          // List of inputted strings
          input: ko.observableArray([]),
          inputIndex: ko.observable(0),
          // Information related to a student run
          student: {
            // str: the filename that was last executed and is associated with these results
            filename: ko.observable(null),
            // integer
            currentStep: ko.observable(null),
            // integer
            lastStep: ko.observable(null),
            // integer
            currentLine: ko.observable(null),
            lastLine: ko.observable(0),
            // array of simple objects
            currentTraceData: ko.observableArray([]),
            // integer
            currentTraceStep: ko.observable(0),
            // Actual execution results
            results: null,
            globals: ko.observable(null),
            calls: {}
          },
          instructor: {
            globals: null,
            sysmodules: undefined
          },
          // Information related to feedback from the instructor run
          feedback: {
            // str (markdown)
            message: ko.observable("Ready"),
            category: ko.observable(null),
            label: ko.observable(null),
            hidden: ko.observable(false),
            linesError: ko.observableArray([]),
            linesUncovered: ko.observableArray([]),
            // The results of the last execution
            results: null
          }
        },
        configuration: {
          /**
           * Functions to fire when certain events occur
           */
          callbacks: {
            /**
             * When the student gets a success
             */
            "success": this.initialConfiguration_["callback.success"]
          },

          /**
           * Whether or not the server is connected.
           * @type {bool}
           */
          serverConnected: ko.observable(this.getSetting("server.connected", true)),
          // string
          blocklyPath: this.initialConfiguration_["blockly.path"],
          // string
          attachmentPoint: this.initialConfiguration_["attachment.point"],
          // JQuery object
          container: null,
          // Maps codes ('log_event', 'save_code') to URLs
          urls: this.initialConfiguration_["urls"] || {}
        }
      };
    }
  }, {
    key: "initInterface",

    /**
     * Creates the interface
     */
    value: function initInterface() {
      var constants = this.model.configuration;
      var gui = Object(interface_js__WEBPACK_IMPORTED_MODULE_8__["makeInterface"])(this);
      constants.container = jquery__WEBPACK_IMPORTED_MODULE_2___default()(constants.attachmentPoint).html(jquery__WEBPACK_IMPORTED_MODULE_2___default()(gui));
    }
  }, {
    key: "loadAssignment",
    value: function loadAssignment(assignment_id) {
      this.components.server.loadAssignment(assignment_id);
    }
  }, {
    key: "loadTags",
    value: function loadTags(tags) {// Already a JSON list representing tags
    }
  }, {
    key: "loadSampleSubmissions",
    value: function loadSampleSubmissions(samples) {// Already a JSON list representing samples
    }
  }, {
    key: "loadNoSubmission",
    value: function loadNoSubmission(assignment) {
      this.model.submission.code(assignment.starting_code);
      Object(_files__WEBPACK_IMPORTED_MODULE_9__["loadConcatenatedFile"])(assignment.extra_starting_files, this.model.submission.extraFiles);
    }
  }, {
    key: "loadSubmission",
    value: function loadSubmission(submission, assignment) {
      if (!submission) {
        // TODO: Scarier "You are not logged in message"
        this.loadNoSubmission(assignment);
        return false;
      } // TODO: What if submissions' assignment version and the assignments' version conflict?


      this.model.submission.id(submission.id);
      this.model.submission.code(submission.code);
      this.model.submission.correct(submission.correct);
      this.model.submission.score(submission.score);
      this.model.submission.endpoint(submission.endpoint);
      this.model.submission.url(submission.url);
      this.model.submission.version(submission.version);
      this.model.submission.gradingStatus(submission.grading_status);
      this.model.submission.submissionStatus(submission.submission_status);
      this.model.submission.ownerId(submission.user_id);
      this.model.user.courseId(submission.course_id);
      Object(_files__WEBPACK_IMPORTED_MODULE_9__["loadConcatenatedFile"])(submission.extra_files, this.model.submission.extraFiles);
    }
  }, {
    key: "loadAssignmentData_",
    value: function loadAssignmentData_(data) {
      console.log(data);
      this.resetInterface();
      this.components.fileSystem.dismountExtraFiles();
      var wasServerConnected = this.model.configuration.serverConnected();
      this.model.configuration.serverConnected(false);
      var assignment = data.assignment;
      this.model.assignment.id(assignment.id);
      this.model.assignment.version(assignment.version);
      this.model.assignment.courseId(assignment.course_id);
      this.model.assignment.forkedId(assignment.forked_id);
      this.model.assignment.forkedVersion(assignment.forked_version);
      this.model.assignment.hidden(assignment.hidden);
      this.model.assignment.reviewed(assignment.reviewed);
      this.model.assignment["public"](assignment["public"]);
      this.model.assignment.type(assignment.type);
      this.model.assignment.url(assignment.url);
      this.model.assignment.ipRanges(assignment.ip_ranges);
      this.model.assignment.instructions(assignment.instructions);
      this.model.assignment.name(assignment.name);
      this.model.assignment.onChange(assignment.on_change || null);

      if (assignment.on_change) {
        this.components.fileSystem.newFile("!on_change.py", assignment.on_change);
      }

      this.model.assignment.onEval(assignment.on_eval || null);

      if (assignment.on_eval) {
        this.components.fileSystem.newFile("!on_eval.py", assignment.on_eval);
      }

      this.model.assignment.onRun(assignment.on_run);
      this.model.assignment.startingCode(assignment.starting_code);
      this.model.assignment.ownerId(assignment.owner_id);
      this.loadTags(assignment.tags);
      this.loadSampleSubmissions(assignment.sample_submissions);
      Object(_files__WEBPACK_IMPORTED_MODULE_9__["loadConcatenatedFile"])(assignment.extra_instructor_files, this.model.assignment.extraInstructorFiles);
      Object(_files__WEBPACK_IMPORTED_MODULE_9__["loadConcatenatedFile"])(assignment.extra_starting_files, this.model.assignment.extraStartingFiles);
      Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_16__["loadAssignmentSettings"])(this.model, assignment.settings);
      this.loadSubmission(data.submission, assignment);
      this.model.display.dirtySubmission(true);
      this.model.display.changedInstructions(null);
      this.model.configuration.serverConnected(wasServerConnected);
      this.components.corgis.loadDatasets(true);
      this.components.pythonEditor.bm.refresh();
      this.components.server.setStatus("saveFile", server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY);
    }
  }, {
    key: "initModelMethods",
    value: function initModelMethods() {
      var _this = this;

      var self = this;
      var model = this.model;
      model.ui = {
        role: {
          isGrader: ko.pureComputed(function () {
            return model.user.role() === "owner" || model.user.role() === "grader";
          })
        },
        instructions: {
          isChanged: ko.pureComputed(function () {
            return model.display.changedInstructions() !== null;
          }),
          current: ko.pureComputed(function () {
            return model.ui.instructions.isChanged() ? self.utilities.markdown(model.display.changedInstructions()) : self.utilities.markdown(model.assignment.instructions());
          }),
          reset: function reset() {
            return model.display.changedInstructions(null);
          }
        },
        menu: {
          textFullscreen: ko.pureComputed(function () {
            return model.display.fullscreen() ? "fa-compress-arrows-alt" : "fa-expand-arrows-alt";
          }),
          clickFullscreen: function clickFullscreen() {
            model.display.fullscreen(!model.display.fullscreen());
          },
          editInputs: function editInputs() {
            _this.components.dialog.EDIT_INPUTS();
          },
          canMarkSubmitted: ko.pureComputed(function () {
            return model.assignment.hidden() || model.assignment.reviewed() || model.assignment.settings.canClose();
          }),
          textMarkSubmitted: ko.pureComputed(function () {
            if (model.ui.menu.isCompleted()) {
              return model.user.groupId() ? "Problem closed" : "Assignment closed";
            } else if (model.ui.menu.isSubmitted()) {
              return "Reopen for editing";
            } else if (model.display.dirtySubmission()) {
              return "Run";
            } else {
              if (!model.assignment.hidden() && model.submission.correct()) {
                return "Submit";
              } else {
                return "Submit early";
              }
            }
          }),
          clickMarkSubmitted: function clickMarkSubmitted() {
            if (model.ui.menu.isCompleted()) {
              alert("You cannot reopen closed assignments. Contact a grader!");
            } else if (model.ui.menu.isSubmitted()) {
              self.components.server.updateSubmissionStatus("inProgress");
            } else if (model.display.dirtySubmission()) {
              self.components.engine.delayedRun();
            } else {
              self.components.server.updateSubmissionStatus("Submitted");
            }
          },
          isSubmitted: ko.pureComputed(function () {
            return (model.assignment.reviewed() || model.assignment.settings.canClose()) && model.submission.submissionStatus().toLowerCase() === "submitted";
          }),
          isCompleted: ko.pureComputed(function () {
            return model.submission.submissionStatus().toLowerCase() === "completed";
          }),
          showQueuedInputs: ko.pureComputed(function () {
            return !model.assignment.settings.hideQueuedInputs();
          })
        },
        secondRow: {
          isAllVisible: ko.pureComputed(function () {
            return !model.assignment.settings.hideMiddlePanel();
          }),
          isFeedbackVisible: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].FEEDBACK;
          }),
          isTraceVisible: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].TRACE;
          }),
          isConsoleShowVisible: ko.pureComputed(function () {
            return model.ui.secondRow.isFeedbackVisible() || model.ui.secondRow.isTraceVisible();
          }),
          switchLabel: ko.pureComputed(function () {
            return model.execution.student.lastStep() !== null ? "View Trace" : "";
          }),
          advanceState: function advanceState() {
            var currentPanel = model.display.secondRowSecondPanel;

            if (currentPanel() === interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].NONE) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].FEEDBACK);
            } else if (currentPanel() === interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].TRACE) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].NONE);
            } else if (model.execution.student.lastStep() !== null) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].TRACE);
            } else {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].NONE);
            }
          }
        },
        console: {
          size: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].NONE ? "col-md-12" : "col-md-6";
          }),
          hideEvaluate: ko.pureComputed(function () {
            return model.assignment.settings.hideEvaluate() || !model.execution.student.globals() || model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].ACTIVE;
          })
        },
        feedback: {
          badge: ko.pureComputed(function () {
            if (model.execution.feedback.category() === null) {
              return "label-none";
            }

            switch (model.execution.feedback.category().toLowerCase()) {
              default:
              case "none":
                return "label-none";

              case "runtime":
                return "label-runtime-error";

              case "syntax":
                return "label-syntax-error";

              case "editor":
                return "label-syntax-error";

              case "internal":
                return "label-internal-error";

              case "semantic":
              case "analyzer":
                return "label-semantic-error";

              case "feedback":
              case "instructor":
                return "label-feedback-error";

              case "complete":
                return "label-problem-complete";

              case "instructions":
                return "label-instructions";

              case "no errors":
                return "label-no-errors";
            }
          }),
          category: ko.pureComputed(function () {
            if (model.execution.feedback.category() === null) {
              return "";
            }

            switch (model.execution.feedback.category().toLowerCase()) {
              default:
              case "none":
                return "";

              case "runtime":
                return "Runtime Error";

              case "syntax":
                return "Syntax Error";

              case "editor":
                return "Editor Error";

              case "internal":
                return "Internal Error";

              case "semantic":
              case "analyzer":
                return "Algorithm Error";

              case "feedback":
              case "instructions":
                return "Instructions";

              case "instructor":
                return "Incorrect Answer";

              case "complete":
                return "Complete";

              case "no errors":
                return "No errors";
            }
          })
        },
        trace: {
          has: ko.pureComputed(function () {
            return model.execution.student.currentTraceData() !== null;
          }),
          line: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData || step === null) {
              return "No trace";
            }

            if (step === 0) {
              return "Before run";
            } else if (step === lastStep) {
              return "Finished run";
            } else {
              // TODO: why are these numbers wonky?
              return "Line " + (traceData[step].line - 1);
            }
          }),
          first: function first() {
            model.execution.student.currentTraceStep(0);
          },
          backward: function backward() {
            var previous = Math.max(0, model.execution.student.currentTraceStep() - 1);
            model.execution.student.currentTraceStep(previous);
          },
          forward: function forward() {
            var next = Math.min(model.execution.student.lastStep(), model.execution.student.currentTraceStep() + 1);
            model.execution.student.currentTraceStep(next);
          },
          last: function last() {
            model.execution.student.currentTraceStep(model.execution.student.lastStep());
          },
          data: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData) {
              return [];
            }

            switch (step) {
              case 0:
                return [];

              case lastStep:
                return traceData[step - 1];

              default:
                return traceData[step];
            }
          })
        },
        files: {
          visible: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.hideFiles();
          }),
          hasContents: function hasContents(path) {
            switch (path) {
              case "answer.py":
                return model.submission.code();

              case "!instructions.md":
                return model.assignment.instructions();

              case "!on_change.py":
                return model.assignment.onChange() !== null;

              case "!on_eval.py":
                return model.assignment.onEval() !== null;

              case "?mock_urls.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?mock_urls.blockpy";
                });

              case "?toolbox.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?toolbox.blockpy";
                });

              case "!tags.blockpy":
                return model.assignment.tags().length;

              case "!sample_submissions.blockpy":
                return model.assignment.sampleSubmissions().length;

              default:
                return false;
            }
          },
          add: function add(path) {
            switch (path) {
              case "?mock_urls.blockpy":
              case "?tags.blockpy":
              case "?settings.blockpy":
                self.components.fileSystem.newFile(path);
                break;

              case "?toolbox.blockpy":
                var normalToolbox = self.components.pythonEditor.bm.blockEditor.TOOLBOXES["normal"];
                normalToolbox = JSON.stringify(normalToolbox, null, 2);
                self.components.fileSystem.newFile(path, normalToolbox);
                break;
                break;

              case "!sample_submissions.blockpy":
                model.assignment.sampleSubmissions([_editor_sample_submissions__WEBPACK_IMPORTED_MODULE_20__["SampleSubmission"].Blank()]);
                self.components.fileSystem.newFile(path);
                break;

              case "!on_change.py":
                model.assignment.onChange("");
                self.components.fileSystem.newFile(path);
                break;
              // TODO fix extrafiles for instructor and student

              case "!on_eval.py":
                model.assignment.onEval("");
                self.components.fileSystem.newFile(path);
                break;

              case "instructor":
                self.components.fileSystem.newFileDialog("instructor");
                return;

              case "student":
                self.components.fileSystem.newFileDialog("student");
                return;

              case "starting":
                self.components.fileSystem.newFileDialog("starting");
                return;

              default:
            }

            model.display.filename(path);
          },
          "delete": function _delete() {
            return self.components.fileSystem.deleteFile(model.display.filename());
          },
          extraStudentFiles: Object(_files__WEBPACK_IMPORTED_MODULE_9__["observeConcatenatedFile"])(model.submission.extraFiles),
          extraInstructorFiles: Object(_files__WEBPACK_IMPORTED_MODULE_9__["observeConcatenatedFile"])(model.assignment.extraInstructorFiles),
          extraStartingFiles: Object(_files__WEBPACK_IMPORTED_MODULE_9__["observeConcatenatedFile"])(model.assignment.extraStartingFiles),
          displayFilename: function displayFilename(path) {
            if (path === "?mock_urls.blockpy") {
              return "URL Data";
            }

            if (path === "?toolbox.blockpy") {
              return "Toolbox";
            }

            if (path.startsWith("&")) {
              return path.slice(1);
            }

            return path;
          }
        },
        editors: {
          current: ko.pureComputed(function () {
            return self.components.editors.getEditor(model.display.filename());
          }),
          view: ko.pureComputed(function () {
            return !model.display.instructor() && model.assignment.settings.hideEditors() ? "None" : model.display.filename() ? model.ui.editors.current() : "None";
          }),
          reset: function reset() {
            self.components.server.logEvent("X-File.Reset", "", "", "", "answer.py");
            model.submission.code(model.assignment.startingCode());
            model.submission.extraFiles(model.assignment.extraStartingFiles().map(function (file) {
              var filename = file.filename().substr(1);
              return Object(_files__WEBPACK_IMPORTED_MODULE_9__["makeModelFile"])(filename, file.contents());
            }));
          },
          canSave: ko.pureComputed(function () {
            return !model.display.autoSave();
          }),
          canDelete: ko.pureComputed(function () {
            return (!model.assignment.settings.hideFiles() || model.display.instructor()) && _files__WEBPACK_IMPORTED_MODULE_9__["UNDELETABLE_FILES"].indexOf(model.display.filename()) === -1;
          }),
          canRename: ko.pureComputed(function () {
            return (!model.assignment.settings.hideFiles() || model.display.instructor()) && _files__WEBPACK_IMPORTED_MODULE_9__["UNRENAMABLE_FILES"].indexOf(model.display.filename()) === -1;
          }),
          upload: _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_10__["uploadFile"].bind(self),
          download: _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_10__["downloadFile"].bind(self),
          importDataset: function importDataset() {
            self.components.corgis.openDialog();
          },
          python: {
            fullscreen: function fullscreen() {
              var codeMirror = self.components.pythonEditor.bm.textEditor.codeMirror;
              return codeMirror.setOption("fullScreen", !codeMirror.getOption("fullScreen"));
            },
            updateMode: function updateMode(newMode) {
              self.components.server.logEvent("X-View.Change", "", "", newMode, model.display.filename());
              model.display.pythonMode(newMode);

              if (model.display.filename() === "answer.py") {
                self.components.pythonEditor.oldPythonMode = newMode;
              }
            },
            isHistoryAvailable: ko.pureComputed(function () {
              return model.ui.server.isEndpointConnected("loadHistory");
            }),
            turnOffHistoryMode: function turnOffHistoryMode() {
              self.components.pythonEditor.updateEditor();
              self.components.pythonEditor.setReadOnly(false);
              model.display.historyMode(false);
            },
            turnOnHistoryMode: function turnOnHistoryMode() {
              self.components.server.loadHistory(function (response) {
                if (response.success) {
                  self.components.history.load(response.history);
                  model.display.historyMode(true);
                  self.components.pythonEditor.setReadOnly(true);
                } else {
                  self.components.dialog.ERROR_LOADING_HISTORY();
                }
              });
            },
            toggleHistoryMode: function toggleHistoryMode() {
              if (model.display.historyMode()) {
                model.ui.editors.python.turnOffHistoryMode();
              } else {
                model.ui.editors.python.turnOnHistoryMode();
              }
            },
            history: {
              start: function start() {
                self.components.history.moveToStart();
              },
              previous: function previous() {
                self.components.history.movePrevious();
              },
              next: function next() {
                self.components.history.moveNext();
              },
              mostRecent: function mostRecent() {
                self.components.history.moveToMostRecent();
              },
              use: function use() {
                self.components.history.use();
              }
            }
          },
          settings: {
            save: function save() {
              return self.components.server.saveAssignment();
            }
          },
          sampleSubmissions: {
            buildEditor: function buildEditor(newDOM, index, newElement) {
              var editor = self.components.editors.byName("Sample Submissions");
              editor.buildEditor(newDOM, index, newElement);
            }
          }
        },
        execute: {
          isRunning: ko.pureComputed(function () {
            return model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].ACTIVE;
          }),
          run: function run() {
            return self.components.engine.delayedRun();
          },
          evaluate: function evaluate() {
            return self.components.engine.evaluate();
          }
        },
        server: {
          status: function status(endpoint) {
            return "server-status-" + model.status[endpoint]();
          },
          isEndpointConnected: function isEndpointConnected(endpoint) {
            return model.configuration.serverConnected() && model.configuration.urls !== undefined && model.configuration.urls[endpoint] !== undefined;
          },
          messages: ko.pureComputed(function () {
            return Object(_utilities__WEBPACK_IMPORTED_MODULE_19__["capitalize"])(model.status.loadAssignmentMessage() || model.status.saveAssignmentMessage() || model.status.loadHistoryMessage() || model.status.loadFileMessage() || model.status.saveFileMessage() || model.status.loadDatasetMessage() || model.status.logEventMessage() || model.status.saveImage() || model.status.updateSubmissionMessage() || model.status.updateSubmissionStatusMessage() || "");
          }),
          force: {
            loadAssignment: function loadAssignment(data, event) {
              //let fileHandler = $(".blockpy-force-load-assignment-file");
              var assignmentForceLoadButton = jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target); //fileHandler.click();

              jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target).parent().fadeOut(100).fadeIn(100); // Allow user to upload a file containing an assignment submission

              var fr = new FileReader();
              var files = assignmentForceLoadButton[0].files;

              fr.onload = function (e) {
                var assignmentSubmission = JSON.parse(e.target.result);
                self.loadAssignmentData_(assignmentSubmission);
              };

              fr.fileName = files[0].name;
              fr.readAsText(files[0]);
              assignmentForceLoadButton.val("");
            },
            updateSubmission: function updateSubmission(data, event) {
              console.log(event);
              self.components.server.updateSubmission(self.model.submission.score(), self.model.submission.correct(), false, true);
              jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target).fadeOut(100).fadeIn(100);
            }
          }
        }
      };
      Object(interface_js__WEBPACK_IMPORTED_MODULE_8__["makeExtraInterfaceSubscriptions"])(self, model);
    }
  }, {
    key: "turnOnHacks",
    value: function turnOnHacks() {
      //console.log("TODO");
      Sk.builtinFiles.files["src/lib/image.js"] = skulpt_modules_image__WEBPACK_IMPORTED_MODULE_3__["$builtinmodule"].toString(); //Sk.builtinFiles.files["src/lib/matplotlib/pyplot/__init__.js"] = matplotlibModule.toString();
    }
    /**
     * Applys the KnockoutJS bindings to the model, instantiating the values into the
     * HTML.
     */

  }, {
    key: "applyModel",
    value: function applyModel() {
      ko.applyBindings(this.model);
    }
  }, {
    key: "initUtilities",
    value: function initUtilities() {
      var main = this;
      this.utilities = {
        markdown: function markdown(text) {
          return text ? EasyMDE.prototype.markdown(text) : "<p></p>";
        }
      };
    }
  }, {
    key: "initComponents",
    value: function initComponents() {
      var container = this.model.configuration.container;
      var components = this.components = {};
      var main = this; // Each of these components will take the BlockPy instance, and possibly a
      // reference to the relevant HTML location where it will be embedded.

      components.dialog = new _dialog__WEBPACK_IMPORTED_MODULE_15__["BlockPyDialog"](main, container.find(".blockpy-dialog"));
      components.feedback = new feedback_js__WEBPACK_IMPORTED_MODULE_14__["BlockPyFeedback"](main, container.find(".blockpy-feedback"));
      components.trace = new _trace__WEBPACK_IMPORTED_MODULE_12__["BlockPyTrace"](main);
      components.console = new _console__WEBPACK_IMPORTED_MODULE_13__["BlockPyConsole"](main, container.find(".blockpy-console"));
      components.engine = new engine_js__WEBPACK_IMPORTED_MODULE_11__["BlockPyEngine"](main);
      components.fileSystem = new _files__WEBPACK_IMPORTED_MODULE_9__["BlockPyFileSystem"](main);
      components.editors = new editors_js__WEBPACK_IMPORTED_MODULE_5__["Editors"](main, container.find(".blockpy-editor")); // Convenient shortcut directly to PythonEditor

      components.pythonEditor = this.components.editors.byName("python");
      components.server = new server_js__WEBPACK_IMPORTED_MODULE_7__["BlockPyServer"](main);
      components.corgis = new _corgis__WEBPACK_IMPORTED_MODULE_17__["BlockPyCorgis"](main);
      components.history = new _history__WEBPACK_IMPORTED_MODULE_18__["BlockPyHistory"](main, container.find(".blockpy-history-toolbar"));
    }
  }, {
    key: "makeExtraSubscriptions",
    value: function makeExtraSubscriptions() {
      var _this2 = this;

      this.model.display.changedInstructions.subscribe(function (changed) {
        _this2.components.server.logEvent("X-Instructions.Change", "", "", changed, "instructions.md");
      });
    }
  }, {
    key: "start",
    value: function start() {
      this.model.display.filename("answer.py");
    }
  }, {
    key: "resetInterface",
    value: function resetInterface() {
      this.components.engine.reset();
    }
  }, {
    key: "requestPasscode",
    value: function requestPasscode() {
      var userSuppliedPasscode = prompt("Please enter the passcode.");
      this.model.display.passcode(userSuppliedPasscode);
    }
  }]);

  return BlockPy;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/console.js":
/*!************************!*\
  !*** ./src/console.js ***!
  \************************/
/*! exports provided: CONSOLE_HTML, ConsoleLineType, BlockPyConsole */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONSOLE_HTML", function() { return CONSOLE_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConsoleLineType", function() { return ConsoleLineType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyConsole", function() { return BlockPyConsole; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


/**
 * Evaluate button HTML template
 * @type {string}
 */

var START_EVAL_HTML = "\n<button type=\"button\" class=\"btn btn-sm btn-outline float-right blockpy-btn-eval\">\n    Evaluate\n</button>";
/**
 * HTML template for a new line in the console.
 * @type {string}
 */

var NEW_CONSOLE_LINE_HTML = "<div></div>";
/**
 * HTML template for the entire console area
 * @type {string}
 */

var CONSOLE_HTML = "\n    <div class='col-md-6 blockpy-panel blockpy-console'\n          role=\"region\" aria-label=\"Console\"\n          data-bind=\"class: ui.console.size\">\n          \n        <!-- Feedback/Trace Visibility Control -->\n        <button type='button'\n                class='btn btn-sm btn-outline-secondary float-right blockpy-show-feedback'\n                data-bind=\"hidden: ui.secondRow.isConsoleShowVisible, click: ui.secondRow.advanceState\">\n            <span class='fas fa-eye'></span>\n        </button>\n          \n        <strong>Console:</strong>\n        \n        <div class='blockpy-printer blockpy-printer-default'>\n        </div>\n        \n     </div>";
/**
 * All the possible types for a line in the console.
 * @enum
 */

var ConsoleLineType = {
  TEXT: "text",
  HTML: "html",
  PLOT: "plot",
  IMAGE: "image",
  PYGAME: "pygame",
  TURTLE: "turtle",
  EVAL: "eval",
  START_EVAL: "start_eval",
  VALUE: "value",
  INPUT: "input",
  TEST_CASE: "test_case"
};
/**
 * Abstract version of a line in the console. All other console lines
 * should extend this class. Critically, they need to implement a render function.
 */

var ConsoleLine = /*#__PURE__*/function () {
  function ConsoleLine(main, type, content) {
    _classCallCheck(this, ConsoleLine);

    /**
     * Reference back to the main BlockPy instance.
     * @const
     * @type {BlockPy}
     */
    this.main = main;
    /**
     * Categorizes what kind of line this is (text/html/plot/etc.)
     * @type {ConsoleLineType}
     */

    this.type = type;
    /**
     * The actual data stored on this line.
     * @type {string}
     */

    this.content = content;
    /**
     * Metadata about where the line originated from in the code.
     * @type {{filename: string, line: number, step: number}}
     */

    this.origin = {
      filename: Sk.currFilename,
      step: main.components.engine.executionBuffer.step,
      line: main.components.engine.executionBuffer.line
    };
    /**
     * The HTML content stored on this line, meant to be rendered
     * to the user.
     * @type {*|jQuery.fn.init|jQuery|HTMLElement}
     */

    this.html = $("<div></div>", {
      "class": "blockpy-printer-output",
      "data-container": main.model.configuration.attachmentPoint,
      "data-toggle": "tooltip",
      "data-placement": "auto",
      "data-step": this.origin.step,
      "title": "Step " + this.origin.step + ", Line " + this.origin.line
    });
    /**
     * Whether or not this line should be visible
     * @type {boolean}
     */

    this.visible = !main.model.display.mutePrinter();
    /**
     *
     * @type {number}
     */

    this.index = 0;
  }
  /**
   * Create a Skulpt representation of this console line's content.
   * @returns {*}
   */


  _createClass(ConsoleLine, [{
    key: "toSkulpt",
    value: function toSkulpt() {
      return Sk.ffi.remapToPy(this.content);
    }
    /**
     * Remove this console line by deleting its HTML representation.
     */

  }, {
    key: "delete",
    value: function _delete() {
      this.html.remove();
    }
  }]);

  return ConsoleLine;
}();

var ConsoleLineTurtle = /*#__PURE__*/function (_ConsoleLine) {
  _inherits(ConsoleLineTurtle, _ConsoleLine);

  var _super = _createSuper(ConsoleLineTurtle);

  // TODO: Capture turtle commands for tracing purposes
  function ConsoleLineTurtle(main) {
    var _this;

    _classCallCheck(this, ConsoleLineTurtle);

    _this = _super.call(this, main, ConsoleLineType.TURTLE);

    _this.html.addClass("blockpy-console-turtle-output");

    return _this;
  }

  _createClass(ConsoleLineTurtle, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        where.prepend(this.html); //this.html[0].scrollIntoView({ behavior: "smooth" });

        var top = this.html.position().top; //$('html').scrollTop(top);

        $("html").scrollTop(0); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineTurtle;
}(ConsoleLine);

var ConsoleLinePygame = /*#__PURE__*/function (_ConsoleLine2) {
  _inherits(ConsoleLinePygame, _ConsoleLine2);

  var _super2 = _createSuper(ConsoleLinePygame);

  function ConsoleLinePygame(main, size, fullscreen, pygameObj) {
    var _this2;

    _classCallCheck(this, ConsoleLinePygame);

    _this2 = _super2.call(this, main, ConsoleLineType.PYGAME);

    _this2.html.addClass("blockpy-console-pygame-output");

    _this2.size = size;
    _this2.fullscreen = fullscreen;
    _this2.pygameObj = pygameObj;
    _this2.initialized = false;
    _this2.canvas = document.createElement("canvas"); //Sk.main_canvas = document.getElementById("myCanvas");

    return _this2;
  }

  _createClass(ConsoleLinePygame, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        this.html.append(this.canvas);
        where.prepend(this.html);
        var top = this.html.position().top;
        $("html").scrollTop(0);
      }
    }
  }, {
    key: "cleanup",
    value: function cleanup() {// Starts off as a no-op
    }
  }, {
    key: "stop",
    value: function stop() {
      this.cleanup = function () {};
    }
  }, {
    key: "finalize",
    value: function finalize(cleanupFunction, listeners) {
      var _this3 = this;

      this.initialized = true;

      this.cleanup = function () {
        return cleanupFunction(_this3.pygameObj, listeners);
      };
    }
  }]);

  return ConsoleLinePygame;
}(ConsoleLine);

var ConsoleLineImage = /*#__PURE__*/function (_ConsoleLine3) {
  _inherits(ConsoleLineImage, _ConsoleLine3);

  var _super3 = _createSuper(ConsoleLineImage);

  function ConsoleLineImage(main, content) {
    var _this4;

    _classCallCheck(this, ConsoleLineImage);

    _this4 = _super3.call(this, main, ConsoleLineType.IMAGE, content);

    _this4.html.addClass("blockpy-console-image-output");

    return _this4;
  }

  _createClass(ConsoleLineImage, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        console.log(this.content);
        this.html.append(this.content);
        where.append(this.html); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineImage;
}(ConsoleLine);

var ConsoleLinePlot = /*#__PURE__*/function (_ConsoleLine4) {
  _inherits(ConsoleLinePlot, _ConsoleLine4);

  var _super4 = _createSuper(ConsoleLinePlot);

  function ConsoleLinePlot(main, content) {
    var _this5;

    _classCallCheck(this, ConsoleLinePlot);

    _this5 = _super4.call(this, main, ConsoleLineType.PLOT, content);

    _this5.html.addClass("blockpy-console-plot-output");

    return _this5;
  }

  _createClass(ConsoleLinePlot, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        where.append(this.html); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLinePlot;
}(ConsoleLine);

var ConsoleLineText = /*#__PURE__*/function (_ConsoleLine5) {
  _inherits(ConsoleLineText, _ConsoleLine5);

  var _super5 = _createSuper(ConsoleLineText);

  function ConsoleLineText() {
    _classCallCheck(this, ConsoleLineText);

    return _super5.apply(this, arguments);
  }

  _createClass(ConsoleLineText, [{
    key: "addContent",
    value: function addContent(content) {
      this.content = this.content + content;
    }
  }, {
    key: "render",
    value: function render(where) {
      if (this.visible) {
        var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);

        if (!encodedText || encodedText.trim().length <= 0) {
          encodedText = "\n";
        }

        var lineData = $("<samp></samp>", {
          "html": encodedText
        });
        this.html.append(lineData);
        where.append(this.html);
        this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineText;
}(ConsoleLine);

var ConsoleLineValue = /*#__PURE__*/function (_ConsoleLine6) {
  _inherits(ConsoleLineValue, _ConsoleLine6);

  var _super6 = _createSuper(ConsoleLineValue);

  function ConsoleLineValue(main, content) {
    _classCallCheck(this, ConsoleLineValue);

    return _super6.call(this, main, ConsoleLineType.VALUE, content);
  }

  _createClass(ConsoleLineValue, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);
        var lineData = $("<code></code>", {
          "html": encodedText
        });
        this.html.append(lineData);
        where.append(this.html);
        this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineValue;
}(ConsoleLine);

var ConsoleLineInput = /*#__PURE__*/function (_ConsoleLine7) {
  _inherits(ConsoleLineInput, _ConsoleLine7);

  var _super7 = _createSuper(ConsoleLineInput);

  function ConsoleLineInput(main, promptMessage) {
    var _this6;

    _classCallCheck(this, ConsoleLineInput);

    _this6 = _super7.call(this, main, ConsoleLineType.INPUT, promptMessage);
    _this6.visible = true;
    return _this6;
  }
  /**
   * Creates an Input box for receiving input() from the user.
   *
   */


  _createClass(ConsoleLineInput, [{
    key: "render",
    value: function render(where) {
      // Perform any necessary cleaning
      if (this.visible) {
        // Input form
        var inputForm = $("<input type='text' />"); // Enter button

        var inputBtn = $("<button></button>", {
          "html": "Enter"
        }); // Group form and button

        var inputGroup = $("<div></div>", {
          "class": "blockpy-console-input"
        });
        inputGroup.append(inputForm);
        inputGroup.append(inputBtn); // Prompt box, new line, input group

        var inputBox = $("<div></div>");

        if (this.content !== "\n") {
          var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);
          var inputMsg = $("<samp></samp>", {
            "html": encodedText
          });
          inputBox.append(inputMsg);
        }

        inputBox.append($("<br>")).append(inputGroup); // Render

        this.html.append(inputBox);
        where.append(this.html); // Make it interactive

        return this.makeInteractive(inputForm, inputBtn);
      }

      return "";
    }
  }, {
    key: "makeInteractive",
    value: function makeInteractive(input, button) {
      var _this7 = this;

      var resolveOnClick;
      var submittedPromise = new Promise(function (resolve) {
        resolveOnClick = resolve;
      });
      var inputIndex = this.main.model.execution.inputIndex();

      var submitForm = function submitForm() {
        var userInputtedValue = input.val();
        Sk.queuedInput.push(userInputtedValue);

        _this7.main.model.execution.inputIndex(inputIndex + 1);

        _this7.main.model.execution.input().push(userInputtedValue);

        resolveOnClick(userInputtedValue);
        input.prop("disabled", true);
        button.prop("disabled", true);

        _this7.html.tooltip();
      };

      button.click(submitForm);
      input.keyup(function (e) {
        if (e.keyCode === 13) {
          submitForm();
        }
      });
      input.focus();

      if (inputIndex < this.main.model.execution.input().length) {
        var userInputtedValue = this.main.model.execution.input()[inputIndex];
        input.val(userInputtedValue);
        this.main.model.execution.inputIndex(inputIndex + 1);
        return new Promise(function (resolve) {
          input.prop("disabled", true);
          button.prop("disabled", true);

          _this7.html.tooltip();

          resolve(userInputtedValue);
        });
      }

      return submittedPromise;
    }
  }]);

  return ConsoleLineInput;
}(ConsoleLine);

var ConsoleLineEvaluate = /*#__PURE__*/function (_ConsoleLineInput) {
  _inherits(ConsoleLineEvaluate, _ConsoleLineInput);

  var _super8 = _createSuper(ConsoleLineEvaluate);

  function ConsoleLineEvaluate(main) {
    _classCallCheck(this, ConsoleLineEvaluate);

    return _super8.call(this, main, "Evaluate:");
  }

  return ConsoleLineEvaluate;
}(ConsoleLineInput);

var ConsoleLineStartEvaluate = /*#__PURE__*/function (_ConsoleLine8) {
  _inherits(ConsoleLineStartEvaluate, _ConsoleLine8);

  var _super9 = _createSuper(ConsoleLineStartEvaluate);

  function ConsoleLineStartEvaluate(main) {
    var _this8;

    _classCallCheck(this, ConsoleLineStartEvaluate);

    _this8 = _super9.call(this, main, ConsoleLineType.START_EVAL);

    _this8.html.append($(START_EVAL_HTML));

    _this8.html.click(function () {
      _this8.main.model.ui.execute.evaluate();

      _this8["delete"]();
    });

    return _this8;
  }

  _createClass(ConsoleLineStartEvaluate, [{
    key: "render",
    value: function render(where) {
      where.append(this.html);
    }
  }]);

  return ConsoleLineStartEvaluate;
}(ConsoleLine);

var BlockPyConsole = /*#__PURE__*/function () {
  /**
   * An object for managing the console, with features for things like printing, plotting, evaling, inputing.
   * The "printer" is the region where we put things, as opposed to the console as a whole.
   *
   * @constructor
   * @param {Object} main - The main BlockPy instance
   * @param {HTMLElement} tag - The HTML object this is attached to.
   */
  function BlockPyConsole(main, tag) {
    _classCallCheck(this, BlockPyConsole);

    this.main = main;
    this.tag = tag;
    this.printerTag = tag.find(".blockpy-printer");
    this.MINIMUM_WIDTH = 200;
    this.MINIMUM_HEIGHT = 200;
    this.DEFAULT_HEIGHT = this.printerTag.height(); // Let CSS define this

    this.main.model.display.previousConsoleHeight(this.DEFAULT_HEIGHT);
    this.output = this.main.model.execution.output; //this.input = this.main.model.execution.input;

    this.settings = {};
    this.clear(); // TODO: If the user modifies a file, then make the console look faded a little
  }

  _createClass(BlockPyConsole, [{
    key: "clear",

    /**
     * Reset the status of the printer, including removing any text in it and
     * fixing its size.
     */
    value: function clear() {
      this.output.removeAll();
      this.lineBuffer = null;
      this.plotBuffer = null;
      this.printerTag.empty(); // If the user hasn't changed the console size, we'll reset it

      if (this.main.model.display.previousConsoleHeight() === this.printerTag.height()) {
        this.printerTag.height(this.DEFAULT_HEIGHT);
        this.main.model.display.previousConsoleHeight(this.printerTag.height());
      }

      this.turtleLine = null;
      Sk.TurtleGraphics = {
        target: this.getTurtleLine.bind(this),
        width: this.getWidth(),
        height: this.getHeight(),
        assets: this.loadAsset.bind(this)
      };
      this.pygameLine = null;
    }
  }, {
    key: "loadAsset",
    value: function loadAsset(name) {
      return name;
    }
  }, {
    key: "getTurtleLine",
    value: function getTurtleLine() {
      if (this.turtleLine === null) {
        this.turtleLine = new ConsoleLineTurtle(this.main);
        this.turtleLine.render(this.printerTag); // If the user hasn't changed the console size, we'll do so

        if (this.main.model.display.previousConsoleHeight() === this.printerTag.height()) {
          var currentPrinterDimension = this.printerTag.width();
          this.printerTag.height(currentPrinterDimension);
          this.main.model.display.previousConsoleHeight(this.printerTag.height());
          Sk.TurtleGraphics.height = currentPrinterDimension - 40;
        }
      }

      return this.turtleLine.html[0];
    }
  }, {
    key: "finishTurtles",
    value: function finishTurtles() {
      if (this.main.model.assignment.settings.saveTurtleOutput()) {
        if (this.turtleLine) {
          var canvas = this.turtleLine.html.find("canvas").last()[0];
          var ctx = canvas.getContext("2d");
          var img = new Image();
          var dataUrl = canvas.toDataURL("image/png");
          this.main.components.server.saveImage("turtle_output", dataUrl);
        } else {// TODO: What if there are no turtles to save?
        }
      }
    } // TODO: turtles should be based on the current width

  }, {
    key: "newTurtle",
    value: function newTurtle() {
      return this;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return Math.max(this.MINIMUM_WIDTH, this.printerTag.width() - 40);
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return Math.max(this.MINIMUM_HEIGHT, this.printerTag.height() + 40);
    }
  }, {
    key: "isMuted",
    value: function isMuted() {
      return this.main.model.display.mutePrinter();
    }
    /**
     * Updates each printed element in the printer and makes it hidden
     * or visible, depending on what step we're on.
     *
     * @param {Number} step - The current step of the executed program that we're on; each element in the printer must be marked with a "data-step" property to resolve this.
     * @param {Number} page - Deprecated, not sure what this even does.
     */

  }, {
    key: "stepPrinter",
    value: function stepPrinter(step, page) {
      this.printerTag.find(".blockpy-printer-output").each(function () {
        if ($(this).attr("data-step") <= step) {
          $(this).show();
        } else {
          $(this).hide();
        }
      });
    }
  }, {
    key: "print",

    /**
     * Print a line to the on-screen printer.
     * @param {String} lineText - A line of text to be printed out.
     */
    value: function print(lineText) {
      // Empty strings means do nothing.
      // print("", end="")
      if (!lineText) {
        return;
      }

      var flush = false;

      if (lineText.charAt(lineText.length - 1) === "\n") {
        flush = true;
      }

      var splitLines = lineText.split("\n");

      if (this.lineBuffer === null) {
        this.lineBuffer = new ConsoleLineText(this.main, ConsoleLineType.TEXT, splitLines[0]);
      } else {
        this.lineBuffer.addContent(splitLines[0]);
      }

      for (var i = 1; i < splitLines.length - 1; i++) {
        this.output.push(this.lineBuffer);
        this.lineBuffer.render(this.printerTag);
        this.lineBuffer = new ConsoleLineText(this.main, ConsoleLineType.TEXT, splitLines[i]);
      }

      if (flush) {
        this.output.push(this.lineBuffer);
        this.lineBuffer.render(this.printerTag);
        this.lineBuffer = null;
      }
    }
  }, {
    key: "plot",
    value: function plot(plots) {
      this.plotBuffer = new ConsoleLinePlot(this.main, plots);
      this.plotBuffer.render(this.printerTag);
      return this.plotBuffer;
    }
  }, {
    key: "pygame",
    value: function pygame(size, fullscreen, pygameObj) {
      if (this.pygameLine === null) {
        this.pygameLine = new ConsoleLinePygame(this.main, size, fullscreen, pygameObj);
        this.pygameLine.render(this.printerTag);
      }

      return this.pygameLine;
    }
  }, {
    key: "printPILImage",
    value: function printPILImage(imageData) {
      console.log("TEST", imageData.image);
      this.imageBuffer = new ConsoleLineImage(this.main, imageData.image);
      this.imageBuffer.render(this.printerTag);
      return this.imageBuffer;
    }
  }, {
    key: "printValue",
    value: function printValue(value) {
      var printedValue = new ConsoleLineValue(this.main, value);
      printedValue.render(this.printerTag);
      return printedValue;
    }
    /**
     * Creates and registers a Promise from the Input box
     * @param {String} promptMessage - Message to display to the user.
     *
     */

  }, {
    key: "input",
    value: function input(promptMessage) {
      this.inputBuffer = new ConsoleLineInput(this.main, promptMessage);
      return this.inputBuffer.render(this.printerTag);
    }
  }, {
    key: "evaluate",
    value: function evaluate() {
      this.inputBuffer = new ConsoleLineEvaluate(this.main);
      return this.inputBuffer.render(this.printerTag);
    }
  }, {
    key: "beginEval",
    value: function beginEval() {
      var startEvaluation = new ConsoleLineStartEvaluate(this.main);
      return startEvaluation.render(this.printerTag);
    }
    /**
     * Unconditionally scroll to the bottom of the window.
     *
     */

  }, {
    key: "scrollToBottom",
    value: function scrollToBottom() {
      this.tag.animate({
        scrollTop: this.tag.prop("scrollHeight") - this.tag.prop("clientHeight")
      }, 500);
    }
  }]);

  return BlockPyConsole;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/corgis.js":
/*!***********************!*\
  !*** ./src/corgis.js ***!
  \***********************/
/*! exports provided: _IMPORTED_DATASETS, _IMPORTED_COMPLETE_DATASETS, BlockPyCorgis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_DATASETS", function() { return _IMPORTED_DATASETS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_COMPLETE_DATASETS", function() { return _IMPORTED_COMPLETE_DATASETS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyCorgis", function() { return BlockPyCorgis; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
 // TODO: editor.bm.blockEditor.extraTools[]

var _IMPORTED_DATASETS = {};
var _IMPORTED_COMPLETE_DATASETS = {};
/**
 * This is a very simplistic helper function that will transform
 * a given button into a "Loaded" state (disabled, pressed state, etc.).
 *
 * @param {HTMLElement} btn - An HTML element to change the text of.
 */

var setButtonLoaded = function setButtonLoaded(btn) {
  btn.addClass("active").addClass("btn-success").removeClass("btn-primary").prop("disabled", true).text("Loaded").attr("aria-pressed", "true");
};
/**
 * Module that connects to the CORGIS datasets and manages interactions
 * with them. This includes loading in datasets at launch and on-the-fly.
 * Note that this has no presence on screen, so it does not have a tag.
 *
 * @constructor
 * @this {BlockPyCorgis}
 * @param {Object} main - The main BlockPy instance
 */


function BlockPyCorgis(main) {
  this.main = main;
  this.loadedDatasets = [];
  this.loadDatasets();
}

BlockPyCorgis.prototype.loadDatasets = function (silently) {
  var _this = this;

  // Load in each the datasets
  var model = this.main.model,
      editor = this.main.components.pythonEditor,
      server = this.main.components.server;
  var imports = [];
  model.assignment.settings.datasets().split(",").forEach(function (name) {
    if (name && !(name in BlockMirrorBlockEditor.EXTRA_TOOLS)) {
      imports.push.apply(imports, _this.importDataset(Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["slug"])(name), name, silently));
    }
  }); // When datasets are loaded, update the toolbox.

  $.when.apply($, imports).done(function () {
    //console.log("TRIGGERED");
    editor.bm.forceBlockRefresh();
    editor.bm.blockEditor.remakeToolbox();
  }).fail(function (e) {
    console.log(arguments);
    console.error(e);
  }).always(function () {
    server.finalizeSubscriptions();
  });
};
/**
 * Loads the definitions for a dataset into the environment, including
 * the dataset (as a JS file), the skulpt bindings, and the blockly
 * bindings. This requires access to a CORGIS server, and occurs
 * asynchronously. The requests are fired and their deferred objects
 * are returned - callers can use this information to perform an action
 * on completion of the import.
 *
 * @param {String} slug - The URL safe version of the dataset name
 * @param {String} name - The user-friendly version of the dataset name.
 * @returns {Array.<Deferred>} - Returns the async requests as deferred objects.
 */


BlockPyCorgis.prototype.importDataset = function (slug, name) {
  var _this2 = this;

  var url_retrievals = [];

  if (this.main.model.ui.server.isEndpointConnected("importDatasets")) {
    var root = this.main.model.configuration.urls.importDatasets + "blockpy/" + slug + "/" + slug;
    this.main.model.display.loadingDatasets.push(name); // Actually get data

    var getDataset = $.getScript(root + "_dataset.js"); // Load getComplete silently in the background because its big :(

    var getComplete = $.getScript(root + "_complete.js");
    var getSkulpt = $.get(root + "_skulpt.js", function (data) {
      Sk.builtinFiles["files"]["src/lib/" + slug + "/__init__.js"] = data;
    });
    var getBlockly = $.getScript(root + "_blockly.js"); // On completion, update menus.

    $.when(getDataset, getSkulpt, getBlockly).done(function () {
      _this2.loadedDatasets.push(slug);

      _this2.main.components.pythonEditor.bm.textToBlocks.hiddenImports.push(slug);

      _this2.main.components.pythonEditor.bm.forceBlockRefresh();

      _this2.main.components.pythonEditor.bm.blockEditor.remakeToolbox();

      _this2.main.model.display.loadingDatasets.remove(name);
    });
    url_retrievals.push(getDataset, getSkulpt, getBlockly);
  }

  return url_retrievals;
};
/**
 * Opens a dialog box to present the user with the datasets available
 * through the CORGIS server. This requires a call, so this method
 * completes asynchronously. The dialog is composed of a table with
 * buttons to load the datasets (More than one dataset can be loaded
 * from within the dialog at a time).
 */


BlockPyCorgis.prototype.openDialog = function () {
  var _this3 = this;

  if (this.main.model.ui.server.isEndpointConnected("importDatasets")) {
    var root = this.main.model.configuration.urls.importDatasets;
    $.getJSON(root + "index.json", function (data) {
      // Make up the Body
      var datasets = data.blockpy;
      var documentation = root + "blockpy/index.html";
      var start = $("<p>Documentation is available at <a href='".concat(documentation, "' target=_blank>url</a></p>"));
      var body = $("<table></table>", {
        "class": "table table-bordered table-sm table-striped"
      });
      Object.keys(datasets).sort().map(function (name) {
        var sluggedName = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["slug"])(datasets[name].name);
        var titleName = name;
        var btn = $('<button type="button" class="btn btn-primary" data-toggle="button" aria-pressed="false" autocomplete="off">Load</button>');
        var imgSrc = root + "../images/datasets/" + name + "-icon.png";

        if (_this3.loadedDatasets.indexOf(sluggedName) > -1) {
          setButtonLoaded(btn);
        } else {
          btn.click(function () {
            _this3.importDataset(sluggedName, "Data - " + datasets[name].title);

            setButtonLoaded(btn);
          });
        } //let img = `<img src='${imgSrc}' class="corgis-icon">`;


        $("<tr></tr>") //.append($("<td>" + img + "</td>"))
        .append($("<td>" + datasets[name].title + "</td>")).append($("<td>" + datasets[name].overview + "</td>")).append($("<td></td>").append(btn)).appendTo(body);
      });
      body.appendTo(start); // Show the actual dialog

      _this3.main.components.dialog.show("Import Datasets", start, null);
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/css/blockpy.css":
/*!*****************************!*\
  !*** ./src/css/blockpy.css ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
    if(false) { var cssReload; }
  

/***/ }),

/***/ "./src/css/bootstrap_retheme.css":
/*!***************************************!*\
  !*** ./src/css/bootstrap_retheme.css ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
    if(false) { var cssReload; }
  

/***/ }),

/***/ "./src/dialog.js":
/*!***********************!*\
  !*** ./src/dialog.js ***!
  \***********************/
/*! exports provided: DIALOG_HTML, BlockPyDialog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIALOG_HTML", function() { return DIALOG_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyDialog", function() { return BlockPyDialog; });
// TODO: Dyanmically populate aria-labelledby in this and other places
var DIALOG_HTML = "\n    <div class='blockpy-dialog modal hidden'\n         role=\"dialog\"\n         aria-label='Dialog'\n         aria-hidden=\"true\"\n         aria-modal=\"true\">\n        <div class='modal-dialog modal-lg' role=\"document\">\n            <div class='modal-content' role='region' aria-label='Dialog content'>\n                <div class='modal-header'>\n                    <h4 class='modal-title'>Dynamic Content</h4>\n                    <button type='button' class='close' data-dismiss='modal' aria-hidden='true'>\n                        <span aria-hidden=\"true\">&times;</span>\n                    </button>\n                </div>\n                <div class='modal-body' style='max-width:100%; max-height:400px'>\n                </div>\n                <div class='modal-footer'>\n                    <button type='button' class='btn btn-white modal-close' data-dismiss='modal'>Close</button>\n                    <button type='button' class='btn btn-success modal-okay' data-dismiss='modal'>Okay</button>\n                </div>    \n            </div>\n        </div>\n    </div>\n";
/**
 * A utility object for quickly and conveniently generating dialog boxes.
 * Unfortunately, this doesn't dynamically create new boxes; it reuses the same one
 * over and over again. It turns out dynamically generating new dialog boxes
 * is a pain! So we can't stack them.
 *
 * @constructor
 * @this {BlockPyDialog}
 * @param {Object} main - The main BlockPy instance
 * @param {HTMLElement} tag - The HTML object this is attached to.
 */

function BlockPyDialog(main, tag) {
  var _this = this;

  this.main = main;
  this.tag = tag;
  this.titleTag = tag.find(".modal-title");
  this.bodyTag = tag.find(".modal-body");
  this.footerTag = tag.find(".modal-footer");
  this.okayButton = tag.find(".modal-okay");
  this.closeButton = tag.find(".modal-close");

  this.yes = function () {};

  this.no = function () {};

  this.okayButton.click(function () {
    _this.yes();

    _this.tag.modal("hide");
  });
  this.closeButton.click(function () {
    _this.no(); //this.tag.modal("hide");

  });
}

BlockPyDialog.prototype.close = function () {
  this.tag.modal("hide");
};
/**
 * A simple externally available function for popping up a dialog
 * message. This menu will be draggable by its title.
 *
 * @param {String} title - The title of the message dialog. Can have HTML.
 * @param {String} body - The body of the message dialog. Can have HTML.
 * @param {function} onclose - A function to be run when the user closes the dialog.
 */


BlockPyDialog.prototype.show = function (title, body, onclose) {
  this.titleTag.html(title);
  this.bodyTag.html(body);
  this.tag.modal("show");
  this.okayButton.hide();
  this.tag.draggable({
    "handle": ".modal-title"
  });
  this.tag.on("hidden.bs.modal", function (e) {
    if (onclose !== undefined && onclose !== null) {
      onclose();
    }
  });
};

BlockPyDialog.prototype.confirm = function (title, body, yes, no, yesText) {
  if (yesText === undefined) {
    yesText = "Okay";
  }

  this.show(title, body, no);
  this.yes = yes;
  this.no = no;
  this.okayButton.show().html(yesText); // TODO: add okay button and cancel button
};

BlockPyDialog.prototype.ASSIGNMENT_VERSION_CHANGED = function () {
  this.confirm("Assignment Changed", "Your instructor has made changes to this assignment. Would you like to reload? All your work has been saved.");
};

BlockPyDialog.prototype.ERROR_LOADING_ASSIGNMNENT = function (reason) {
  this.show("Error Loading Assignment", "BlockPy encountered an error while loading the assignment.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_SHOW_STUDENT_ERROR = function (error) {
  this.show("Original Error", "When I ran your code, I encountered an error:\n\n<div class=\"blockpy-dialog-student-error-message\">".concat(error, "</div>"));
};

BlockPyDialog.prototype.POSITIVE_FEEDBACK_FULL = function (title, message) {
  this.show(title, message);
};

BlockPyDialog.prototype.SCREENSHOT_BLOCKS = function () {// TODO
};

BlockPyDialog.prototype.ERROR_UPDATING_SUBMISSION_STATUS = function () {
  this.show("Error Updating Submission Status", "BlockPy encountered an error while updating your submission status.<br>\nPlease reload the page and try again.");
};

BlockPyDialog.prototype.ERROR_LOADING_HISTORY = function () {
  this.show("Error Loading History", "BlockPy encountered an error while loading your history.<br>\nPlease reload the page and try again.");
};

BlockPyDialog.prototype.EDIT_INPUTS = function () {
  var _this2 = this;

  var inputText = this.main.model.execution.input().join("\n");
  var clearInputs = this.main.model.display.clearInputs() ? "" : "checked";

  var yes = function yes() {
    var checked = _this2.tag.find(".blockpy-remember-inputs").prop("checked");

    var inputs = _this2.tag.find(".blockpy-input-list").val().split("\n");

    _this2.main.model.display.clearInputs(!checked);

    _this2.main.model.execution.input(inputs);
  };

  this.confirm("Edit Remembered Inputs", "\n\n<div class=\"form-check\">\n<input type=\"checkbox\" class=\"blockpy-remember-inputs form-check-input\"\n        name=\"blockpy-remember-inputs\" ".concat(clearInputs, ">\n<label class=\"form-check-label\" for=\"blockpy-remember-inputs\">Reuse inputs for next execution</label>\n</div>\n\n<textarea class=\"blockpy-input-list form-control\" rows=\"4\">").concat(inputText, "</textarea><br>\nEdit the inputs above to store and reuse them across multiple executions.\nEach input should be put on its own line.\nYou do not need quotes; the text will be entered literally.\n \n"), yes, this.no, "Save"); // TODO: Allow user to specify the infinite string to keep giving when the others run out
};

/***/ }),

/***/ "./src/editor/abstract_editor.js":
/*!***************************************!*\
  !*** ./src/editor/abstract_editor.js ***!
  \***************************************/
/*! exports provided: uploadFile, sluggify, downloadFile, AbstractEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uploadFile", function() { return uploadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sluggify", function() { return sluggify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "downloadFile", function() { return downloadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractEditor", function() { return AbstractEditor; });
/* harmony import */ var _editors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../editors */ "./src/editors.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


function uploadFile(model, event) {
  var fileReader = new FileReader();
  var files = event.target.files;

  fileReader.onload = function (e) {
    return model.ui.editors.current().uploadFile(e);
  };

  fileReader.fileName = files[0].name;
  fileReader.readAsText(files[0]);
  event.target.value = "";
}
function sluggify(text) {
  return text.replace(/[^a-z0-9]/gi, "_").toLowerCase();
}
function downloadFile(model, event) {
  var _model$ui$editors$cur = model.ui.editors.current().downloadFile(),
      name = _model$ui$editors$cur.name,
      extension = _model$ui$editors$cur.extension,
      contents = _model$ui$editors$cur.contents,
      mimetype = _model$ui$editors$cur.mimetype; // Make safe


  name = sluggify(name);
  name = name + extension; // Make the data download as a file

  var blob = new Blob([contents], {
    type: mimetype
  });

  if (window.navigator.msSaveOrOpenBlob) {
    window.navigator.msSaveBlob(blob, name);
  } else {
    var temporaryDownloadLink = window.document.createElement("a");
    temporaryDownloadLink.href = window.URL.createObjectURL(blob);
    temporaryDownloadLink.download = name;
    document.body.appendChild(temporaryDownloadLink);
    temporaryDownloadLink.click();
    document.body.removeChild(temporaryDownloadLink);
  }
}
var AbstractEditor = /*#__PURE__*/function () {
  function AbstractEditor(main, tag) {
    _classCallCheck(this, AbstractEditor);

    this.main = main;
    this.tag = tag;
    this.fileSystem = main.components.fileSystem;
    this.filename = null;
    this.file = null;
  }

  _createClass(AbstractEditor, [{
    key: "deleteFile",
    value: function deleteFile() {
      this.fileSystem.deleteFile(this.filename);
      this.main.model.display.filename("answer.py");
      this.main.components.editors.changeEditor("answer.py");
    }
  }, {
    key: "onFileDeleted",
    value: function onFileDeleted() {
      // TODO: Switch to the previous file instead of a default file
      this.main.model.display.filename("answer.py");
      this.main.components.editors.changeEditor("answer.py");
    }
  }, {
    key: "onFileUpdated",
    value: function onFileUpdated(file) {
      if (file.filename === this.filename) {
        //this.file = file;
        this.main.components.editors.changeEditor(this.filename); //this.fileSystem.stopWatchingFile(this.filename);
        //this.trackCurrentFile();
      }
    }
  }, {
    key: "trackCurrentFile",
    value: function trackCurrentFile() {
      this.fileSystem.watchFile(this.filename, {
        updated: this.onFileUpdated.bind(this),
        deleted: this.onFileDeleted.bind(this)
      });
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      this.filename = newFilename;
      this.file = this.fileSystem.getFile(newFilename);
      this.trackCurrentFile();
    }
    /**
     *
     * @param newFilename - the filename that the other editor will be switching to
     * @param oldEditor
     * @param newEditor
     */

  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      this.fileSystem.stopWatchingFile(this.filename);
      this.file = null;
      this.filename = null;
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(event) {
      var filename = event.target.fileName;
      var contents = event.target.result;
      this.file.handle(contents);
    }
  }, {
    key: "downloadFile",
    value: function downloadFile() {
      var filename = _editors__WEBPACK_IMPORTED_MODULE_0__["Editors"].parseFilename(this.filename);
      return {
        name: filename.name,
        extension: filename.type,
        contents: this.file.handle(),
        mimetype: "text/plain"
      };
    }
  }]);

  return AbstractEditor;
}();

/***/ }),

/***/ "./src/editor/assignment_settings.js":
/*!*******************************************!*\
  !*** ./src/editor/assignment_settings.js ***!
  \*******************************************/
/*! exports provided: ASSIGNMENT_SETTINGS_EDITOR_HTML, saveAssignmentSettings, loadAssignmentSettings, makeAssignmentSettingsModel, AssignmentSettings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ASSIGNMENT_SETTINGS_EDITOR_HTML", function() { return ASSIGNMENT_SETTINGS_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveAssignmentSettings", function() { return saveAssignmentSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadAssignmentSettings", function() { return loadAssignmentSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeAssignmentSettingsModel", function() { return makeAssignmentSettingsModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssignmentSettings", function() { return AssignmentSettings; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _python__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./python */ "./src/editor/python.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var ASSIGNMENT_SETTINGS = [["toolbox", "toolbox", "normal", "toolbox", "Which version of the toolbox to present to the user."], ["passcode", "passcode", "", "string", "A string that the user must enter to access the problem. If blank, then no passcode is prompted."], //["toolboxLevel", "toolbox_level", "normal", "toolbox", "INCOMPLETE: What level of toolbox to present to the user (hiding and showing categories)."],
["startView", "start_view", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].SPLIT, _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"], "The Python editor mode to start in when the student starts the problem."], ["datasets", "datasets", "", "string", "The current list of datasets available on load as a comma-separated string."], ["disableTimeout", "disable_timeout", false, "bool", "If checked, then students code is allowed to run without timeouts (potentially allowing infinite loops)."], ["isParsons", "is_parsons", false, "bool", "If checked, then this is a parson's style question (jumbled)."], ["disableFeedback", "disable_feedback", false, "bool", "If checked, then no instructor scripts are run (e.g., on_run and on_eval)."], ["disableInstructorRun", "disable_instructor_run", false, "bool", "If checked, then the instructor on_run will not automatically run the students' code. This still runs the students' code."], ["disableStudentRun", "disable_student_run", false, "bool", "If checked, then the run button no longer run the students' code. This still runs the instructor's feedback on_run script."], ["disableTifa", "disable_tifa", false, "bool", "If checked, then do not automatically run Tifa (which can be slow)."], ["disableTrace", "disable_trace", false, "bool", "If checked, then the students code will not have its execution traced (no variables recorded, no coverage tracked)."], ["disableEdit", "disable_edit", false, "bool", "If checked, then the students' file will not be editable."], ["enableImages", "can_image", false, "bool", "If checked, then users can copy/paste images directly into the text editor."], ["enableBlocks", "can_blocks", true, "bool", "If checked, then the student can edit the block interface (if not, then it is visible but not editable)."], ["canClose", "can_close", false, "bool", "If checked, then the student should mark their submission closed when they are done. There is no way to force a student to do so. Unlike Reviewed, this still submits the correctness."], ["onlyInteractive", "only_interactive", false, "bool", "If checked, the editors are hidden, the program is automatically run, and then the console enters Eval mode (interactive)."], ["onlyUploads", "only_uploads", false, "bool", "If checked, then the students' file will not be directly editable (they will have to upload submissions)."], // What menus/feedback to show and hide
["hideSubmission", "hide_submission", false, "bool", "If checked, then students will not be able to see their submission's code or history on Canvas."], ["hideFiles", "hide_files", true, "bool", "If checked, then students will not see the View Files toolbar."], ["hideQueuedInputs", "hide_queued_inputs", false, "bool", "If checked, then the students cannot access the queued inputs box (makes repeated debugging easier for the input function)."], ["hideEditors", "hide_editors", false, "bool", "If checked, then all of the editors are hidden."], ["hideMiddlePanel", "hide_middle_panel", false, "bool", "If checked, then the console and feedback areas is hidden."], ["hideAll", "hide_all", false, "bool", "INCOMPLETE: If checked, then the entire interface is hidden."], ["hideEvaluate", "hide_evaluate", false, "bool", "If checked, then the Evaluate button is not shown on the console."], ["hideImportDatasetsButton", "hide_import_datasets_button", false, "bool", "If checked, then students cannot see the import datasets button."], // TODO: Fix this one to be settable
["hideImportStatements", "hide_import_statements", false, "bool", "INCOMPLETE: If checked, certain kinds of import statements (matplotlib, turtle, datasets) are not shown in the block interface."], ["hideCoverageButton", "hide_coverage_button", false, "bool", "INCOMPLETE: If checked, the coverage button is not shown."], ["saveTurtleOutput", "save_turtle_output", false, "bool", "If checked, then turtle output is saved whenever the program uses it."]];

function getDocumentation(name) {
  for (var i = 0; i < ASSIGNMENT_SETTINGS.length; i++) {
    if (ASSIGNMENT_SETTINGS[i][0] === name) {
      return ASSIGNMENT_SETTINGS[i][4];
    }
  }

  return "Documentation not found for field";
}

function makeStartViewTab(name, icon, mode) {
  return "<label class=\"btn btn-outline-secondary blockpy-mode-set-blocks\"\n                data-bind=\"css: {active: assignment.settings.startView() === '".concat(mode, "'},\n                           click: assignment.settings.startView.bind($data, '").concat(mode, "')\">\n                <span class='fas fa-").concat(icon, "'></span>\n                <input type=\"radio\" name=\"blockpy-start-view-set\" autocomplete=\"off\" checked> ").concat(name, "\n            </label>");
}

var ASSIGNMENT_SETTINGS_BOOLEAN_COMPONENTS_HTML = ASSIGNMENT_SETTINGS // Only handle the simple booleans this way
.filter(function (setting) {
  return setting[3] === "bool";
}).map(function (setting) {
  var prettyName = setting[1].split("_").map(function (word) {
    return word.charAt(0).toUpperCase() + word.slice(1);
  }).join(" ");
  return "\n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-".concat(setting[0], "\">").concat(prettyName, "</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-").concat(setting[0], "\"\n                    data-bind=\"checked: assignment.settings.").concat(setting[0], "\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    ").concat(setting[4], "\n                </small>\n            </div>\n        </div>\n        ");
}).join("\n\n");
var ASSIGNMENT_SETTINGS_EDITOR_HTML = "\n    <div class=\"blockpy-view-settings\">\n    \n    <form>\n\n        <div class=\"form-group row\">\n            <div class=\"col-sm-12 mx-auto\">\n                <button type=\"button\" class=\"btn btn-success\"\n                    data-bind=\"click: ui.editors.settings.save\">Save changes</button>\n            </div>\n        </div>\n    \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-name\" class=\"col-sm-2 col-form-label text-right\">Name:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-name\"\n                data-bind=\"value: assignment.name\">\n                <small class=\"form-text text-muted\">\n                    The student-facing name of the assignment. Assignments within a group are ordered alphabetically\n                    by their name, so you may want to use a naming scheme like \"#43.5) Whatever\".\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-url\" class=\"col-sm-2 col-form-label text-right\">URL:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-url\"\n                data-bind=\"value: assignment.url\">\n                <small class=\"form-text text-muted\">\n                    The course-unique URL that can be used to consistently refer to this assignment. \n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-public\">Public:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-public\"\n                    data-bind=\"checked: assignment.public\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If not public, users outside of the course will not be able to see the assignment in course listings.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-hidden\">Hidden:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-hidden\"\n                    data-bind=\"checked: assignment.hidden\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If hidden, students will not be able to see their grade while working on the assignment.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-reviewed\">Reviewed:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-reviewed\"\n                    data-bind=\"checked: assignment.reviewed\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If reviewed, the assignment need to be commented upon and regraded by the staff after submission.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-reviewed\">Starting View:</label>\n            </div>\n            <div class=\"col-sm-3\">\n                <div class=\"btn-group btn-group-toggle mr-2\" data-toggle=\"buttons\">\n                    ".concat(makeStartViewTab("Blocks", "th-large", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].BLOCK), "\n                    ").concat(makeStartViewTab("Split", "columns", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].SPLIT), "\n                    ").concat(makeStartViewTab("Text", "align-left", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].TEXT), "\n                 </div>\n            </div>            \n            <div class=\"col-sm-7\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("startView"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-ip-ranges\" class=\"col-sm-2 col-form-label text-right\">IP Ranges:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-ip-ranges\"\n                data-bind=\"value: assignment.ipRanges\">\n                <small class=\"form-text text-muted\">\n                    Provide a comma-separated list of IP Addresses that will be explicitly allowed. If blank,\n                    then all addresses are allowed. If an address starts with <code>^</code> then it it is explicitly\n                    blacklisted, but that can be overridden in turn with a <code>!</code>. Addresses can also\n                    include a bit mask to allow a range of addresses.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-passcode\" class=\"col-sm-2 col-form-label text-right\">Passcode:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-passcode\"\n                data-bind=\"value: assignment.settings.passcode\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("passcode"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-datasets\" class=\"col-sm-2 col-form-label text-right\">Preloaded Datasets:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-datasets\"\n                data-bind=\"value: assignment.settings.datasets\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("datasets"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-toolbox\" class=\"col-sm-2 col-form-label text-right\">Block Toolbox:</label>\n            <div class=\"col-sm-10\">\n                <select class=\"form-control\" id=\"blockpy-settings-toolbox\"\n                       data-bind=\"value: assignment.settings.toolbox\">\n                   <option value=\"normal\">Normal Toolbox</option>\n                   <option value=\"ct\">CT@VT Toolbox</option>\n                   <option value=\"ct2\">CT@VT Toolbox V2</option>\n                   <option value=\"minimal\">Minimal Set</option>\n                   <option value=\"full\">All Blocks</option>\n                   <option value=\"custom\">Custom</option>\n                </select>\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("toolbox"), "\n                </small>\n            </div>\n        </div>\n        \n        ").concat(ASSIGNMENT_SETTINGS_BOOLEAN_COMPONENTS_HTML, "\n    </form>\n    \n    </div>\n");
function saveAssignmentSettings(model) {
  var settings = {};
  ASSIGNMENT_SETTINGS.forEach(function (setting) {
    var clientName = setting[0],
        serverName = setting[1],
        defaultValue = setting[2];
    var value = model.assignment.settings[clientName](); // Only store this setting if its different from the default

    if (value !== defaultValue) {
      settings[serverName] = value;
    }
  });
  return JSON.stringify(settings);
}
function loadAssignmentSettings(model, settings) {
  if (settings) {
    settings = JSON.parse(settings);
    ASSIGNMENT_SETTINGS.forEach(function (setting) {
      var clientName = setting[0],
          serverName = setting[1];

      if (serverName in settings) {
        model.assignment.settings[clientName](settings[serverName]);
      } else {
        model.assignment.settings[clientName](setting[2]);
      }
    });

    if (settings.start_view) {
      model.display.pythonMode(settings.start_view);
    }
  }
}
function makeAssignmentSettingsModel(configuration) {
  var settings = {};
  ASSIGNMENT_SETTINGS.forEach(function (setting) {
    var clientName = setting[0],
        serverName = setting[1],
        defaultValue = setting[2],
        fieldType = setting[3];

    if (configuration["assignment.settings." + serverName] === undefined) {
      settings[clientName] = ko.observable(defaultValue);
    } else {
      var configValue = configuration["assignment.settings." + serverName];

      if (fieldType === "bool") {
        configValue = configValue.toLowerCase() === "true";
      }

      settings[clientName] = ko.observable(configValue);
    }
  });
  return settings;
}

var AssignmentSettingsView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(AssignmentSettingsView, _AbstractEditor);

  var _super = _createSuper(AssignmentSettingsView);

  function AssignmentSettingsView(main, tag) {
    var _this;

    _classCallCheck(this, AssignmentSettingsView);

    _this = _super.call(this, main, tag);
    _this.dirty = false;
    return _this;
  }

  _createClass(AssignmentSettingsView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(AssignmentSettingsView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false; //TODO: this.updateEditor(this.file.handle());
      // Subscribe to the relevant File
      // this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this));
      // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this); //TODO: this.codeMirror.on("change", this.currentListener);
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true; // TODO: Do update

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true; //this.file.handle(this.codeMirror.value());
        // TODO: Update

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      //this.currentSubscription.dispose();
      // TODO: update
      //this.codeMirror.off("change", this.currentListener);
      _get(_getPrototypeOf(AssignmentSettingsView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return AssignmentSettingsView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var AssignmentSettings = {
  name: "Assignment Settings",
  extensions: ["!assignment_settings.blockpy"],
  constructor: AssignmentSettingsView,
  template: ASSIGNMENT_SETTINGS_EDITOR_HTML
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/editor/json.js":
/*!****************************!*\
  !*** ./src/editor/json.js ***!
  \****************************/
/*! exports provided: JSON_EDITOR_HTML, JsonEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSON_EDITOR_HTML", function() { return JSON_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonEditor", function() { return JsonEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var JSON_EDITOR_HTML = "\n    <div>\n        <textarea class=\"blockpy-editor-json\"></textarea>\n    </div>\n";

var JsonEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(JsonEditorView, _AbstractEditor);

  var _super = _createSuper(JsonEditorView);

  function JsonEditorView(main, tag) {
    var _this;

    _classCallCheck(this, JsonEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-json")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      mode: "json",
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(JsonEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(JsonEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(JsonEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return JsonEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var JsonEditor = {
  name: "JSON",
  extensions: [".json"],
  constructor: JsonEditorView,
  template: JSON_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/markdown.js":
/*!********************************!*\
  !*** ./src/editor/markdown.js ***!
  \********************************/
/*! exports provided: MARKDOWN_EDITOR_HTML, MarkdownEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MARKDOWN_EDITOR_HTML", function() { return MARKDOWN_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkdownEditor", function() { return MarkdownEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var MARKDOWN_EDITOR_HTML = "\n    <textarea class=\"blockpy-editor-markdown\"></textarea>    \n";

var MarkdownEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(MarkdownEditorView, _AbstractEditor);

  var _super = _createSuper(MarkdownEditorView);

  function MarkdownEditorView(main, tag) {
    var _this;

    _classCallCheck(this, MarkdownEditorView);

    _this = _super.call(this, main, tag);
    _this.mde = new EasyMDE({
      element: tag.find(".blockpy-editor-markdown")[0],
      autoDownloadFontAwesome: false,
      forceSync: true,
      minHeight: "500px",
      // TODO: imageUploadFunction
      renderingConfig: {
        codeSyntaxHighlighting: true
      },
      indentWithTabs: false,
      tabSize: 4
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(MarkdownEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(MarkdownEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.mde.codemirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.mde.codemirror.refresh.bind(this.mde.codemirror), 1);
      }
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.mde.value(newContents);
        this.mde.codemirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.mde.value());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.mde.codemirror.off("change", this.currentListener);

      _get(_getPrototypeOf(MarkdownEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return MarkdownEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var MarkdownEditor = {
  name: "Markdown",
  extensions: [".md"],
  constructor: MarkdownEditorView,
  template: MARKDOWN_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/python.js":
/*!******************************!*\
  !*** ./src/editor/python.js ***!
  \******************************/
/*! exports provided: DisplayModes, PYTHON_EDITOR_HTML, PythonEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayModes", function() { return DisplayModes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PYTHON_EDITOR_HTML", function() { return PYTHON_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PythonEditor", function() { return PythonEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../history */ "./src/history.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * TODO: rename files, manual save, tags, sample_submissions, on_eval, non-builtin files
 * TODO: import data, history, run, url_data, assignment_settings, parsons_mode
 * TODO: delete becomes "clear" for instructor files
 */

/**
 *
 * @enum {str}
 */


var DisplayModes = {
  BLOCK: "block",
  SPLIT: "split",
  TEXT: "text"
};

function makeTab(name, icon, mode) {
  return "<label class=\"btn btn-outline-secondary blockpy-mode-set-blocks\"\n                data-bind=\"css: {active: display.pythonMode() === '".concat(mode, "'},\n                           click: ui.editors.python.updateMode.bind($data, '").concat(mode, "')\">\n                <span class='fas fa-").concat(icon, "'></span>\n                <input type=\"radio\" name=\"blockpy-mode-set\" autocomplete=\"off\" checked> ").concat(name, "\n            </label>");
}

var PYTHON_EDITOR_HTML = "\n\n    <div class=\"blockpy-python-toolbar col-md-12 btn-toolbar\"\n         role=\"toolbar\" aria-label=\"Python Toolbar\">\n\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Run Group\">         \n            <button type=\"button\" class=\"btn blockpy-run notransition\"\n                data-bind=\"click: ui.execute.run,\n                            css: {'blockpy-run-running': ui.execute.isRunning}\">\n                <span class=\"fas fa-play\"></span> Run\n             </button>\n         </div>\n         \n         <div class=\"btn-group btn-group-toggle mr-2\" data-toggle=\"buttons\">\n            <!-- ko if: $root.assignment.settings.enableBlocks() -->\n            ".concat(makeTab("Blocks", "th-large", DisplayModes.BLOCK), "\n            ").concat(makeTab("Split", "columns", DisplayModes.SPLIT), "\n            ").concat(makeTab("Text", "align-left", DisplayModes.TEXT), "\n            <!-- /ko -->\n         </div>\n\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Reset Group\">\n             <button type=\"button\" class=\"btn btn-outline-secondary\"\n                 data-bind=\"click: ui.editors.reset\">\n                 <span class=\"fas fa-sync\"></span> Reset\n              </button>\n         </div>\n         \n         <!-- ko if: !assignment.settings.hideImportDatasetsButton() -->\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Import Group\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                data-bind=\"click: ui.editors.importDataset\">\n                <span class=\"fas fa-cloud-download-alt\"></span> Import datasets\n             </button>\n         </div>\n         <!-- /ko -->\n         \n         <div class=\"btn-group mr-2\">\n                <label class=\"btn btn-outline-secondary\">\n                    <span class=\"fas fa-file-upload\"></span> Upload\n                    <input class=\"blockpy-toolbar-upload\" type=\"file\"\n                        hidden\n                        data-bind=\"event: {change: ui.editors.upload}\">\n                 </label>\n\n                <button type=\"button\" class=\"btn btn-outline-secondary dropdown-toggle dropdown-toggle-split\"\n                    data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"caret\"></span>\n                    <span class=\"sr-only\">Toggle Dropdown</span>\n                </button>\n                \n                <div class=\"dropdown-menu dropdown-menu-right\">\n                    <a class='dropdown-item blockpy-toolbar-download'\n                        data-bind=\"click: ui.editors.download\">\n                    <span class='fas fa-download'></span> Download\n                    </a>\n                </div>\n            </div>\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"History Group\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                aria-pressed=\"false\"\n                data-bind=\"click: ui.editors.python.toggleHistoryMode,\n                           enable: ui.editors.python.isHistoryAvailable,\n                           css: { active: display.historyMode },\n                           attr: { 'aria-pressed': display.historyMode }\">\n                <span class=\"fas fa-history\"></span> History\n             </button>\n         </div>\n         \n         <!-- Fully functional, but a little too.. Invasive \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Fullscreen Group\"\n            data-bind=\"visible: display.pythonMode() === 'text'\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                data-bind=\"click: ui.editors.python.fullscreen\">\n                <span class=\"fas fa-expand-arrows-alt\"></span> Fullscreen\n             </button>\n         </div>\n         -->\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Save Group\"\n            data-bind=\"visible: ui.editors.canSave\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\">\n                <span class=\"fas fa-save\"></span> Save\n             </button>\n         </div>\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Delete Group\"\n            data-bind=\"visible: ui.editors.canDelete\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\",\n                data-bind=\"click: ui.files.delete\">\n                <span class=\"fas fa-trash\"></span> Delete\n             </button>\n         </div>\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Rename Group\"\n            data-bind=\"visible: ui.editors.canRename\">\n             <button type=\"button\" class=\"btn btn-outline-secondary\">\n                <span class=\"fas fa-file-signature\"></span> Rename\n             </button>\n         </div>\n         \n    </div>\n    \n    ").concat(_history__WEBPACK_IMPORTED_MODULE_1__["HISTORY_TOOLBAR_HTML"], "\n\n\n    <div class=\"blockpy-python-blockmirror\"\n        data-bind=\"hidden: ui.menu.isSubmitted\">\n    </div>\n");

function convertIpynbToPython(code) {
  var ipynb = JSON.parse(code);

  var isUsable = function isUsable(cell) {
    if (cell.cell_type === "code") {
      return cell.source.length > 0 && !cell.source[0].startsWith("%");
    } else {
      return cell.cell_type === "markdown" || cell.cell_type === "raw";
    }
  };

  var makePython = function makePython(cell) {
    if (cell.cell_type === "code") {
      return cell.source.join("\n");
    } else if (cell.cell_type === "markdown" || cell.cell_type === "raw") {
      return "'''" + cell.source.join("\n") + "'''";
    }
  };

  return ipynb.cells.filter(isUsable).map(makePython).join("\n");
}

var PythonEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(PythonEditorView, _AbstractEditor);

  var _super = _createSuper(PythonEditorView);

  function PythonEditorView(main, tag) {
    var _this;

    _classCallCheck(this, PythonEditorView);

    _this = _super.call(this, main, tag.find(".blockpy-python-blockmirror"));
    Blockly.setParentContainer(main.model.configuration.container[0]);
    _this.bm = new BlockMirror({
      "container": _this.tag[0],
      "run": main.components.engine.run.bind(main.components.engine),
      "skipSkulpt": true,
      "blocklyMediaPath": main.model.configuration.blocklyPath,
      "toolbox": main.model.assignment.settings.toolbox(),
      "imageMode": true,
      imageDownloadHOok: function imageDownloadHOok(oldUrl) {
        return oldUrl;
      },
      imageUploadHook: function imageUploadHook(blob) {
        return Promise.resolve("Image(" + JSON.stringify(URL.createObjectURL(blob)) + ")");
      },
      imageLiteralHook: function imageLiteralHook(oldUrl) {
        return "Image(\"".concat(oldUrl, "\")");
      } //'height': '2000px'

    });
    _this.dirty = false;
    _this.readOnly = false;

    _this.makeSubscriptions();

    _this.lineErrorSubscription = null;
    _this.lineUncoveredSubscription = null;
    _this.oldPythonMode = _this.main.model.display.pythonMode();

    _this.makePerAssignmentSubscriptions();

    return _this;
  }

  _createClass(PythonEditorView, [{
    key: "configureExtraBlockly",
    value: function configureExtraBlockly() {
      var _this2 = this;

      this.bm.blockEditor.workspace.configureContextMenu = function (options) {
        options.push({
          enabled: true,
          text: "Screenshot",
          callback: function callback() {
            return _this2.main.components.dialog.SCREENSHOT_BLOCKS;
          }
        });
      };
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      var _this3 = this;

      var oldFilename = this.filename;

      _get(_getPrototypeOf(PythonEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;

      if (newFilename !== "answer.py") {
        if (oldFilename === "answer.py") {
          this.oldPythonMode = this.main.model.display.pythonMode();
        }

        this.main.model.display.pythonMode(DisplayModes.TEXT);
      } else {
        this.main.model.display.pythonMode(this.oldPythonMode);
      }

      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentBMListener = this.updateHandle.bind(this);
      this.bm.addChangeListener(this.currentBMListener);

      if (newFilename !== "answer.py") {
        this.bm.isParsons = function () {
          return false;
        };
      } else {
        this.bm.isParsons = this.main.model.assignment.settings.isParsons;
        this.lineErrorSubscription = this.main.model.execution.feedback.linesError.subscribe(function (lines) {
          return _this3.bm.setHighlightedLines(lines, "editor-error-line");
        });
        this.lineUncoveredSubscription = this.main.model.execution.feedback.linesUncovered.subscribe(function (lines) {
          return _this3.bm.setHighlightedLines(lines, "editor-uncovered-line");
        });
      } //this.bm.blockEditor.workspace.render();
      //this.bm.refresh();
      // TODO: Figure out why this doesn't end up looking right (go to a different editor, come back, and it'll be squished)
      //this.bm.refresh();


      setTimeout(function () {
        return _this3.bm.refresh();
      }, 0);
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      if (newContents === undefined) {
        if (this.file !== null) {
          newContents = this.file.handle();
        } else {
          // Doesn't matter, file was already shut down.
          newContents = "";
        }
      } else if (newContents === null) {
        // We're closing this file
        this.main.components.fileSystem.deleteFileLocally_(this.filename);
        return;
      }

      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.bm.setCode(newContents); // Delay so that everything is rendered

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.bm.clearHighlightedLines();
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;

        if (!this.main.model.display.historyMode()) {
          this.file.handle(this.bm.getCode());
        }

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.dirty = false;
      this.currentSubscription.dispose();
      this.bm.removeChangeListener(this.currentBMListener);

      if (this.main.model.display.historyMode()) {
        this.main.model.ui.editors.python.turnOffHistoryMode();
      }

      this.clearLineSubscriptions();

      _get(_getPrototypeOf(PythonEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }, {
    key: "clearLineSubscriptions",
    value: function clearLineSubscriptions() {
      this.bm.clearHighlightedLines();

      if (this.lineErrorSubscription) {
        this.lineErrorSubscription.dispose();
        this.lineErrorSubscription = null;
      }

      if (this.lineUncoveredSubscription) {
        this.lineUncoveredSubscription.dispose();
        this.lineUncoveredSubscription = null;
      }
    }
  }, {
    key: "makeSubscriptions",
    value: function makeSubscriptions() {
      var _this4 = this;

      this.bm.setMode(this.main.model.display.pythonMode());
      this.main.model.display.pythonMode.subscribe(function (mode) {
        _this4.bm.setMode(mode);
      });
      this.main.model.assignment.settings.enableBlocks.subscribe(function (enabled) {
        if (!enabled) {
          _this4.bm.setMode(DisplayModes.TEXT);
        } else {
          _this4.bm.setMode(_this4.main.model.display.pythonMode());
        }
      });
      this.main.model.assignment.settings.toolbox.subscribe(this.reloadToolbox.bind(this));
      this.main.model.assignment.settings.enableImages.subscribe(function (imageMode) {
        _this4.bm.setImageMode(imageMode);
      });
    }
  }, {
    key: "reloadToolbox",
    value: function reloadToolbox(toolbox) {
      if (toolbox === "custom") {
        var customToolbox = this.main.components.fileSystem.getFile("?toolbox.blockpy");

        if (customToolbox == null) {
          toolbox = "empty";
        } else {
          try {
            toolbox = JSON.parse(customToolbox.handle());
          } catch (e) {
            console.error(e); // TODO: Improve error message for instructor

            toolbox = "minimal";
          }
        }
      }

      this.bm.configuration.toolbox = toolbox; // TODO: Handle invalid toolbox better

      try {
        this.bm.blockEditor.remakeToolbox();
      } catch (e) {
        console.error(e);
        this.bm.configuration.toolbox = "empty";
        this.bm.blockEditor.remakeToolbox();
      }
    }
  }, {
    key: "makePerAssignmentSubscriptions",
    value: function makePerAssignmentSubscriptions() {
      var _this5 = this;

      this.main.model.display.instructor.subscribe(function (changed) {
        _this5.setReadOnly(_this5.decideIfNotEditable());
      });
      this.main.model.assignment.settings.onlyUploads.subscribe(function (changed) {
        _this5.setReadOnly(_this5.decideIfNotEditable());
      });
    }
  }, {
    key: "decideIfNotEditable",
    value: function decideIfNotEditable() {
      var model = this.main.model;
      return model.display.historyMode() || model.assignment.settings.onlyUploads() && !model.display.instructor();
    }
  }, {
    key: "setReadOnly",
    value: function setReadOnly(isReadOnly) {
      this.readOnly = isReadOnly;
      this.bm.setReadOnly(isReadOnly);
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(event) {
      var filename = event.target.fileName;
      var code = event.target.result;

      if (filename.endsWith(".ipynb")) {
        code = convertIpynbToPython(code);
      }

      this.main.components.server.logEvent("X-File.Upload", "", "", code, this.filename);
      this.file.handle(code);
      this.main.components.engine.run(); // TODO: Run code
    }
  }, {
    key: "downloadFile",
    value: function downloadFile() {
      var result = _get(_getPrototypeOf(PythonEditorView.prototype), "downloadFile", this).call(this);

      if (result.name === "answer" && result.extension === ".py") {
        result.name = Object(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["sluggify"])(this.main.model.assignment.name());
      }

      result.mimetype = "text/x-python";
      this.main.components.server.logEvent("X-File.Download", "", "", "", result.name);
      return result;
    }
  }]);

  return PythonEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var PythonEditor = {
  name: "Python",
  extensions: [".py"],
  constructor: PythonEditorView,
  template: PYTHON_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/sample_submissions.js":
/*!******************************************!*\
  !*** ./src/editor/sample_submissions.js ***!
  \******************************************/
/*! exports provided: SubmissionStatuses, SampleSubmission, SAMPLE_SUBMISSIONS_HTML, SampleSubmissions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubmissionStatuses", function() { return SubmissionStatuses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleSubmission", function() { return SampleSubmission; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SAMPLE_SUBMISSIONS_HTML", function() { return SAMPLE_SUBMISSIONS_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleSubmissions", function() { return SampleSubmissions; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Panel for editing the set of Sample Submissions.
 * These are not provided at all to students without the Grader role.
 */

var SubmissionStatuses = {
  UNKNOWN: "unknown",
  PASSED: "passed",
  FAILED: "failed",
  ERROR: "error",
  SKIPPED: "skipped"
};
var SampleSubmission = /*#__PURE__*/function () {
  function SampleSubmission(name, status, code) {
    _classCallCheck(this, SampleSubmission);

    this.name = name;
    this.status = status;
    this.code = code;
  }

  _createClass(SampleSubmission, [{
    key: "serialize",
    value: function serialize() {
      return {
        name: this.name,
        status: this.status,
        code: this.code
      };
    }
  }], [{
    key: "Blank",
    value: function Blank(count) {
      return new SampleSubmission("Untitled" + (count || 1), SubmissionStatuses.UNKNOWN, "a=0");
    }
  }, {
    key: "deserialize",
    value: function deserialize(data) {
      return new SampleSubmission(data.name, data.status, data.code);
    }
  }]);

  return SampleSubmission;
}();
var SAMPLE_SUBMISSIONS_HTML = "\n<div>\n    <div data-bind=\"foreach: {data: assignment.sampleSubmissions}\"\n        class=\"row\">\n        <div class=\"col-md-6\">\n            <span data-bind=\"text: name\"></span>\n            <textarea class=\"blockpy-editor-sample-submissions-code\"\n                data-bind=\"codeMirrorInstance: code\"></textarea>\n        </div>\n        <div class=\"col-md-6\">\n            <span data-bind=\"text: status\"></span>        \n        </div>\n    </div>\n</div>\n";
ko.bindingHandlers.codeMirrorInstance = {
  init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // This will be called when the binding is first applied to an element
    // Set up any initial state, event handlers, etc. here
    console.log("INIT");
    var cm = CodeMirror.fromTextArea(element, {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    cm.setSize("100%", "100px");
    return cm;
  },
  update: function update(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // This will be called once when the binding is first applied to an element,
    // and again whenever any observables/computeds that are accessed change
    // Update the DOM element based on the supplied values here.
    console.log("UPDATE");
  }
};

var SampleSubmissionsView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(SampleSubmissionsView, _AbstractEditor);

  var _super = _createSuper(SampleSubmissionsView);

  function SampleSubmissionsView(main, tag) {
    var _this;

    _classCallCheck(this, SampleSubmissionsView);

    _this = _super.call(this, main, tag);
    _this.tag = tag;
    _this.codeMirrors = [];
    _this.dirty = false;
    return _this;
  }

  _createClass(SampleSubmissionsView, [{
    key: "buildEditor",
    value: function buildEditor(newDOM, index, newElement) {}
  }, {
    key: "rebuildEditors",
    value: function rebuildEditors() {
      console.log("Rebuilding editors");
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      var _this2 = this;

      _get(_getPrototypeOf(SampleSubmissionsView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this); //this.rebuildEditors();
      //this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        console.log(this.tag);
        console.log(this.tag.find(".CodeMirror"));
        console.log(this.tag.find(".CodeMirror").map(function (i, cm) {
          return console.log("+++", cm.CodeMirror);
        }));
        this.tag.find(".CodeMirror").map(function (i, cm) {
          return cm.CodeMirror.refresh();
        });
        console.log("REFRESH"); // Delay so that everything is rendered

        setTimeout(function () {
          return _this2.tag.find(".CodeMirror").map(function (i, cm) {
            return cm.CodeMirror.refresh();
          });
        }, 1);
      } // TODO: update dynamically when changing instructor status
      //this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());

    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        console.log(this.codeMirrors); //this.codeMirrors.each( (i, cm) => cm.setValue(newContents.join("\n")));
        //this.codeMirrors.each( (i, cm) => cm.refresh());

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirrors.map(function (cm) {
          return cm.getValue();
        }));
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirrors = []; //this.codeMirrors.off("change", this.currentListener);
      //this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(SampleSubmissionsView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return SampleSubmissionsView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var SampleSubmissions = {
  name: "Sample Submissions",
  extensions: ["!sample_submissions.blockpy"],
  constructor: SampleSubmissionsView,
  template: SAMPLE_SUBMISSIONS_HTML
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/editor/tags.js":
/*!****************************!*\
  !*** ./src/editor/tags.js ***!
  \****************************/
/*! exports provided: TAGS_EDITOR_HTML, TagsEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TAGS_EDITOR_HTML", function() { return TAGS_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TagsEditor", function() { return TagsEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var TAGS_EDITOR_HTML = "\nCreate new\nImport by name\nFind by owner/course/kind\n\nTags:\n    Data:\n        Name\n        Kind\n        Level\n        Version\n        Description\n    Controls:\n        Edit\n        Remove\n        Delete \n";

var TagsEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(TagsEditorView, _AbstractEditor);

  var _super = _createSuper(TagsEditorView);

  function TagsEditorView(main, tag) {
    _classCallCheck(this, TagsEditorView);

    return _super.call(this, main, tag.find(".blockpy-editor-tags"));
  }

  return TagsEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var TagsEditor = {
  name: "Tags",
  extensions: ["!tags.blockpy"],
  constructor: TagsEditorView,
  template: TAGS_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/text.js":
/*!****************************!*\
  !*** ./src/editor/text.js ***!
  \****************************/
/*! exports provided: TEXT_EDITOR_HTML, TextEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_EDITOR_HTML", function() { return TEXT_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextEditor", function() { return TextEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var TEXT_EDITOR_HTML = "\n    <div>\n    <textarea class=\"blockpy-editor-text\"></textarea>\n    </div>\n";

var TextEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(TextEditorView, _AbstractEditor);

  var _super = _createSuper(TextEditorView);

  function TextEditorView(main, tag) {
    var _this;

    _classCallCheck(this, TextEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-text")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(TextEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(TextEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(TextEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return TextEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var TextEditor = {
  name: "Text",
  extensions: [".txt"],
  constructor: TextEditorView,
  template: TEXT_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/toolbox.js":
/*!*******************************!*\
  !*** ./src/editor/toolbox.js ***!
  \*******************************/
/*! exports provided: TOOLBOX_EDITOR_HTML, ToolboxEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLBOX_EDITOR_HTML", function() { return TOOLBOX_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolboxEditor", function() { return ToolboxEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var TOOLBOX_EDITOR_HTML = "\n    <div>\n        <div class=\"col-md-12\"\n         role=\"toolbar\" aria-label=\"Toolbox Toolbar\">\n             <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Save Group\">         \n                <button type=\"button\" class=\"btn btn-outline-secondary btn-editor-json-save\">\n                    <span class=\"fas fa-save\"></span> Save\n                 </button>\n             </div>\n         </div>\n        <textarea class=\"blockpy-editor-toolbox\"></textarea>\n    </div>\n";

var ToolboxEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(ToolboxEditorView, _AbstractEditor);

  var _super = _createSuper(ToolboxEditorView);

  function ToolboxEditorView(main, tag) {
    var _this;

    _classCallCheck(this, ToolboxEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-toolbox")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      mode: "json",
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(ToolboxEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(ToolboxEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.tag.find(".btn-editor-json-save").on("click", this.currentListener); //this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());

        if (this.main.model.assignment.settings.toolbox() === "custom") {
          this.main.components.pythonEditor.reloadToolbox("custom");
        }

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.tag.find(".btn-editor-toolbox-save").off("click", this.currentListener); //this.codeMirror.off("change", this.currentListener);

      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(ToolboxEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return ToolboxEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var ToolboxEditor = {
  name: "Toolbox",
  extensions: ["?toolbox.blockpy"],
  constructor: ToolboxEditorView,
  template: TOOLBOX_EDITOR_HTML
};

/***/ }),

/***/ "./src/editors.js":
/*!************************!*\
  !*** ./src/editors.js ***!
  \************************/
/*! exports provided: EditorsEnum, EDITORS_HTML, Editors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorsEnum", function() { return EditorsEnum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDITORS_HTML", function() { return EDITORS_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editors", function() { return Editors; });
/* harmony import */ var _editor_python__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./editor/python */ "./src/editor/python.js");
/* harmony import */ var _editor_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor/text */ "./src/editor/text.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
/* harmony import */ var _editor_tags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./editor/tags */ "./src/editor/tags.js");
/* harmony import */ var _editor_markdown__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./editor/markdown */ "./src/editor/markdown.js");
/* harmony import */ var _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./editor/sample_submissions */ "./src/editor/sample_submissions.js");
/* harmony import */ var _editor_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./editor/json */ "./src/editor/json.js");
/* harmony import */ var _editor_toolbox__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./editor/toolbox */ "./src/editor/toolbox.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Editors are inferred from Filenames.
 *
 * The editor is based on the extension:
 *  .blockpy: Special editor (will be chosen by filename)
 *  .py: Python Editor
 *  .md: Markdown Editor
 *  .txt: Text Editor (also used for other types)
 *  .peml: PEML Editor
 *  .png, .gif, .jpeg, .jpg, .bmp: Image Editor
 *  .json: JSON Editor
 *  .yaml: YAML Editor
 */








/**
 * The different possible editors available
 * @enum {string}
 */

var EditorsEnum = {
  SUBMISSION: "submission",
  ASSIGNMENT: "assignment",
  INSTRUCTIONS: "instructions",
  ON_RUN: "on_run",
  ON_CHANGE: "on_change",
  ON_EVAL: "on_eval",
  STARTING_CODE: "starting_code",
  SAMPLE_SUBMISSIONS: "sample_submissions",
  INSTRUCTOR_FILE: "instructor_file"
};
var SPECIAL_NAMESPACES = ["!", "^", "?", "$"];
var AVAILABLE_EDITORS = [_editor_text__WEBPACK_IMPORTED_MODULE_1__["TextEditor"], _editor_python__WEBPACK_IMPORTED_MODULE_0__["PythonEditor"], _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__["AssignmentSettings"], _editor_tags__WEBPACK_IMPORTED_MODULE_3__["TagsEditor"], _editor_markdown__WEBPACK_IMPORTED_MODULE_4__["MarkdownEditor"], _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_5__["SampleSubmissions"], _editor_json__WEBPACK_IMPORTED_MODULE_6__["JsonEditor"], _editor_toolbox__WEBPACK_IMPORTED_MODULE_7__["ToolboxEditor"]];
var EDITORS_HTML = AVAILABLE_EDITORS.map(function (editor) {
  return "\n<div class=\"col-md-12 blockpy-panel blockpy-editor\" \n     data-bind=\"visible: ui.editors.view().name === '".concat(editor.name, "'\">\n    <div>\n    ").concat(editor.template, "\n    </div>\n</div>\n");
}
/*
`
<!-- ko if: ui.editors.view().name === '${editor.name}' -->
${editor.template}
<!-- /ko -->`*/
).join("\n");
var Editors = /*#__PURE__*/function () {
  function Editors(main, tag) {
    var _this = this;

    _classCallCheck(this, Editors);

    this.main = main;
    this.tag = tag;
    this.current = null;
    this.registered_ = [];
    this.extensions_ = {};
    this.byName_ = {};
    AVAILABLE_EDITORS.forEach(function (editor) {
      return _this.registerEditor(editor);
    });
    this.main.model.display.filename.subscribe(this.changeEditor, this);
  }

  _createClass(Editors, [{
    key: "registerEditor",
    value: function registerEditor(data) {
      var extensions = data.extensions;
      var instance = new data.constructor(this.main, this.tag);
      instance.name = data.name;
      this.registered_.push(instance);
      this.byName_[data.name.toLowerCase()] = instance;

      for (var i = 0; i < extensions.length; i++) {
        this.extensions_[extensions[i]] = instance;
      }
    }
  }, {
    key: "byName",
    value: function byName(name) {
      return this.byName_[name.toLowerCase()];
    }
  }, {
    key: "changeEditor",
    value: function changeEditor(newFilename) {
      var oldEditor = this.current;
      var newEditor = this.getEditor(newFilename, oldEditor);

      if (oldEditor !== null) {
        oldEditor.exit(newFilename, oldEditor, newEditor);
      }

      this.current = newEditor;
      this.current.enter(newFilename, oldEditor);
    }
  }, {
    key: "getEditor",
    value: function getEditor(path) {
      var _Editors$parseFilenam = Editors.parseFilename(path),
          space = _Editors$parseFilenam.space,
          name = _Editors$parseFilenam.name,
          type = _Editors$parseFilenam.type;

      if (type === ".blockpy" && path in this.extensions_) {
        return this.extensions_[path];
      } else if (type in this.extensions_) {
        return this.extensions_[type];
      } else {
        return this.registered_[0];
      }
    }
  }], [{
    key: "parseFilename",
    value: function parseFilename(path) {
      var space = path.charAt(0);

      if (SPECIAL_NAMESPACES.indexOf(space) !== -1) {
        path = path.substr(1);
      } else {
        space = "";
      }

      var name = path.substr(0, path.lastIndexOf("."));
      var type = path.substr(path.lastIndexOf("."));
      return {
        "space": space,
        "name": name,
        "type": type
      };
    }
  }]);

  return Editors;
}();

/***/ }),

/***/ "./src/engine.js":
/*!***********************!*\
  !*** ./src/engine.js ***!
  \***********************/
/*! exports provided: BlockPyEngine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyEngine", function() { return BlockPyEngine; });
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server */ "./src/server.js");
/* harmony import */ var _engine_on_run__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine/on_run */ "./src/engine/on_run.js");
/* harmony import */ var _engine_run__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./engine/run */ "./src/engine/run.js");
/* harmony import */ var _engine_eval__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./engine/eval */ "./src/engine/eval.js");
/* harmony import */ var _engine_sample__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./engine/sample */ "./src/engine/sample.js");
/* harmony import */ var _engine_on_change__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./engine/on_change */ "./src/engine/on_change.js");
/* harmony import */ var _engine_on_eval__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./engine/on_eval */ "./src/engine/on_eval.js");
/* harmony import */ var _engine_on_sample__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./engine/on_sample */ "./src/engine/on_sample.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }









/**
 * An object for executing Python code and passing the results along to interested components.
 *
 * Interesting components:
 *  Execution Buffer: Responsible for collecting the trace during program execution.
 *                    This prevents Knockoutjs from updating the editor during execution.
 *
 * @constructor
 * @this {BlockPyEditor}
 * @param {Object} main - The main BlockPy instance
 * @param {HTMLElement} tag - The HTML object this is attached to.
 */

var BlockPyEngine = /*#__PURE__*/function () {
  function BlockPyEngine(main) {
    _classCallCheck(this, BlockPyEngine);

    this.main = main;
    this.executionModel = this.main.model.execution;
    this.configurations = {
      run: new _engine_run__WEBPACK_IMPORTED_MODULE_2__["RunConfiguration"](main),
      eval: new _engine_eval__WEBPACK_IMPORTED_MODULE_3__["EvalConfiguration"](main),
      onRun: new _engine_on_run__WEBPACK_IMPORTED_MODULE_1__["OnRunConfiguration"](main),
      onChange: new _engine_on_change__WEBPACK_IMPORTED_MODULE_5__["OnChangeConfiguration"](main),
      onEval: new _engine_on_eval__WEBPACK_IMPORTED_MODULE_6__["OnEvalConfiguration"](main)
    }; // Preconfigure skulpt so we can parse

    Sk.configure(this.configurations.run.getSkulptOptions()); // Keeps track of the tracing while the program is executing

    this.executionBuffer = {};
    /**
     * Definable function to be run when execution has fully ended,
     * whether it succeeds or fails.
     */

    this.onExecutionBegin = null;
    this.onExecutionEnd = null;
  }
  /**
   * Reset reports
   */


  _createClass(BlockPyEngine, [{
    key: "resetReports",
    value: function resetReports() {
      var report = this.executionModel.reports;
      report["verifier"] = {};
      report["parser"] = {};
      report["student"] = {};
      report["instructor"] = {};
      report["model"] = this.main.model;
    }
  }, {
    key: "resetStudentModel",
    value: function resetStudentModel() {
      var student = this.executionModel.student;
      student.calls = {};
      student.currentStep(null);
      student.currentTraceStep(0);
      student.lastStep(0);
      student.currentLine(null);
      student.currentTraceData.removeAll();
      student.results = null;
    }
  }, {
    key: "resetExecutionBuffer",
    value: function resetExecutionBuffer() {
      this.executionBuffer = {
        "trace": [],
        "step": 0,
        "line": 0
      };
    }
  }, {
    key: "reset",

    /**
     * Remove all interface aspects of the previous Run.
     */
    value: function reset() {
      // TODO: Clear out any coverage/trace/error highlights in editors
      // Reset execution in model
      this.resetStudentModel(); // Get reports ready

      this.resetReports(); // Clear out the execution buffer

      this.resetExecutionBuffer(); // Clear out the console of printed stuff

      this.main.components.console.clear(); // Clear out any old feedback

      this.main.components.feedback.clear();
    }
  }, {
    key: "delayedRun",
    value: function delayedRun() {
      //this.main.model.status.onExecution(StatusState.ACTIVE);
      //$(".blockpy-run").addClass("blockpy-run-running");
      this.run(); //setTimeout(this.run.bind(this), 1);
    }
  }, {
    key: "run",
    value: function run() {
      var _this = this;

      this.configuration = this.configurations.run.use(this);
      var execution = this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration));

      if (!this.main.model.assignment.settings.disableFeedback()) {
        execution.then(function () {
          _this.configuration.provideSecretError();

          return _this.onRun();
        });
      } else {
        execution.then(this.configuration.showErrors.bind(this.configuration));
      }

      execution.then(this.configuration["finally"].bind(this.configuration));
    }
  }, {
    key: "onRun",
    value: function onRun() {
      this.configuration = this.configurations.onRun.use(this);
      this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration)).then(this.configuration["finally"].bind(this.configuration)).then(this.executionEnd_.bind(this));
    }
  }, {
    key: "evaluate",
    value: function evaluate() {
      var _this2 = this;

      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_0__["StatusState"].ACTIVE);
      var evaluationInput = this.main.components.console.evaluate();
      console.log(evaluationInput);
      evaluationInput.then(function (userInput) {
        _this2.configuration = _this2.configurations.eval.use(_this2, userInput);

        var execution = _this2.execute().then(_this2.configuration.success.bind(_this2.configuration), _this2.configuration.failure.bind(_this2.configuration));

        if (!_this2.main.model.assignment.settings.disableFeedback() && _this2.main.model.assignment.onEval()) {
          execution.then(_this2.onEval.bind(_this2));
        } else {
          execution.then(_this2.configuration.showErrors.bind(_this2.configuration)).then(_this2.evaluate.bind(_this2));
        }

        execution.then(_this2.configuration["finally"].bind(_this2.configuration));
      });
    }
  }, {
    key: "onEval",
    value: function onEval() {
      this.configuration = this.configurations.onEval.use(this);
      this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration)).then(this.evaluate.bind(this)).then(this.configuration["finally"].bind(this.configuration));
    }
  }, {
    key: "onChange",
    value: function onChange() {
      this.configuration = this.configurations.onChange.use(this);
    }
  }, {
    key: "execute",
    value: function execute() {
      var _this3 = this;

      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_0__["StatusState"].ACTIVE);
      return Sk.misceval.asyncToPromise(function () {
        return Sk.importMainWithBody(_this3.configuration.filename, false, _this3.configuration.code, true, _this3.configuration.sysmodules);
      });
    }
    /**
     * Activated whenever the Python code changes
     */

  }, {
    key: "on_change",
    value: function on_change() {
      var FILENAME = "on_change"; // Skip if the instructor has not defined anything

      if (!this.main.model.programs[FILENAME]().trim()) {
        return false;
      }

      this.main.model.execution.status("changing");
      this.main.components.server.saveCode(); // On step does not perform parse analysis by default or run student code

      var engine = this;
      var feedback = this.main.components.feedback;
      engine.resetReports();
      engine.verifyCode();
      engine.updateParse();
      engine.runInstructorCode(FILENAME, true, function (module) {
        if (Sk.executionReports["instructor"]["success"]) {
          // SUCCESS, SCORE, CATEGORY, LABEL, MESSAGE, DATA, HIDE
          // TODO: only show under certain circumstances
          if (!success && !(category === "Instructor" && label === "No errors")) {
            feedback.presentFeedback(category, label, message, line);
          }

          engine.main.components.feedback.presentFeedback(module.$d);
          engine.main.model.execution.status("complete");
        }
      });
      engine.main.components.server.logEvent("engine", "on_change");
    }
  }, {
    key: "executionEnd_",

    /**
     * Helper function that will attempt to call the defined onExecutionEnd,
     * but will do nothing if there is no function defined.
     */
    value: function executionEnd_() {
      if (this.onExecutionEnd !== null) {
        this.onExecutionEnd();
      }
    }
    /**
     *
     */

  }, {
    key: "executionBegin_",
    value: function executionBegin_() {
      if (this.onExecutionBegin !== null) {
        this.onExecutionBegin();
      }
    }
  }]);

  return BlockPyEngine;
}();

/***/ }),

/***/ "./src/engine/configurations.js":
/*!**************************************!*\
  !*** ./src/engine/configurations.js ***!
  \**************************************/
/*! exports provided: EMPTY_MODULE, Configuration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY_MODULE", function() { return EMPTY_MODULE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Configuration", function() { return Configuration; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EMPTY_MODULE = "let $builtinmodule = function(mod){ return mod; }";
/**
 * A container for holding settings of a particular run configuration.
 * This is the root class for all other configurations.
 */

var Configuration = /*#__PURE__*/function () {
  function Configuration(main) {
    _classCallCheck(this, Configuration);

    this.main = main;
    this.filename = null;
    this.code = null;
    this.sysmodules = undefined;
  }

  _createClass(Configuration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      // Access point for instructor data
      this.engine = engine;
      Sk.executionReports = this.main.model.execution.reports;
      Sk.console = this.main.components.console;
      Sk.queuedInput = [];
      Sk.configure(this.getSkulptOptions()); // Set openFile as mechanism to read files

      Sk.inBrowser = this.openFile.bind(this); // Proxy requests

      Sk.requestsGet = function (url, data, timeout) {
        return _this.openURL(url, data, timeout);
      }; // Configure a "do you want to wait? prompt"


      Sk.timeoutHandler = function (timePassed, execLimit) {
        if (_this.main.model.assignment.settings.disableTimeout()) {
          return null;
        }

        var promptMessage = _this.getTimeoutPrompt(timePassed / 1000 > 30);

        var delay = prompt(promptMessage, Sk.execLimit / 1000);

        if (delay !== null || delay == 0) {
          delay = Sk.execLimit + parseInt(delay, 10) * 1000;
          Sk.execLimit = delay;

          Sk.execLimitFunction = function () {
            return _this.main.model.assignment.settings.disableTimeout() ? Infinity : delay;
          };
        }

        return delay;
      };

      return this;
    }
  }, {
    key: "getTimeoutPrompt",
    value: function getTimeoutPrompt(longTimeout) {
      if (longTimeout) {
        return "The program has taken a REALLY long time to run (30 or more seconds). You might want to cancel and check your code. Or, you can add more seconds to wait below.";
      } else {
        return "The program is taking a while to run. How many more seconds would you like to wait?";
      }
    }
  }, {
    key: "getSkulptOptions",
    value: function getSkulptOptions() {
      return {
        __future__: Sk.python3,
        // import
        read: this.importFile.bind(this),
        // open
        //fileopen: this.openFile.bind(this),
        // file.write
        filewrite: this.writeFile.bind(this),
        // print
        output: this.print.bind(this),
        // input
        inputfun: this.input.bind(this),
        inputfunTakesPrompt: true,
        // Media Image Proxy URL
        imageProxy: this.getImageProxy.bind(this),
        // Whether or not to keep the globals
        retainGlobals: true
      };
    }
    /**
     * Used to access Skulpt built-ins. This is pretty generic, taken
     * almost directly from the Skulpt docs.
     *
     * @param {String} filename - The python filename (e.g., "os" or "pprint") that will be loaded.
     * @returns {String} The JavaScript source code of the file (weird, right?)
     * @throws Will throw an error if the file isn't found.
     */

  }, {
    key: "importFile",
    value: function importFile(filename) {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "openURL",
    value: function openURL(url, data, timeout) {
      //return new Promise((resolve, reject) => {
      var mockUrlData = this.main.components.fileSystem.getFile("?mock_urls.blockpy");

      if (mockUrlData == null) {
        throw new Sk.builtin.IOError("Cannot access url: URL Data was not made available for this assignment");
      }

      mockUrlData = JSON.parse(mockUrlData.handle());

      for (var filename in mockUrlData) {
        if (mockUrlData.hasOwnProperty(filename)) {
          for (var i = 0; i < mockUrlData[filename].length; i += 1) {
            if (mockUrlData[filename][i] === url) {
              var fileData = this.main.components.fileSystem.readFile(filename);
              return fileData;
            }
          }
        }
      } //reject(new Sk.builtin.IOError("Cannot access url: "+url+" was not made available for this assignment"));


      throw new Sk.builtin.IOError("Cannot access url: " + url + " was not made available for this assignment"); //});
    }
  }, {
    key: "openFile",
    value: function openFile() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "writeFile",
    value: function writeFile() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "print",
    value: function print(value) {
      this.main.components.console.print(value);
    }
  }, {
    key: "input",
    value: function input() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "clearInput",
    value: function clearInput() {
      if (this.main.model.display.clearInputs()) {
        this.main.model.execution.input([]);
      }

      this.main.model.execution.inputIndex(0);
    }
  }, {
    key: "getImageProxy",
    value: function getImageProxy(url) {
      // TODO
      return url;
    }
  }, {
    key: "step",
    value: function step() {}
  }, {
    key: "lastStep",
    value: function lastStep() {}
  }, {
    key: "isForbidden",
    value: function isForbidden(filename) {
      return false;
    }
  }, {
    key: "success",
    value: function success(module) {
      throw new Error("Abstract success execution");
    }
  }, {
    key: "failure",
    value: function failure(error) {
      throw new Error("Abstract failure execution");
    }
  }, {
    key: "finally",
    value: function _finally(result) {
      // Force Pygame to stop trapping keyboard events
      if (this.main.components.console.pygameLine) {
        this.main.components.console.pygameLine.cleanup();
        this.main.components.console.pygameLine.stop();
      }
    }
  }, {
    key: "dummyOutSandbox",
    value: function dummyOutSandbox() {//Sk.builtinFiles.files["src/lib/pedal/sandbox/sandbox.py"] = "class Sandbox: pass\ndef run(): pass\ndef reset(): pass\n";
    }
  }], [{
    key: "inputMockFunction",
    value: function inputMockFunction() {
      if (Sk.queuedInput.length) {
        return Sk.queuedInput.pop();
      } else {
        return "";
      }
    }
  }]);

  return Configuration;
}();

/***/ }),

/***/ "./src/engine/eval.js":
/*!****************************!*\
  !*** ./src/engine/eval.js ***!
  \****************************/
/*! exports provided: EvalConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EvalConfiguration", function() { return EvalConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../trace */ "./src/trace.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var EvalConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(EvalConfiguration, _StudentConfiguration);

  var _super = _createSuper(EvalConfiguration);

  function EvalConfiguration() {
    _classCallCheck(this, EvalConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(EvalConfiguration, [{
    key: "use",
    value: function use(engine, code) {
      // TODO: fix to be currently added line
      this.main.model.execution.feedback.message("Running...");
      this.filename = "answer";
      this.code = "_ = " + code;
      Sk.afterSingleExecution = null;
      Sk.beforeCall = null;

      _get(_getPrototypeOf(EvalConfiguration.prototype), "use", this).call(this, engine);

      Sk.retainGlobals = true;
      Sk.globals = this.main.model.execution.student.globals();
      this.main.components.server.logEvent("X-File.Add", "", "", code, "evaluations");
      this.main.components.server.logEvent("Compile", "", "", this.code, "evaluations");
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      var _this = this;

      console.log("Eval success");
      this.main.components.server.logEvent("X-Evaluate.Program", "", "", "", "evaluations");
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      this.main.model.execution.student.globals(Sk.globals);
      Sk.globals = {};
      var report = this.main.model.execution.reports;
      var filename = this.filename;
      this.main.model.execution.student.results = module;
      this.main.components.console.printValue(Sk.ffi.remapToJs(module.$d._.$r()));
      return new Promise(function (resolve, reject) {
        //this.step(module.$d, module.$d,-1, 0, filename + ".py");
        _this.lastStep();

        report["student"] = {
          "success": true,
          "trace": _this.engine.executionBuffer.trace,
          "lines": _this.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "results": module,
          "output": _this.main.model.execution.output,
          "evaluation": _this.code,
          "calls": _this.main.model.execution.student.calls
        };
        resolve();
      });
    }
  }, {
    key: "failure",
    value: function failure(error) {
      var _this2 = this;

      console.log("Eval failure");
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED);
      var report = this.main.model.execution.reports;
      this.main.components.server.logEvent("Compile.Error", "", "", error.toString(), "evaluations");
      return new Promise(function (resolve, reject) {
        report["student"] = {
          "success": false,
          "error": error,
          "evaluation": _this2.code
        };
        console.error(error);
        resolve();
      });
    }
  }]);

  return EvalConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/instructor.js":
/*!**********************************!*\
  !*** ./src/engine/instructor.js ***!
  \**********************************/
/*! exports provided: InstructorConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstructorConfiguration", function() { return InstructorConfiguration; });
/* harmony import */ var _configurations_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configurations.js */ "./src/engine/configurations.js");
/* harmony import */ var _skulpt_modules_sk_mod_instructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../skulpt_modules/sk_mod_instructor */ "./src/skulpt_modules/sk_mod_instructor.js");
/* harmony import */ var _skulpt_modules_coverage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../skulpt_modules/coverage */ "./src/skulpt_modules/coverage.js");
/* harmony import */ var _skulpt_modules_pedal_tracer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../skulpt_modules/pedal_tracer */ "./src/skulpt_modules/pedal_tracer.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var UTILITY_MODULE_CODE = "var $builtinmodule = " + _skulpt_modules_sk_mod_instructor__WEBPACK_IMPORTED_MODULE_1__["$sk_mod_instructor"].toString();
var COVERAGE_MODULE_CODE = _skulpt_modules_coverage__WEBPACK_IMPORTED_MODULE_2__["$sk_mod_coverage"];
var InstructorConfiguration = /*#__PURE__*/function (_Configuration) {
  _inherits(InstructorConfiguration, _Configuration);

  var _super = _createSuper(InstructorConfiguration);

  function InstructorConfiguration() {
    _classCallCheck(this, InstructorConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(InstructorConfiguration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      _get(_getPrototypeOf(InstructorConfiguration.prototype), "use", this).call(this, engine); // Instructors get 4 seconds


      Sk.execLimitFunction = function () {
        return _this.main.model.assignment.settings.disableTimeout() ? Infinity : 7000;
      };

      Sk.execLimit = Sk.execLimitFunction(); // Stepper! Executed after every statement.

      Sk.afterSingleExecution = null; // 10 *1000

      Sk.beforeCall = null; // Mute everything

      this.main.model.display.mutePrinter(true); // Disable input box

      Sk.queuedInput = []; // TODO Sk.inputfun = BlockPyEngine.inputMockFunction;
      // TODO: Allow input function to disable the timer, somehow
      // Enable utility mode

      Sk.builtinFiles.files["src/lib/utility/__init__.js"] = UTILITY_MODULE_CODE;
      Sk.builtinFiles.files["src/lib/coverage.py"] = COVERAGE_MODULE_CODE; // TODO: Check if this needs to be optimized
      //const PEDAL_TRACER_MODULE_CODE = Sk.compile($pedal_tracer, "tracer.py", "exec", true, false);

      Sk.builtinFiles.files["src/lib/pedal/sandbox/tracer.py"] = _skulpt_modules_pedal_tracer__WEBPACK_IMPORTED_MODULE_3__["$pedal_tracer"];
      delete Sk.builtinFiles.files["src/lib/pedal/sandbox/tracer.js"]; // TODO: Mock Pedal's tracer module with the appropriate version

      Sk.builtinFiles.files["./_instructor/__init__.js"] = _configurations_js__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"]; // Reuse any existing sysmodules that we previously found;

      this.sysmodules = this.main.model.execution.instructor.sysmodules; // Remove any existing __main__ modules

      var $main = new Sk.builtin.str("__main__");

      if (this.sysmodules !== undefined) {
        if (this.sysmodules.quick$lookup($main)) {
          this.sysmodules.del$item($main);
        }
      }

      return this;
    }
  }, {
    key: "getTimeoutPrompt",
    value: function getTimeoutPrompt(longTimeout) {
      if (longTimeout) {
        return "The instructor code has taken a REALLY long time to check your code (30 or more seconds). You might want to cancel and check your code (or get help from an instructor). Or, you can add more seconds to wait below.";
      } else {
        return "The instructor code is taking a little while to check your code; it might just need a little more time. How many more seconds would you like to wait?";
      }
    }
  }, {
    key: "openFile",
    value: function openFile(filename) {
      var found = this.main.components.fileSystem.searchForFile(filename, false);

      if (found === undefined) {
        throw new Sk.builtin.OSError("File not found: " + filename);
      } else {
        return found.contents();
      }
    }
  }, {
    key: "importFile",
    value: function importFile(filename) {
      if (filename === "./answer.py") {
        return this.main.model.submission.code();
      } else if (filename === "./_instructor/on_run.py") {
        return this.main.model.assignment.onRun();
      } else if (filename === "./_instructor/on_eval.py") {
        return this.main.model.assignment.onEval() || "";
      } else if (filename === "./_instructor/__init__.js") {
        return _configurations_js__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"];
      } else if (Sk.builtinFiles === undefined) {
        throw new Sk.builtin.OSError("Built-in modules not accessible.");
      } else if (Sk.builtinFiles["files"][filename] !== undefined) {
        return Sk.builtinFiles["files"][filename];
      } else {
        var found = this.main.components.fileSystem.searchForFile(filename, false);

        if (found === undefined) {
          throw new Sk.builtin.OSError("File not found: '" + filename + "'");
        } else {
          return found.contents();
        }
      }
    }
  }, {
    key: "input",
    value: function input(promptMessage) {
      //return "ApplePie";
      if (this.main.model.execution.inputIndex() < this.main.model.execution.input().length) {
        var inputIndex = this.main.model.execution.inputIndex();
        var nextInput = this.main.model.execution.input()[inputIndex];
        this.main.model.execution.inputIndex(inputIndex + 1);
        return nextInput;
      } else {
        return "ApplePie";
      }
      /*return new Promise((resolve) => {
          resolve(Sk.queuedInput.pop());
      });*/

    }
  }]);

  return InstructorConfiguration;
}(_configurations_js__WEBPACK_IMPORTED_MODULE_0__["Configuration"]);

/***/ }),

/***/ "./src/engine/on_change.js":
/*!*********************************!*\
  !*** ./src/engine/on_change.js ***!
  \*********************************/
/*! exports provided: OnChangeConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnChangeConfiguration", function() { return OnChangeConfiguration; });
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var OnChangeConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnChangeConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnChangeConfiguration);

  function OnChangeConfiguration() {
    _classCallCheck(this, OnChangeConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnChangeConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnChangeConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "on_change.py";
      this.code = this.main.model.assignment.onChange();
      clearTimeout(this.main.model.display.triggerOnChange);
      return this;
    }
  }]);

  return OnChangeConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_0__["InstructorConfiguration"]);

/***/ }),

/***/ "./src/engine/on_eval.js":
/*!*******************************!*\
  !*** ./src/engine/on_eval.js ***!
  \*******************************/
/*! exports provided: WRAP_INSTRUCTOR_CODE, OnEvalConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WRAP_INSTRUCTOR_CODE", function() { return WRAP_INSTRUCTOR_CODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnEvalConfiguration", function() { return OnEvalConfiguration; });
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _on_run__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./on_run */ "./src/engine/on_run.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities */ "./src/utilities.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





/**
 * @return {string}
 */

var WRAP_INSTRUCTOR_CODE = function WRAP_INSTRUCTOR_CODE(studentCode, instructorCode, quick, isSafe) {
  var safeCode = JSON.stringify(studentCode);
  var indentedCode = Object(_utilities__WEBPACK_IMPORTED_MODULE_3__["indent"])(Object(_utilities__WEBPACK_IMPORTED_MODULE_3__["indent"])(isSafe ? studentCode : "None"));
  return "\nfrom utility import *\n\n# Load in some commonly used tools\nfrom pedal.cait.cait_api import parse_program\nfrom pedal.sandbox.commands import *\nfrom pedal.core.commands import *\n\n# Backup the feedback\non_run_feedback = []\nfor feedback in MAIN_REPORT.feedback:\n    on_run_feedback.append(feedback)\nMAIN_REPORT.feedback.clear()\n\nfrom pedal.environments.blockpy import setup_environment\n# Add in evaluated stuff from last time\nstudent = get_sandbox()\n# TODO: What about new inputs since we last ran/evaled?\nMAIN_REPORT.submission.files['evaluation'] = ".concat(safeCode, "\nevaluate(").concat(safeCode, ")\n\n# TODO: Refactor resolver to return instructions\n# Monkey-patch questions\n#from pedal import questions\n#questions.show_question = set_instructions\n\n# Run the actual instructor code\n").concat(instructorCode, "\n\n# Resolve everything\nfrom pedal.resolvers.simple import resolve\nfinal = resolve()\nSUCCESS = final.success\nSCORE = final.score\nCATEGORY = final.category\nLABEL = final.title\nMESSAGE = final.message\nDATA = final.data\nHIDE = final.hide_correctness\n\n# Handle questions\nif final.instructions:\n    set_instructions(final.instructions[-1].message)\n    \n# Handle positive feedback\nPOSITIVE = []\nfor positive in final.positives:\n    message = positive.message\n    if not positive:\n        message = positive.else_message\n    POSITIVE.append({\n        \"title\": positive.title,\n        \"label\": positive.label,\n        \"message\": message\n    })\n    \n# Handle system messages\nfor system in final.systems:\n    if system.label == 'log':\n        console_log(system.title, system.message);\n    if system.label == 'debug':\n        console_debug(system.title, system.message);\n\n");
};
var OnEvalConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnEvalConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnEvalConfiguration);

  function OnEvalConfiguration() {
    _classCallCheck(this, OnEvalConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnEvalConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnEvalConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "_instructor.on_eval";
      this.code = this.main.model.assignment.onEval() || "";
      var disableTifa = this.main.model.assignment.settings.disableTifa();
      var report = this.main.model.execution.reports;
      var studentCodeSafe = this.main.model.execution.reports.student.evaluation || "None";
      this.dummyOutSandbox();
      var instructorCode = this.code;
      var lineOffset = instructorCode.split(_on_run__WEBPACK_IMPORTED_MODULE_2__["NEW_LINE_REGEX"]).length;
      var isSafe = !report["parser"].empty && report["verifier"].success;
      instructorCode = WRAP_INSTRUCTOR_CODE(studentCodeSafe, instructorCode, disableTifa, isSafe);
      lineOffset = instructorCode.split(_on_run__WEBPACK_IMPORTED_MODULE_2__["NEW_LINE_REGEX"]).length - lineOffset;
      report["instructor"] = {
        "compliments": [],
        "filename": "./_instructor/on_eval.py",
        "code": instructorCode,
        "lineOffset": lineOffset //'complete': false // Actually, let's use undefined for now.

      };
      this.code = instructorCode;

      _get(_getPrototypeOf(OnEvalConfiguration.prototype), "use", this).call(this, engine); //Sk.retainGlobals = false;


      Sk.globals = this.main.model.execution.instructor.globals;
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      console.log("OnEval success"); // TODO: Actually parse results

      this.main.model.execution.instructor.globals = Sk.globals;
      this.main.model.execution.instructor.sysmodules = Sk.sysmodules;
      console.log(module);
      var results = module.$d.on_eval.$d;
      console.log(module.$d);
      this.main.components.feedback.presentFeedback(results);
      this.main.model.execution.reports["instructor"]["success"] = true;
      var success = Sk.ffi.remapToJs(results.SUCCESS);
      this.main.model.submission.correct(success || this.main.model.submission.correct()); // Cannot exceed 1 point, cannot go below 0 points

      var score = Sk.ffi.remapToJs(results.SCORE);
      score = Math.max(0.0, Math.min(1.0, score));
      var oldScore = this.main.model.submission.score();
      this.main.model.submission.score(Math.max(oldScore, score)); // Hide status

      var hide = Sk.ffi.remapToJs(results.HIDE); // And fire the result!

      this.main.components.server.updateSubmission(score, success, hide, false);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY); //after(module);

      /*if (success && this.main.model.configuration.callbacks.success) {
          this.main.model.configuration.callbacks.success(this.main.model.assignment.id());
      }*/

      if (!Sk.executionReports.instructor.scrolling) {
        try {
          this.main.components.console.scrollToBottom();
        } catch (e) {}
      }
    }
  }, {
    key: "failure",
    value: function failure(error) {
      console.log("OnEval failure");
      var report = this.main.model.execution.reports;

      if (error.tp$name === "GracefulExit") {
        report["instructor"]["success"] = true;
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      } else {
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED); //console.log(report["instructor"]["code"]);

        console.error(error);
        this.main.components.feedback.presentInternalError(error, this.filename); //report["instructor"]["success"] = false;
        //report["instructor"]["error"] = error;
        //TODO: report["instructor"]["line_offset"] = lineOffset;
      } //TODO: after(error);

    }
  }]);

  return OnEvalConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_0__["InstructorConfiguration"]);

/***/ }),

/***/ "./src/engine/on_run.js":
/*!******************************!*\
  !*** ./src/engine/on_run.js ***!
  \******************************/
/*! exports provided: NEW_LINE_REGEX, WRAP_INSTRUCTOR_CODE, OnRunConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEW_LINE_REGEX", function() { return NEW_LINE_REGEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WRAP_INSTRUCTOR_CODE", function() { return WRAP_INSTRUCTOR_CODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnRunConfiguration", function() { return OnRunConfiguration; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities */ "./src/utilities.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var NEW_LINE_REGEX = /\r\n|\r|\n/;
/**
 * @return {string}
 */

var WRAP_INSTRUCTOR_CODE = function WRAP_INSTRUCTOR_CODE(studentCode, instructorCode, quick, isSafe) {
  var safeCode = JSON.stringify(studentCode);
  var indentedCode = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["indent"])(Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["indent"])(isSafe ? studentCode : "pass"));
  var tifaAnalysis = "";

  if (!quick) {
    tifaAnalysis = "from pedal.tifa import tifa_analysis\ntifa_analysis(False)";
  }

  var skip_tifa = quick ? "True" : "False"; // TODO: Add in Sk.queuedInput to be passed in

  return "\n# Support our sysmodules hack by clearing out any lingering old data\nfrom pedal.core.report import MAIN_REPORT\nMAIN_REPORT.clear()\n\nfrom cisc108 import student_tests\nstudent_tests.reset()\n\nfrom utility import *\n\n# Load in some commonly used tools\nfrom pedal.cait.cait_api import parse_program\nfrom pedal.sandbox.commands import *\nfrom pedal.core.commands import *\n\nfrom pedal.environments.blockpy import setup_environment\n# Do we execute student's code?\nskip_run = get_model_info('assignment.settings.disableInstructorRun')\ninputs = None if skip_run else get_model_info('execution.input')\n\n# Initialize the BlockPy environment\npedal = setup_environment(skip_tifa=".concat(skip_tifa, ",\n                          skip_run=skip_run,\n                          inputs=inputs,\n                          main_file='answer.py',\n                          main_code=").concat(safeCode, ")\nstudent = pedal.fields['student']\n\n# TODO: Refactor resolver to return instructions\n# Monkey-patch questions\n#from pedal import questions\n#questions.show_question = set_instructions\n\n# Run the actual instructor code\n").concat(instructorCode, "\n\n# Resolve everything\nfrom pedal.resolvers.simple import resolve\nfinal = resolve()\nSUCCESS = final.success\nSCORE = final.score\nCATEGORY = final.category\nLABEL = final.title\nMESSAGE = final.message\nDATA = final.data\nHIDE = final.hide_correctness\n\n# Handle questions\nif final.instructions:\n    set_instructions(final.instructions[-1].message)\n    \n# Handle positive feedback\nPOSITIVE = []\nfor positive in final.positives:\n    message = positive.message\n    if not positive:\n        message = positive.else_message\n    POSITIVE.append({\n        \"title\": positive.title,\n        \"label\": positive.label,\n        \"message\": message\n    })\n    \n# Handle system messages\nfor system in final.systems:\n    if system.label == 'log':\n        console_log(system.title, system.message);\n    if system.label == 'debug':\n        console_debug(system.title, system.message);\n\n");
};
var OnRunConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnRunConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnRunConfiguration);

  function OnRunConfiguration() {
    _classCallCheck(this, OnRunConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnRunConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnRunConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "_instructor.on_run";
      this.code = this.main.model.assignment.onRun();
      var disableTifa = this.main.model.assignment.settings.disableTifa();
      var report = this.main.model.execution.reports;
      var studentCodeSafe = this.main.model.submission.code();
      this.dummyOutSandbox();
      var instructorCode = this.code;
      var lineOffset = instructorCode.split(NEW_LINE_REGEX).length;
      var isSafe = !report["parser"].empty && report["verifier"].success;
      instructorCode = WRAP_INSTRUCTOR_CODE(studentCodeSafe, instructorCode, disableTifa, isSafe);
      lineOffset = 0; //instructorCode.split(NEW_LINE_REGEX).length - lineOffset - 4;

      report["instructor"] = {
        "compliments": [],
        "filename": "./_instructor/on_run.py",
        "code": instructorCode,
        "lineOffset": lineOffset //'complete': false // Actually, let's use undefined for now.

      };
      this.code = instructorCode;
      Sk.retainGlobals = false;
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      // TODO Logging!!!!
      //console.log("OnRun success");
      // TODO: Actually parse results
      this.main.model.execution.instructor.globals = Sk.globals;
      this.main.model.execution.instructor.sysmodules = Sk.sysmodules;
      Sk.globals = {};
      var results = module.$d.on_run.$d;
      this.main.components.feedback.presentFeedback(results);
      this.main.model.execution.reports["instructor"]["success"] = true;
      var success = Sk.ffi.remapToJs(results.SUCCESS);
      this.main.model.submission.correct(success || this.main.model.submission.correct()); // Cannot exceed 1 point, cannot go below 0 points

      var score = Sk.ffi.remapToJs(results.SCORE);
      score = Math.max(0, Math.min(1, score));
      var oldScore = this.main.model.submission.score();
      score = Math.max(oldScore, score);
      this.main.model.submission.score(score); // Hide status

      var hide = Sk.ffi.remapToJs(results.HIDE); // And fire the result!

      this.main.components.server.updateSubmission(score, success, hide, false);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY); //after(module);

      /*if (success && this.main.model.configuration.callbacks.success) {
          this.main.model.configuration.callbacks.success(this.main.model.assignment.id());
      }*/

      if (!Sk.executionReports.instructor.scrolling) {
        try {
          this.main.components.console.scrollToBottom();
        } catch (e) {}
      }
    }
  }, {
    key: "failure",
    value: function failure(error) {
      console.log("OnRun failure");
      var report = this.main.model.execution.reports;

      if (error.tp$name === "GracefulExit") {
        report["instructor"]["success"] = true;
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      } else {
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED); //console.log(report["instructor"]["code"]);

        console.error(error);
        this.main.components.feedback.presentInternalError(error, this.filename); //report["instructor"]["success"] = false;
        //report["instructor"]["error"] = error;
        //TODO: report["instructor"]["line_offset"] = lineOffset;
      } //TODO: after(error);

    }
  }]);

  return OnRunConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_2__["InstructorConfiguration"]);
/*
# The following is the old instructor code, leaving it here for now.

from pedal.core.report import MAIN_REPORT
# Support our sysmodules hack by clearing out any lingering old data
MAIN_REPORT.clear()
from pedal.core.commands import contextualize_report
contextualize_report(${safeCode}, "answer.py")
${tifaAnalysis}
from pedal.sandbox.sandbox import Sandbox
from pedal.sandbox import compatibility
from utility import *
student = MAIN_REPORT['sandbox']['run'] = Sandbox()
student.report_exceptions_mode = True
log(get_model_info('execution.input'))
student.set_input(get_model_info('execution.input'))
if not get_model_info('assignment.settings.disableInstructorRun'):
    compatibility.run_student(raise_exceptions=False)
#log(student.data)
#student = get_student_data()
#error, position = get_student_error()
#compatibility.raise_exception(error, position)
run_student = compatibility.run_student
reset_output = compatibility.reset_output
queue_input = compatibility.queue_input
get_output = compatibility.get_output
get_plots = compatibility.get_plots
compatibility.trace_lines = trace_lines
from pedal import questions
questions.show_question = set_instructions
# TODO: Remove the need for this hack!
def capture_output(func, *args):
   reset_output()
   student.call(func.__name__, *args)
   return get_output()
compatibility.capture_output = capture_output

from pedal.cait.cait_api import parse_program
${instructorCode}
from pedal.resolvers import simple
final = simple.resolve()
SUCCESS = final.success
SCORE = final.score
CATEGORY = final.category
LABEL = final.title
MESSAGE = final.message
DATA = final.data
HIDE = final.hide_correctness

 */

/***/ }),

/***/ "./src/engine/on_sample.js":
/*!*********************************!*\
  !*** ./src/engine/on_sample.js ***!
  \*********************************/
/*! exports provided: OnSampleConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnSampleConfiguration", function() { return OnSampleConfiguration; });
/* harmony import */ var _on_run__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./on_run */ "./src/engine/on_run.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var OnSampleConfiguration = /*#__PURE__*/function (_OnRunConfiguration) {
  _inherits(OnSampleConfiguration, _OnRunConfiguration);

  var _super = _createSuper(OnSampleConfiguration);

  function OnSampleConfiguration() {
    _classCallCheck(this, OnSampleConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnSampleConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnSampleConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "on_run.py";
      this.code = this.main.model.assignment.onRun();
      return this;
    }
  }]);

  return OnSampleConfiguration;
}(_on_run__WEBPACK_IMPORTED_MODULE_0__["OnRunConfiguration"]);

/***/ }),

/***/ "./src/engine/run.js":
/*!***************************!*\
  !*** ./src/engine/run.js ***!
  \***************************/
/*! exports provided: RunConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RunConfiguration", function() { return RunConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var RunConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(RunConfiguration, _StudentConfiguration);

  var _super = _createSuper(RunConfiguration);

  function RunConfiguration() {
    _classCallCheck(this, RunConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(RunConfiguration, [{
    key: "use",
    value: function use(engine) {
      this.main.model.execution.feedback.message("Running...");
      this.filename = "answer";
      this.code = this.main.model.submission.code();
      this.main.components.server.saveFile("answer.py", this.code, null);
      this.main.components.server.logEvent("Compile", "", "", "", "answer.py");

      _get(_getPrototypeOf(RunConfiguration.prototype), "use", this).call(this, engine);

      engine.reset();
      this.updateParse();
      this.main.model.execution.reports["verifier"] = {
        "success": Boolean(this.code.trim()),
        "code": this.code
      };
      Sk.retainGlobals = false;
      this.clearInput();
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      var _this = this;

      console.log("Run success");
      var message = {
        "inputs": this.main.model.execution.input().join("\n"),
        "outputs": this.main.model.execution.output().map(function (line) {
          return line.content;
        }).join("\n")
      };
      this.main.components.server.logEvent("Run.Program", "", "", JSON.stringify(message), "answer.py");
      this.main.model.display.dirtySubmission(false);
      this.main.components.console.finishTurtles();
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      this.main.model.execution.student.globals(Sk.globals);
      Sk.globals = {};
      var report = this.main.model.execution.reports;
      var filename = this.filename;
      this.main.model.execution.student.results = module;

      if (!this.main.model.assignment.settings.hideEvaluate()) {
        this.main.components.console.beginEval();
      }

      return new Promise(function (resolve, reject) {
        _this.step(module.$d, module.$d, -1, 0, filename + ".py");

        _this.lastStep();

        report["student"] = {
          "success": true,
          "trace": _this.engine.executionBuffer.trace,
          "lines": _this.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "results": module,
          "output": _this.main.model.execution.output,
          "input": _this.main.model.execution.input,
          "calls": _this.main.model.execution.student.calls
        };
        resolve();
      });
    }
  }, {
    key: "failure",
    value: function failure(error) {
      var _this2 = this;

      console.log("Run failure");
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED);
      var report = this.main.model.execution.reports;

      if (report.parser.success && report.verifier.success) {
        this.main.components.server.logEvent("Compile.Error", "", "", error.toString(), "answer.py");
      } else {
        this.main.components.server.logEvent("Run.Program", "ProgramErrorOutput", "", error.toString(), "answer.py");
      }

      return new Promise(function (resolve, reject) {
        report["student"] = {
          "success": false,
          "error": error,
          "lines": _this2.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this2.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "input": _this2.main.model.execution.input,
          "calls": _this2.main.model.execution.student.calls
        };
        console.error(error);
        resolve();
      });
    }
  }]);

  return RunConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/sample.js":
/*!******************************!*\
  !*** ./src/engine/sample.js ***!
  \******************************/
/*! exports provided: SampleConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleConfiguration", function() { return SampleConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var SampleConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(SampleConfiguration, _StudentConfiguration);

  var _super = _createSuper(SampleConfiguration);

  function SampleConfiguration() {
    _classCallCheck(this, SampleConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(SampleConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(SampleConfiguration.prototype), "use", this).call(this, engine); // TODO: Fix to be the current sample submission


      this.filename = "answer.py";
      this.code = "print('Not ready yet!')";
      return this;
    }
  }]);

  return SampleConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/student.js":
/*!*******************************!*\
  !*** ./src/engine/student.js ***!
  \*******************************/
/*! exports provided: StudentConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StudentConfiguration", function() { return StudentConfiguration; });
/* harmony import */ var _configurations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configurations */ "./src/engine/configurations.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var StudentConfiguration = /*#__PURE__*/function (_Configuration) {
  _inherits(StudentConfiguration, _Configuration);

  var _super = _createSuper(StudentConfiguration);

  function StudentConfiguration() {
    _classCallCheck(this, StudentConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(StudentConfiguration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      _get(_getPrototypeOf(StudentConfiguration.prototype), "use", this).call(this, engine); // Limit execution to 4 seconds


      var settings = this.main.model.settings;

      Sk.execLimitFunction = function () {
        return _this.main.model.assignment.settings.disableTimeout() ? Infinity : 5000;
      };

      Sk.execLimit = Sk.execLimitFunction(); // Stepper! Executed after every statement.

      Sk.afterSingleExecution = this.step.bind(this);
      Sk.beforeCall = this.beforeCall.bind(this); // Unmute everything

      this.main.model.display.mutePrinter(false); // Function to call after each step
      // afterSingleExecution

      Sk.builtinFiles.files["src/lib/utility/__init__.js"] = _configurations__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"];
      return this;
    }
  }, {
    key: "openFile",
    value: function openFile(filename) {
      var found = this.main.components.fileSystem.searchForFile(filename, true); //console.log(filename, found);

      if (found === undefined) {
        throw new Sk.builtin.OSError("File not found: " + filename);
      } else {
        return found.contents();
      }
    }
  }, {
    key: "importFile",
    value: function importFile(filename) {
      if (this.isForbidden(filename)) {
        throw "File not accessible: '" + filename + "'";
      } else if (filename === "./answer.py") {
        return this.main.model.submission.code();
      } else if (Sk.builtinFiles === undefined) {
        throw new Sk.builtin.OSError("Built-in modules not accessible.");
      } else if (Sk.builtinFiles["files"][filename] !== undefined) {
        return Sk.builtinFiles["files"][filename];
      } else {
        var found = this.main.components.fileSystem.searchForFile(filename, true);

        if (found === undefined) {
          throw new Sk.builtin.OSError("File not found: '" + filename + "'");
        } else {
          return found.contents();
        }
      }
    }
  }, {
    key: "input",
    value: function input(promptMessage) {
      return this.main.components.console.input(promptMessage);
    }
  }, {
    key: "isForbidden",
    value: function isForbidden(filename) {
      return filename.startsWith("src/lib/utility/") || filename.startsWith("src/lib/pedal/") || filename.startsWith("./_instructor/");
    }
    /**
     * "Steps" the execution of the code, meant to be used as a callback to the Skulpt
     * environment.
     *
     * @param {Object} globals - Hash that maps the names of global variables (Strings) to their Skulpt representation.
     * @param {Object} locals - Hash that maps the names of local variables (Strings) to their Skulpt representation.
     * @param {Number} lineNumber - The corresponding line number in the source code that is being executed.
     * @param {Number} columnNumber - The corresponding column number in the source code that is being executed.
     *                                Think of it as the "X" position to the lineNumber's "Y" position.
     * @param {String} filename - The name of the python file being executed (e.g., "__main__.py").
     * @param {Boolean} isDocstring - Whether or not this is an actual line or a docstring.
     */

  }, {
    key: "step",
    value: function step(globals, locals, lineNumber, columnNumber, filename, isDocstring) {
      if (filename === "answer.py") {
        var currentStep = this.engine.executionBuffer.step;
        globals = this.main.components.trace.parseGlobals(globals); // TODO: Trace local variables properly
        //let locals = this.main.components.trace.parseGlobals(locals);
        //Object.assign(globals, locals);

        this.engine.executionBuffer.trace.push({
          "step": currentStep,
          "filename": filename,
          //'block': highlightMap[lineNumber-1],
          "line": lineNumber,
          "column": columnNumber,
          "properties": globals.properties,
          "modules": globals.modules,
          "isDocstring": isDocstring
        });
        this.engine.executionBuffer.step = currentStep + 1;
        this.engine.executionBuffer.line = lineNumber;
      }
    }
  }, {
    key: "beforeCall",
    value: function beforeCall(functionName, posargs, kwargs) {
      // TODO: Handle fastcall too? Check how that works in Skulpt side
      var studentModel = this.main.model.execution.student;

      if (!(functionName in studentModel.calls)) {
        studentModel.calls[functionName] = [];
      }

      var args = {}; // Get actual parameter names!!

      for (var i = 0; i < posargs.length; i += 1) {
        args["__ARG" + i] = posargs[i];
      }

      if (kwargs && kwargs[0] != null) {
        args["__ARGS"] = kwargs[0];
      }

      if (kwargs && kwargs[1] != null) {
        args["__KWARGS"] = kwargs[1];
      }

      console.log(args);
      studentModel.calls[functionName].push(args);
    }
    /**
     * Called at the end of the Skulpt execution to terminate the executionBuffer
     * and hand it off to the execution trace in the model.
     */

  }, {
    key: "lastStep",
    value: function lastStep() {
      var execution = this.main.model.execution;
      execution.student.currentTraceData(this.engine.executionBuffer.trace);
      execution.student.currentStep(this.engine.executionBuffer.step);
      execution.student.lastStep(this.engine.executionBuffer.step);
      execution.student.currentLine(this.engine.executionBuffer.line);
      execution.student.lastLine(this.engine.executionBuffer.line);
      execution.student.currentTraceStep(this.engine.executionBuffer.step);
    }
  }, {
    key: "getLines",
    value: function getLines(ast) {
      var visitedLines = new Set();

      var visitBody = function visitBody(node) {
        if (node.lineno !== undefined) {
          visitedLines.add(node.lineno);
        }

        if (node.body) {
          node.body.forEach(function (statement) {
            return visitBody(statement);
          });
        }

        if (node.orelse) {
          node.orelse.forEach(function (statement) {
            return visitBody(statement);
          });
        }

        if (node.finalbody) {
          node.finalbody.forEach(function (statement) {
            return visitBody(statement);
          });
        }
      };

      visitBody(ast);
      return Array.from(visitedLines);
    }
    /**
     * Ensure that the parse information is up-to-date
     */

  }, {
    key: "updateParse",
    value: function updateParse() {
      var report = this.main.model.execution.reports; // Hold all the actually discovered lines from the parse

      var lines = []; // Attempt a parse

      var ast;

      try {
        var parse = Sk.parse(this.filename, this.code);
        ast = Sk.astFromParse(parse.cst, this.filename, parse.flags);
        lines = this.getLines(ast);
      } catch (error) {
        // Report the error
        report["parser"] = {
          "success": false,
          "error": error,
          "empty": true,
          "lines": lines
        };
        console.error(error);
        console.log(this.filename, this.code);
        return false;
      } // Successful parse


      report["parser"] = {
        "success": true,
        "ast": ast,
        "empty": ast.body.length === 0,
        "lines": lines
      };
      return true;
    }
  }, {
    key: "showErrors",
    value: function showErrors() {
      var report = this.main.model.execution.reports;

      if (report["student"].success) {
        this.main.components.feedback.clear();
      } else {
        this.main.components.feedback.presentRunError(report.student.error);
      }
    }
  }, {
    key: "provideSecretError",
    value: function provideSecretError() {
      var _this2 = this;

      var report = this.main.model.execution.reports;
      var feedback = this.main.components.feedback;

      if (!report["student"].success) {
        var errorButton = this.main.model.configuration.container.find(".blockpy-student-error");
        var message = feedback.presentRunError(report.student.error, true);
        errorButton.attr("title", "Click to see Original Error");
        errorButton.tooltip({
          "trigger": "hover",
          "container": this.main.model.configuration.attachmentPoint
        });
        errorButton.click(function () {
          return _this2.main.components.dialog.ERROR_SHOW_STUDENT_ERROR(message);
        });
        errorButton.show();
      }
    }
  }]);

  return StudentConfiguration;
}(_configurations__WEBPACK_IMPORTED_MODULE_0__["Configuration"]);

/***/ }),

/***/ "./src/feedback.js":
/*!*************************!*\
  !*** ./src/feedback.js ***!
  \*************************/
/*! exports provided: FEEDBACK_HTML, BlockPyFeedback */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FEEDBACK_HTML", function() { return FEEDBACK_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyFeedback", function() { return BlockPyFeedback; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FEEDBACK_HTML = "\n\n<span class='blockpy-floating-feedback text-muted-less pull-right position-sticky sticky-top'\n    aria-hidden=\"true\" role=\"presentation\" aria-label=\"New Feedback Alert\">\n    New feedback &uarr;\n</span>\n\n<div class='blockpy-feedback col-md-6 blockpy-panel'\n            role=\"region\" aria-label=\"Feedback\"\n            aria-live=\"polite\">\n\n    <!-- Feedback/Trace Visibility Control -->\n    <button type='button'\n            class='btn btn-sm btn-outline-secondary float-right'\n            data-bind=\"click: ui.secondRow.advanceState\">\n        <span class='fas fa-eye'></span>\n        <span data-bind=\"text: ui.secondRow.switchLabel\"></span>\n    </button>\n    \n    <!-- Positive Feedback Region -->\n    <div class=\"blockpy-feedback-positive float-right\">\n        \n    \n    </div>\n\n    <!-- Actual Feedback Region -->    \n    <div>\n        <strong>Feedback: </strong>\n        <span class='badge blockpy-feedback-category feedback-badge'\n            data-bind=\"css: ui.feedback.badge,\n                       text: ui.feedback.category\">Feedback Kind</span>\n        <small data-bind=\"text: (100*submission.score())+'%',\n                          visible: display.instructor() && execution.feedback.label()\"\n            class=\"text-muted\"></small>\n    </div>\n    <div>\n        <strong class=\"blockpy-feedback-label\"\n            data-bind=\"text: execution.feedback.label\"></strong>\n        <div class=\"blockpy-feedback-message\"\n            data-bind=\"html: execution.feedback.message\"></div>\n    </div>\n</div>            \n";
var BlockPyFeedback = /*#__PURE__*/function () {
  /**
   * An object that manages the feedback area, where users are told the state of their
   * program's execution and given guidance. Also manages the creation of the Trace Table.
   *
   * @constructor
   * @this {BlockPyFeedback}
   * @param {Object} main - The main BlockPy instance
   * @param {HTMLElement} tag - The HTML object this is attached to.
   */
  function BlockPyFeedback(main, tag) {
    var _this = this;

    _classCallCheck(this, BlockPyFeedback);

    this.main = main;
    this.tag = tag;
    this.feedbackModel = this.main.model.execution.feedback;
    this.category = this.tag.find(".blockpy-feedback-category");
    this.label = this.tag.find(".blockpy-feedback-label");
    this.message = this.tag.find(".blockpy-feedback-message");
    this.positive = this.tag.find(".blockpy-feedback-positive"); // TODO: If they change the student extra files, also update the dirty flag

    this.main.model.submission.code.subscribe(function () {
      return _this.main.model.display.dirtySubmission(true);
    });
  }

  _createClass(BlockPyFeedback, [{
    key: "scrollIntoView",

    /**
     * Moves the screen (takes 1 second) to make the Feedback area visible.
     */
    value: function scrollIntoView() {
      $("html, body").animate({
        scrollTop: this.tag.offset().top
      }, 1000);
    }
  }, {
    key: "isFeedbackVisible",

    /**
     * Determines if the feedback area is currently visible
     * @returns {boolean}
     */
    value: function isFeedbackVisible() {
      var visibilityBuffer = 100;
      var topOfElement = this.tag.offset().top; //let bottomOfElement = this.tag.offset().top + this.tag.outerHeight();

      var bottomOfElement = topOfElement + visibilityBuffer;
      var bottomOfScreen = $(window).scrollTop() + $(window).height();
      var topOfScreen = $(window).scrollTop(); //bottom_of_element -= 40; // User friendly padding

      return topOfElement < bottomOfScreen && topOfScreen < bottomOfElement;
    }
  }, {
    key: "clear",

    /**
     * Clears any output currently in the feedback area. Also resets the printer and
     * any highlighted lines in the editor.
     */
    value: function clear() {
      this.feedbackModel.message("*Ready*");
      this.feedbackModel.category(null);
      this.feedbackModel.label(null);
      this.feedbackModel.hidden(false);
      this.feedbackModel.linesError.removeAll();
      this.feedbackModel.linesUncovered.removeAll();
      this.clearPositiveFeedback();
    }
  }, {
    key: "updateRegularFeedback",
    value: function updateRegularFeedback() {}
    /**
     * Updates the model with these new execution results
     * @param executionResults
     */

  }, {
    key: "updateFeedback",
    value: function updateFeedback(executionResults) {
      var _this2 = this;

      // Parse out data
      var message = Sk.ffi.remapToJs(executionResults.MESSAGE);
      var category = Sk.ffi.remapToJs(executionResults.CATEGORY);
      var label = Sk.ffi.remapToJs(executionResults.LABEL);
      var hide = Sk.ffi.remapToJs(executionResults.HIDE);
      var data = executionResults.DATA;
      var positives = Sk.ffi.remapToJs(executionResults.POSITIVE); // Override based on assignments' settings

      var hideScore = this.main.model.assignment.hidden();

      if (hideScore && category.toLowerCase() === "complete") {
        category = "no errors";
        label = "No errors";
        message = "No errors reported.";
      } // Remap to expected BlockPy labels


      if (category.toLowerCase() === "instructor" && label.toLowerCase() === "explain") {
        label = "Instructor Feedback";
      } // Don't present a lack of error as being incorrect


      if (category === "Instructor" && label === "No errors") {
        category = "no errors";
      } // Update model accordingly


      message = this.main.utilities.markdown(message).replace(/<pre>\n/g, "<pre>\n\n");
      this.feedbackModel.message(message);
      this.feedbackModel.category(category);
      this.feedbackModel.label(label); //let highlightTimeout = setTimeout(() => {

      this.message.find("pre code").map(function (i, block) {
        window.hljs.highlightBlock(block);
      }); //}, 400);
      // TODO: Instead of tracking student file, let's track the instructor file

      this.main.components.server.logEvent("Intervention", category, label, message, "answer.py"); // Clear out any previously highlighted lines

      this.main.components.pythonEditor.bm.clearHighlightedLines(); // Find the first error on a line and report that

      var line = BlockPyFeedback.findFirstErrorLine(data);
      this.feedbackModel.linesError.removeAll();

      if (line !== null && line !== undefined) {
        this.feedbackModel.linesError.push(line);
      } // Invert the set of traced lines


      var studentReport = this.main.model.execution.reports.student;
      this.feedbackModel.linesUncovered.removeAll();

      if (studentReport.success) {
        var uncoveredLines = [];
        this.main.model.execution.reports.parser.lines.forEach(function (line) {
          if (studentReport.lines.indexOf(line) === -1) {
            uncoveredLines.push(line);
          }
        });
        this.feedbackModel.linesUncovered(uncoveredLines);
      }

      var _loop = function _loop(i) {
        var positiveData = positives[i];

        _this2.addPositiveFeedback(positiveData.message, "star", "green", function () {
          return _this2.main.components.dialog.POSITIVE_FEEDBACK_FULL(positiveData.title, positiveData.message);
        });
      };

      for (var i = 0; i < positives.length; i += 1) {
        _loop(i);
      }
    }
  }, {
    key: "clearPositiveFeedback",
    value: function clearPositiveFeedback() {
      this.positive.empty();
      this.main.model.configuration.container.find(".blockpy-student-error").hide();
    }
  }, {
    key: "addPositiveFeedback",
    value: function addPositiveFeedback(text, icon, color, onclick, toEnd) {
      var _this3 = this;

      var positive = $("<span></span>");
      positive.addClass("blockpy-feedback-positive-icon fas fa-" + icon);
      positive.css("color", color);
      positive.attr("title", text);

      if (toEnd) {
        this.positive.append(positive);
      } else {
        this.positive.prepend(positive);
      }

      positive.tooltip({
        "trigger": "hover",
        "container": this.main.model.configuration.attachmentPoint
      });

      if (onclick !== undefined) {
        positive.click(onclick);
      }

      positive.hover(function () {
        _this3.main.components.server.logEvent("X-Feedback", "positive", "hover", text, "");
      });
    }
    /**
     * Present any accumulated feedback
     */

  }, {
    key: "presentFeedback",
    value: function presentFeedback(executionResults) {
      this.updateFeedback(executionResults); // TODO: Logging
      //this.main.components.server.logEvent("feedback", category+"|"+label, message);

      this.notifyFeedbackUpdate();
    }
  }, {
    key: "notifyFeedbackUpdate",
    value: function notifyFeedbackUpdate() {
      if (!this.isFeedbackVisible()) {
        this.tag.find(".blockpy-floating-feedback").show().fadeOut(7000);
        this.scrollIntoView();
      }
    }
  }, {
    key: "presentRunError",
    value: function presentRunError(error, just_return) {
      if (just_return === undefined) {
        just_return = false;
      }

      var message, label, category, lineno;
      label = error.tp$name;
      category = "runtime";
      message = this.convertSkulptError(error);

      if (just_return) {
        return message;
      }

      this.feedbackModel.message(message);
      this.feedbackModel.category(category);
      this.feedbackModel.label(label);
      this.feedbackModel.linesError.removeAll();

      if (lineno !== undefined && lineno !== null) {
        this.feedbackModel.linesError.push(lineno);
      }
    }
  }, {
    key: "convertSkulptError",
    value: function convertSkulptError(error, filenameExecuted) {
      var _this4 = this;

      var name = error.tp$name;
      var args = Sk.ffi.remapToJs(error.args);
      var top = "".concat(name, ": ").concat(args[0], "\n<br>\n<br>");
      var traceback = "";

      if (error.traceback && error.traceback.length) {
        traceback = "Traceback:<br>\n" + error.traceback.map(function (frame) {
          var lineno = frame.lineno;

          if (frame.filename.slice(0, -3) === filenameExecuted) {
            lineno -= _this4.main.model.execution.reports.instructor.lineOffset;
          }

          var file = "File <code class=\"filename\">\"".concat(frame.filename, "\"</code>, ");
          var line = "on line <code class=\"lineno\">".concat(lineno, "</code>, ");
          var scope = frame.scope !== "<module>" && frame.scope !== undefined ? "in scope ".concat(frame.scope) : "";
          var source = "";

          if (frame.source !== undefined) {
            source = "\n<pre><code>".concat(frame.source, "</code></pre>");
          }

          return file + line + scope + source;
        }).join("\n<br>");
        traceback = "".concat(traceback);
      }

      return top + "\n" + traceback;
    }
  }, {
    key: "presentInternalError",
    value: function presentInternalError(error, filenameExecuted) {
      this.main.model.execution.feedback.category("internal");
      this.main.model.execution.feedback.label("Internal Error");
      var message = "Error in instructor feedback. Please show the following to an instructor:<br>\n";
      message += this.convertSkulptError(error, filenameExecuted);
      this.main.model.execution.feedback.message(message);
      this.notifyFeedbackUpdate();
      this.main.components.server.logEvent("X-System.Error", "internal", "Internal Error", message, filenameExecuted);
    }
  }], [{
    key: "findFirstErrorLine",
    value: function findFirstErrorLine(feedbackData) {
      if (feedbackData.quick$lookup) {
        var location = feedbackData.quick$lookup(new Sk.builtin.str("location"));

        if (location) {
          var line = location.tp$getattr(new Sk.builtin.str("line"));

          if (line) {
            return Sk.ffi.remapToJs(line);
          }
        }
      }

      return null;
      /*for (let i = feedbackData.length-1; i >= 0; i-= 1) {
          if ("position" in feedbackData[i]) {
              return feedbackData[i].position.line;
          }
      }
      return null;*/
    }
  }]);

  return BlockPyFeedback;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/files.js":
/*!**********************!*\
  !*** ./src/files.js ***!
  \**********************/
/*! exports provided: FILES_HTML, STARTING_FILES, BASIC_NEW_FILES, UNDELETABLE_FILES, UNRENAMABLE_FILES, makeModelFile, loadConcatenatedFile, createConcatenatedFile, observeConcatenatedFile, BlockPyFileSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko, $) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILES_HTML", function() { return FILES_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING_FILES", function() { return STARTING_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BASIC_NEW_FILES", function() { return BASIC_NEW_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNDELETABLE_FILES", function() { return UNDELETABLE_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNRENAMABLE_FILES", function() { return UNRENAMABLE_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeModelFile", function() { return makeModelFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadConcatenatedFile", function() { return loadConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createConcatenatedFile", function() { return createConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observeConcatenatedFile", function() { return observeConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyFileSystem", function() { return BlockPyFileSystem; });
/* harmony import */ var utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utilities.js */ "./src/utilities.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

 // ${makeTab("?mock_urls.blockpy", "URL Data", true)}

var makeTab = function makeTab(filename, friendlyName, hideIfEmpty, notInstructor) {
  if (friendlyName === undefined) {
    friendlyName = filename;
  }

  var instructorFileClass = "";
  var hideIfNotInstructor = "true";

  if (!notInstructor) {
    instructorFileClass = "blockpy-file-instructor";
    hideIfNotInstructor = "display.instructor()";
  }

  return "\n    <li class=\"nav-item ".concat(instructorFileClass, "\">\n        <a class=\"nav-link\" href=\"#\"\n            data-toggle=\"tab\"\n            data-bind=\"css: {active: display.filename() === '").concat(filename, "'},\n                click: display.filename.bind($data, '").concat(filename, "'),\n                visible: (!").concat(hideIfEmpty, " || ui.files.hasContents('").concat(filename, "')) && ").concat(hideIfNotInstructor, "\">\n            ").concat(friendlyName, "</a>\n    </li>");
};

var FILES_HTML = "\n<div class=\"col-md-12 blockpy-panel blockpy-files\"\n    data-bind=\"visible: ui.files.visible\">\n<ul class=\"nav nav-tabs\" role=\"tablist\">\n\n    <li class=\"nav-item\">\n        <strong>View: </strong>\n    </li>\n\n    ".concat(makeTab("answer.py", undefined, undefined, true), "\n    ").concat(makeTab("!instructions.md", "Instructions"), "\n    ").concat(makeTab("!assignment_settings.blockpy", "Settings"), "\n    ").concat(makeTab("^starting_code.py", "Starting Code"), "\n    ").concat(makeTab("!on_run.py", "On Run"), "\n    ").concat(makeTab("!on_change.py", "On Change", true), "\n    ").concat(makeTab("!on_eval.py", "On Eval", true), "\n    ").concat(makeTab("!sample_submissions.blockpy", "Sample Submissions", true), "\n    ").concat(makeTab("!tags.blockpy", "Tags", true), "\n    \n    <!-- ko foreach: assignment.extraInstructorFiles -->\n        <li class=\"nav-item\"\n            data-bind=\"css: {'blockpy-file-instructor': !filename().startsWith('&')},\n                       visible: filename().startsWith('&') || $root.display.instructor() \">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename(),\n                                 uneditable: filename().startsWith('&')},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: $root.ui.files.displayFilename(filename())\">\n            </a>        \n        </li>\n    <!-- /ko -->\n    <!-- ko foreach: assignment.extraStartingFiles -->\n        <li class=\"nav-item blockpy-file-instructor\"\n            data-bind=\"visible: $root.display.instructor()\">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename()},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: filename\">\n            </a>        \n        </li>\n    <!-- /ko -->\n    \n    <!-- ko foreach: submission.extraFiles -->\n        <li class=\"nav-item\">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename()},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: $root.ui.files.displayFilename(filename())\">\n            </a>        \n        </li>\n    <!-- /ko -->\n  \n    <li class=\"nav-item dropdown\">\n        <a class=\"nav-link dropdown-toggle\" href=\"#\" data-toggle=\"dropdown\"\n         role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\">Add New</a>\n        <div class=\"dropdown-menu dropdown-menu-right\">\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?mock_urls.blockpy'),\n                           click: ui.files.add.bind($data, '?mock_urls.blockpy')\">URL Data</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?toolbox.blockpy'),\n                           click: ui.files.add.bind($data, '?toolbox.blockpy')\">Toolbox</a>\n            \n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!tags.blockpy')\">Tags</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!sample_submissions.blockpy'),\n                           click: ui.files.add.bind($data, '!sample_submissions.blockpy')\">Sample Submissions</a>\n            <div class=\"dropdown-divider\"></div>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: assignment.onChange,\n                           click: ui.files.add.bind($data, '!on_change.py')\">On Change</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: assignment.onEval,\n                           click: ui.files.add.bind($data, '!on_eval.py')\">On Eval</a>\n            <div class=\"dropdown-divider\"></div>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'starting')\">Starting File</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'instructor')\">Instructor File</a>\n            <a class=\"dropdown-item\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'student')\">Student File</a>\n        </div>\n    </li>\n  \n</ul>\n</div>\n");
var NEW_INSTRUCTOR_FILE_DIALOG_HTML = "\n<form>\n<div class=\"form-group row\">\n    <!-- Filename -->\n    <div class=\"col-sm-2 text-right\">\n        <label for=\"blockpy-instructor-file-dialog-filename\">Filename:</label>\n    </div>\n    <div class=\"col-sm-10\">\n        <input type=\"text\" class=\"form-control blockpy-instructor-file-dialog-filename\"\n            id=\"blockpy-instructor-file-dialog-filename\">    \n    </div>\n    <!-- Filetype -->\n    <div class=\"col-sm-2 text-right mt-2\">\n        <label for=\"blockpy-instructor-file-dialog-filetype\">Filetype: </label>\n    </div>\n    <div class=\"col-sm-10\">\n        <span class=\"blockpy-instructor-file-dialog-filetype\"\n            id=\"blockpy-instructor-file-dialog-filetype\"></span>    \n    </div>\n    <!-- Inaccessible to student? -->\n    <div class=\"col-sm-2 text-right mt-2\">\n        <label for=\"blockpy-instructor-file-dialog-namespace\">Namespace: </label>\n    </div>\n    <div class=\"col-sm-4\">\n        <select class=\"form-control blockpy-instructor-file-dialog-namespace\"\n            id=\"blockpy-instructor-file-dialog-namespace\">\n            <option value=\"!\">Completely inaccessible</option>\n            <option value=\"?\">Hidden from student, accessible programatically</option>\n            <option value=\"&\">Visible to student, but not editable</option>\n        </select>\n    </div>\n</div>\n</form>\n";
/**
 * Filenames live in one of five possible namespaces:
 *  Instructor (!): Invisible to the student under all circumstances
 *  Start Space (^): Used to reset the student namespace
 *  Student Space (): Visible to the student when display.hideFiles is not true, able to be edited
 *  Hidden Space (?): Not directly visible to the student, but accessible programmatically
 *  Read-only Space (&): An instructor file type visible to the student, but is uneditable by them
 *  Secret Space ($): Not visible from the menu at all, some other mechanism controls it
 *  Generated Space (*): Visible to the student, but destroyed after Engine.Clear. Can shadow an actual file.
 *  Concatenated Space (#): Used when bundling a space for the server.
 */

var STARTING_FILES = [// Submission
"answer.py", // Instructor files
"!instructions.md", "!assignment_settings.blockpy", "^starting_code.py", "!on_run.py", "$settings.blockpy"];
var BASIC_NEW_FILES = ["!on_change.py", "!on_eval.py", "?mock_urls.blockpy", "?toolbox.blockpy", "!tags.blockpy", "!sample_submissions.blockpy"];
var INSTRUCTOR_DIRECTORY = "_instructor/";
var STUDENT_DIRECTORY = "_student/";
var SearchModes = {
  EVERYWHERE: "EVERYWHERE",
  START_WITH_INSTRUCTOR: "START_WITH_INSTRUCTOR",
  ONLY_STUDENT_FILES: "ONLY_STUDENT_FILES"
};
var DELETABLE_SIMPLE_FILES = ["!on_change.py", "!on_eval.py"];
var UNDELETABLE_FILES = ["answer.py", "!instructions.md", "!assignment_settings.py", "^starting_code.py", "!on_run.py", "$settings.blockpy"];
var UNRENAMABLE_FILES = ["answer.py", "!instructions.md", "!assignment_settings.py", "^starting_code.py", "!on_run.py", "$settings.blockpy", "!on_change.py", "!on_eval.py", "?mock_urls.blockpy", "?toolbox.blockpy", "!tags.blockpy", "!sample_submissions.blockpy"];

var BlockPyFile = function BlockPyFile(main, filename, contents) {
  _classCallCheck(this, BlockPyFile);

  this.main = main;
  this.filename = filename;
  this.contents = contents || "";
  this.owner = null;
  this.handle = null;
};

function makeModelFile(filename, contents) {
  return {
    "filename": ko.observable(filename),
    contents: ko.observable(contents || "")
  };
}

function makeMockModelFile(_filename, _contents) {
  return {
    filename: function filename() {
      return _filename;
    },
    contents: function contents() {
      return _contents;
    }
  };
}

function loadConcatenatedFile(concatenatedFile, modelFileList) {
  if (concatenatedFile) {
    var files = JSON.parse(concatenatedFile);
    var modelFiles = [];

    for (var filename in files) {
      if (files.hasOwnProperty(filename)) {
        modelFiles.push(makeModelFile(filename, files[filename]));
      }
    } //files = files.map(file => makeModelFile(file.filename, file.contents));


    modelFileList(modelFiles);
  } else {
    modelFileList([]);
  }
}
function createConcatenatedFile(modelFileList) {
  return JSON.stringify(modelFileList().map(function (file) {
    return {
      filename: file.filename(),
      contents: file.contents()
    };
  }));
}
function observeConcatenatedFile(modelFileList) {
  return ko.pureComputed(function () {
    var result = {};
    modelFileList().forEach(function (file) {
      return result[file.filename()] = file.contents();
    });
    return JSON.stringify(result);
  });
}
/**
 * Abstracts away database logic
 */

var BlockPyFileSystem = /*#__PURE__*/function () {
  function BlockPyFileSystem(main) {
    _classCallCheck(this, BlockPyFileSystem);

    this.main = main;
    this.files_ = {};
    this.mountFiles();
    this.watchModel();
    this.watches_ = {};
    this.main.model.display.instructor.subscribe(function (visiblity) {
      $(".blockpy-file-instructor").toggle(visiblity);
    });
  }

  _createClass(BlockPyFileSystem, [{
    key: "watchFile",
    value: function watchFile(filename, callback) {
      if (!(filename in this.watches_)) {
        this.watches_[filename] = [];
      }

      this.watches_[filename].push(callback);
    }
  }, {
    key: "stopWatchingFile",
    value: function stopWatchingFile(filename) {
      delete this.watches_[filename];
    }
  }, {
    key: "watchModel",
    value: function watchModel() {
      var _this = this;

      var filesystem = this;
      [this.main.model.submission.extraFiles, this.main.model.assignment.extraStartingFiles, this.main.model.assignment.extraInstructorFiles].forEach(function (fileArray) {
        return fileArray.subscribe(function (changes) {
          changes.forEach(function (change) {
            var modelFile = change.value;

            if (change.status === "added") {
              // Track new file
              var file = filesystem.newFile(modelFile.filename(), modelFile.contents(), modelFile.contents);
              filesystem.notifyWatches(file);
            } else if (change.status === "deleted") {
              // Delete file
              filesystem.deleteFileLocally_(modelFile.filename);
            }
          });
        }, _this, "arrayChange");
      });
    } // answer.py
    //   => subscribe to first element of submission.code)
    // !on_run.py, !on_change.py, !on_eval.py
    //   => subscribe to relevant assignment.<whatever>
    // ^starting_code.py
    //   => subscribe to first element of assignment.startingCode
    // ^whatever
    //   => subscribe to rest of the elements of assignment.startingCode
    // !whatever or ?whatever
    //   => subscribe to elements of assignment.extraFiles
    // Otherwise:
    //   => subscribe to rest of the elements of submission.code

    /**
     * New special files need to be registered here
     * @param file {BlockPyFile}
     * @private
     */

  }, {
    key: "observeFile_",
    value: function observeFile_(file) {
      if (file.filename === "answer.py") {
        file.handle = this.main.model.submission.code;
      } else if (file.filename === "!on_run.py") {
        file.handle = this.main.model.assignment.onRun;
      } else if (file.filename === "!on_change.py") {
        file.handle = this.main.model.assignment.onChange;
      } else if (file.filename === "!on_eval.py") {
        file.handle = this.main.model.assignment.onEval;
      } else if (file.filename === "!instructions.md") {
        file.handle = this.main.model.assignment.instructions;
      } else if (file.filename === "^starting_code.py") {
        file.handle = this.main.model.assignment.startingCode;
      } else if (file.filename === "?mock_urls.blockpy") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "?toolbox.blockpy") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!tags.blockpy") {
        file.handle = this.main.model.assignment.tags;
      } else if (file.filename === "!assignment_settings.blockpy") {
        file.handle = this.main.model.assignment.settings;
      } else if (file.filename === "!sample_submissions.blockpy") {
        file.handle = this.main.model.assignment.sampleSubmissions;
      } else if (file.filename === "$settings.blockpy") {
        file.handle = this.main.model.display;
      } else if (file.filename.startsWith("^")) {
        this.observeInArray_(file, this.main.model.assignment.extraStartingFiles);
      } else if (file.filename.startsWith("!") || file.filename.startsWith("?") || file.filename.startsWith("&")) {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else {
        this.observeInArray_(file, this.main.model.submission.extraFiles);
      }
    }
  }, {
    key: "observeInArray_",
    value: function observeInArray_(file, array) {
      file.owner = array;
      var codeBundle = file.owner();

      for (var i = 0; i < codeBundle.length; i++) {
        if (codeBundle[i].filename() === file.filename) {
          file.handle = codeBundle[i].contents;
        }
      }

      if (file.handle === null) {
        var newFile = makeModelFile(file.filename);
        file.handle = newFile.contents;
        array.push(newFile);
      }
    }
  }, {
    key: "mountFiles",
    value: function mountFiles() {
      this.newFile("answer.py");
      this.newFile("^starting_code.py");
      this.newFile("!on_run.py");
      this.newFile("!instructions.md");
      this.newFile("!assignment_settings.blockpy");
    }
  }, {
    key: "dismountExtraFiles",
    value: function dismountExtraFiles() {
      for (var name in this.files_) {
        if (this.files_.hasOwnProperty(name)) {
          if (UNDELETABLE_FILES.indexOf(name) === -1) {
            delete this.files_[name];
            delete this.watches_[name];
          }
        }
      } // submission.codeTODO: Shouldn't we notify the UI that the file was deleted?

    }
  }, {
    key: "newFile",
    value: function newFile(filename, contents, modelFile) {
      if (filename in this.files_) {
        // File already exists! Just update its handle
        var existingFile = this.files_[filename];

        if (modelFile === undefined) {
          this.observeFile_(existingFile);
        } else {
          existingFile.handle = modelFile;
        }

        existingFile.handle(contents || "");
        return existingFile;
      } else {
        // File does not exist
        var newFile = new BlockPyFile(this.main, filename);
        this.files_[filename] = newFile;

        if (modelFile === undefined) {
          this.observeFile_(newFile);
        } else {
          newFile.handle = modelFile;
        }

        if (contents !== undefined) {
          newFile.handle(contents);
        }

        return newFile;
      }
    }
  }, {
    key: "writeFile",
    value: function writeFile(filename, contents) {
      contents = contents || "";
      this.files_[filename].handle(contents);
    }
  }, {
    key: "readFile",
    value: function readFile(filename) {
      return this.files_[filename].handle();
    }
  }, {
    key: "getFile",
    value: function getFile(filename) {
      return this.files_[filename];
    }
    /**
     *
     * @param filename
     * @returns {boolean|object} The info about the file, or false if it could not be deleted
     */

  }, {
    key: "deleteFile",
    value: function deleteFile(filename) {
      if (DELETABLE_SIMPLE_FILES.indexOf(filename) !== -1) {
        var file = this.deleteFileLocally_(filename);
        file.handle(null);
        return true;
      } else if (this.files_[filename].owner === null) {
        return false;
      } else {
        // Triggers a callback to eventually call deleteFileLocally_
        var found = this.files_[filename].owner.remove(function (modelFile) {
          return modelFile.filename === filename;
        });
        return found || false;
      }
    }
  }, {
    key: "deleteFileLocally_",
    value: function deleteFileLocally_(filename) {
      var file = this.files_[filename];
      delete this.files_[filename];

      if (filename in this.watches_) {
        this.watches_[filename].forEach(function (callback) {
          return callback.deleted();
        });
      }

      return file;
    }
  }, {
    key: "notifyWatches",
    value: function notifyWatches(file) {
      if (file.filename in this.watches_) {
        this.watches_[file.filename].forEach(function (callback) {
          return callback.updated(file);
        });
      }
    }
  }, {
    key: "searchForFile",
    value: function searchForFile(name, studentSearch) {
      /*
      TODO: This is called quite a bit by the Import mechanism, might need
            to optimize it some more. Do timing tests.
       files.*
      _instructor/files.*
      _student/files.*
       If a student searches for a file, it checks the "?", "&", "*", "" namespaces
          import helper => "./helper.py"
          open("external.json") => "external.json"
      If an instructor searches for a file, it checks "!", "^", "?", "&", "*", "" namespaces
          To explicitly search instructor namespaces first
              import _instructor.helper => "./instructor/helper.py"
              open("_instructor/external.json") => "_instructor/external.json"
          to allow student files to override:
              import helper => "./helper.py"
              open("external.json") => "external.json"
          to only check student files, prepend with _student
       */
      // Chop off starting "./"
      if (name.startsWith("./")) {
        name = name.slice(2);
      }

      var searchMode = SearchModes.EVERYWHERE; // Should the search be start with instructor side?

      if (name.startsWith(INSTRUCTOR_DIRECTORY)) {
        name = name.slice(INSTRUCTOR_DIRECTORY.length);
        searchMode = SearchModes.START_WITH_INSTRUCTOR;
      } // Should the search be limited to the student mode?


      if (name.startsWith(STUDENT_DIRECTORY)) {
        name = name.slice(STUDENT_DIRECTORY.length);
        searchMode = SearchModes.ONLY_STUDENT_FILES;
      } else if (studentSearch) {
        searchMode = SearchModes.ONLY_STUDENT_FILES;
      } // Shortcut for instructor versions


      var extraStudentFiles = this.main.model.submission.extraFiles();
      var extraInstructorFiles = this.main.model.assignment.extraInstructorFiles();
      var extraStartingFiles = this.main.model.assignment.extraStartingFiles(); // Check special files (TODO: how would an instructor access "./_instructor/answer.py"?

      var specialFile = this.searchForSpecialFiles_(name, searchMode);

      if (specialFile !== undefined) {
        return specialFile;
      } // Start looking through possible files


      var studentVersion = this.searchForFileInList_(extraStudentFiles, name);
      var generatedVersion = this.searchForFileInList_(extraStudentFiles, "*" + name);
      var defaultVersion = this.searchForFileInList_(extraInstructorFiles, "&" + name);

      if (searchMode === SearchModes.ONLY_STUDENT_FILES) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(defaultVersion, studentVersion, generatedVersion);
      }

      var instructorVersion = this.searchForFileInList_(extraInstructorFiles, "!" + name);
      var hiddenVersion = this.searchForFileInList_(extraInstructorFiles, "?" + name);
      var startingVersion = this.searchForFileInList_(extraStartingFiles, "^" + name);

      if (searchMode === SearchModes.START_WITH_INSTRUCTOR) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(instructorVersion, hiddenVersion, startingVersion, defaultVersion, studentVersion, generatedVersion);
      } else if (searchMode === SearchModes.EVERYWHERE) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(defaultVersion, studentVersion, generatedVersion, instructorVersion, hiddenVersion, startingVersion);
      }
    }
  }, {
    key: "searchForFileInList_",
    value: function searchForFileInList_(modelList, filename) {
      for (var i = 0; i < modelList.length; i++) {
        if (modelList[i].filename() === filename) {
          return modelList[i];
        }
      }

      return undefined;
    }
  }, {
    key: "searchForSpecialFiles_",
    value: function searchForSpecialFiles_(filename, searchMode) {
      if (searchMode === SearchModes.ONLY_STUDENT_FILES) {
        if (filename === "answer.py") {
          return makeMockModelFile("_instructor/answer.py", this.main.model.submission.code());
        }

        return undefined;
      }

      switch (filename) {
        case "answer.py":
          return makeMockModelFile("_instructor/answer.py", this.main.model.submission.code());

        case "on_run.py":
          return makeMockModelFile("_instructor/on_run.py", this.main.model.assignment.onRun());

        case "on_change.py":
          return makeMockModelFile("_instructor/on_change.py", this.main.model.assignment.onChange());

        case "on_eval.py":
          return makeMockModelFile("_instructor/on_eval.md", this.main.model.assignment.onEval());

        case "instructions.md":
          return makeMockModelFile("_instructor/instructions.md", this.main.model.assignment.instructions());

        case "starting_code.py":
          return makeMockModelFile("_instructor/starting_code.py", this.main.model.assignment.startingCode());
      }

      return undefined;
    }
  }, {
    key: "newFileDialog",
    value: function newFileDialog(kind) {
      var _this2 = this;

      var body = $(NEW_INSTRUCTOR_FILE_DIALOG_HTML);
      var filename = body.find(".blockpy-instructor-file-dialog-filename");
      var filetype = body.find(".blockpy-instructor-file-dialog-filetype");
      var namespace = body.find(".blockpy-instructor-file-dialog-namespace");
      var extensionRegex = /(?:\.([^.]+))?$/;
      filename.on("input", function () {
        var extension = extensionRegex.exec(filename.val())[1];
        extension = extension === undefined ? "No extension" : extension; //TODO: this.main.components.editors.getEditorFromExtension(extension);

        filetype.text(extension);
      });

      var yes = function yes() {
        var prefix = "";

        if (kind === "instructor") {
          prefix = namespace.val();
        } else if (kind === "starting") {
          prefix = "^";
        }

        if (filename.val()) {
          filename = prefix + filename.val();

          _this2.newFile(filename);
        }
      };

      body.submit(function (e) {
        e.preventDefault();
        yes();

        _this2.main.components.dialog.close();
      });
      this.main.components.dialog.confirm("Make New File", body, yes, function () {}, "Add");
    }
  }]);

  return BlockPyFileSystem;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout"), __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/footer.js":
/*!***********************!*\
  !*** ./src/footer.js ***!
  \***********************/
/*! exports provided: FOOTER_HTML */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FOOTER_HTML", function() { return FOOTER_HTML; });
//TODO: Move get link down to footer, remove vertical bar from quick-menu
var FOOTER_HTML = "\n<div class=\"col-md-12 blockpy-panel blockpy-status\">\n    <div>\n        <label class=\"badge\" data-bind=\"class: ui.server.status('loadAssignment')\">Load Assignment\n            <!-- ko if: display.instructor -->\n            <input type=\"file\"\n            class=\"blockpy-force-load-assignment-file blockpy-hidden-file\"\n            accept=\"application/JSON\"\n            data-bind=\"event: {change: ui.server.force.loadAssignment}\">\n            <!-- /ko -->\n        </label>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('saveAssignment')\">Save Assignment</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('loadFile')\">Load File</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('saveFile')\">Save File</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('loadDataset')\">Load Dataset</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('logEvent')\">Log Event</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('updateSubmission'),\n                                        click: ui.server.force.updateSubmission\">Update Submission</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('onExecution')\">Execution</span>\n    </div>\n    <div\n        <span data-bind=\"text: ui.server.messages\"></span>\n    </div>\n    <div>\n        <span>User: <span data-bind=\"text: user.id\"></span> (<span data-bind=\"text: user.name\"></span>, <span data-bind=\"text: user.role\"></span>)</span>, \n        <span>Course: <span data-bind=\"text: user.courseId\"></span></span>,\n        <span>Group: <span data-bind=\"text: user.groupId\"></span></span>,\n        <span>Assignment: <span data-bind=\"text: assignment.id\"></span></span>,\n        <span>Assignment Version: <span data-bind=\"text: assignment.version\"></span></span>,\n        <span>Submission: \n            <span data-bind=\"text: submission.id\"></span>\n            <span data-bind=\"if: submission.ownerId() != user.id()\">\n                (Owner ID: <span data-bind=\"text: submission.ownerId()\"></span>)\n            </span>\n        </span>, \n        <span>Submission Version: <span data-bind=\"text: submission.version\"></span></span>,\n        <span>Editor Version: <span data-bind=\"text: display.editorVersion\"></span></span>\n    </div>\n</div>\n";

/***/ }),

/***/ "./src/history.js":
/*!************************!*\
  !*** ./src/history.js ***!
  \************************/
/*! exports provided: HISTORY_TOOLBAR_HTML, BlockPyHistory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HISTORY_TOOLBAR_HTML", function() { return HISTORY_TOOLBAR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyHistory", function() { return BlockPyHistory; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// TODO: Should disable buttons if we can't activate them.
var HISTORY_TOOLBAR_HTML = "\n<div class=\"blockpy-history-toolbar col-md-12\" data-bind=\"visible: display.historyMode\">\n\n    <form class=\"form-inline\">\n        <button class=\"blockpy-history-start btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.start\">\n            <span class='fas fa-step-backward'></span> Start\n        </button>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.previous\">\n            <span class='fas fa-backward'></span> Previous\n        </button>\n        <select class=\"blockpy-history-selector form-control custom-select mr-2\" aria-title=\"History Selector\">\n        </select>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.use\">\n            <span class='fas fa-file-import'></span> Use\n        </button>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.next\">\n            <span class='fas fa-forward'></span> Next\n        </button>\n        <button class=\"btn btn-outline-secondary\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.mostRecent\">\n            <span class='fas fa-step-forward'></span> Most Recent\n        </button>\n    </form>\n</div>\n";
/**
 * An object for displaying the user's coding logs (their history).
 * A lightweight component, its only job is to open a dialog.
 *
 * @constructor
 * @this {BlockPyHistory}
 * @param {Object} main - The main BlockPy instance
 */

var BlockPyHistory = /*#__PURE__*/function () {
  function BlockPyHistory(main, tag) {
    _classCallCheck(this, BlockPyHistory);

    this.main = main;
    this.tag = tag;
    this.currentId = null;
    this.history = [];
    this.editEvents = [];
  }

  _createClass(BlockPyHistory, [{
    key: "load",
    value: function load(history) {
      var _this = this;

      this.history = history;
      this.editEvents = [];
      this.selector = $(".blockpy-history-selector").empty();
      var editId = 0;
      history.filter(function (entry) {
        return !entry.file_path.startsWith("_instructor.") && entry.event_type !== "Compile" && entry.event_type !== "Intervention" && (!_this.main.model.assignment.hidden() || entry.event_type !== "X-Submission.LMS");
      }).forEach(function (entry, index) {
        var event_type = REMAP_EVENT_TYPES[entry.event_type] || entry.event_type;
        var displayed = prettyPrintDateTime(entry.client_timestamp) + " - " + event_type;
        var disable = entry.event_type !== "File.Edit";
        var option = $("<option></option>", {
          text: displayed,
          disabled: disable
        });

        if (_this.isEditEvent(entry)) {
          option.attr("value", editId);

          _this.editEvents.push(entry);

          editId += 1;
        }

        _this.selector.append(option);
      });
      this.selector.val(Math.max(0, editId - 1));
      this.selector.change(function (evt) {
        _this.updateEditor();
      });
    }
  }, {
    key: "moveToStart",
    value: function moveToStart() {
      this.selector.val(0);
      this.updateEditor();
    }
  }, {
    key: "movePrevious",
    value: function movePrevious() {
      var currentId = parseInt(this.selector.val(), 10);
      this.selector.val(Math.max(0, currentId - 1));
      this.updateEditor();
    }
  }, {
    key: "moveNext",
    value: function moveNext() {
      var currentId = parseInt(this.selector.val(), 10);
      this.selector.val(Math.min(this.editEvents.length - 1, currentId + 1));
      this.updateEditor();
    }
  }, {
    key: "moveToMostRecent",
    value: function moveToMostRecent() {
      this.selector.val(this.editEvents.length - 1);
      this.updateEditor();
    }
  }, {
    key: "updateEditor",
    value: function updateEditor() {
      if (this.editEvents.length) {
        var currentId = parseInt(this.selector.val(), 10);
        this.main.components.pythonEditor.bm.setCode(this.editEvents[currentId].message);
      }
    }
  }, {
    key: "use",
    value: function use() {
      if (this.editEvents.length) {
        var currentId = parseInt(this.selector.val(), 10);
        var code = this.editEvents[currentId].message;
        this.main.model.ui.editors.python.turnOffHistoryMode();
        this.main.components.pythonEditor.file.handle(code);
      }
    }
  }, {
    key: "isEditEvent",
    value: function isEditEvent(entry) {
      return (entry.event_type === "File.Edit" || entry.event_type === "File.Create") && this.main.model.display.filename() === entry.file_path;
    }
  }]);

  return BlockPyHistory;
}();
var REMAP_EVENT_TYPES = {
  "Session.Start": "Began session",
  "X-IP.Change": "Changed IP address",
  "File.Edit": "Edited code",
  "File.Create": "Started assignment",
  "Run.Program": "Ran program",
  "Compile.Error": "Syntax error",
  "X-Submission.LMS": "Updated grade"
};
var monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec"];
var weekDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

function isSameDay(first, second) {
  return first.getDate() === second.getDate() && first.getMonth() === second.getMonth() && first.getFullYear() === second.getFullYear();
}
/**
 * Helper function to parse a date/time string and rewrite it as something
 * more human readable.
 * @param {String} timeString - the string representation of time ("YYYYMMDD HHMMSS")
 * @returns {String} - A human-readable time string.
 */


function prettyPrintDateTime(timeString) {
  /*let year = timeString.slice(0, 4),
      month = parseInt(timeString.slice(4, 6), 10)-1,
      day = timeString.slice(6, 8),
      hour = timeString.slice(9, 11),
      minutes = timeString.slice(11, 13),
      seconds = timeString.slice(13, 15);*/
  // TODO: Handle timezones correctly
  if (timeString === undefined) {
    return "Undefined Time";
  }

  var now = new Date();
  var past = new Date(parseInt(timeString, 10));

  if (isSameDay(now, past)) {
    return "Today at " + past.toLocaleTimeString();
  } else {
    var dayStr = weekDays[past.getDay()];
    var monthStr = monthNames[past.getMonth()];
    var date = dayStr + ", " + monthStr + " " + past.getDate();

    if (now.getFullYear() === past.getFullYear()) {
      return date + " at " + past.toLocaleTimeString();
    } else {
      return date + ", " + past.getFullYear() + " at " + past.toLocaleTimeString();
    }
  }
}
/**
 * Opens the history dialog box. This requires a trip to the server and
 * occurs asynchronously. The users' code is shown in preformatted text
 * tags (no code highlighting currently) along with the timestamp.
 */


BlockPyHistory.prototype.openDialog = function () {
  var dialog = this.main.components.dialog;
  var body = "<pre>a = 0</pre>";
  this.main.components.server.getHistory(function (data) {
    body = data.reverse().reduce(function (complete, elem) {
      var complete_str = prettyPrintDateTime(elem.time);
      var new_line = "<b>" + complete_str + "</b><br><pre>" + elem.code + "</pre>";
      return complete + "\n" + new_line;
    }, "");
    dialog.show("Work History", body, function () {});
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/interface.js":
/*!**************************!*\
  !*** ./src/interface.js ***!
  \**************************/
/*! exports provided: SecondRowSecondPanelOptions, makeExtraInterfaceSubscriptions, makeInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SecondRowSecondPanelOptions", function() { return SecondRowSecondPanelOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeExtraInterfaceSubscriptions", function() { return makeExtraInterfaceSubscriptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeInterface", function() { return makeInterface; });
/* harmony import */ var trace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trace.js */ "./src/trace.js");
/* harmony import */ var dialog_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dialog.js */ "./src/dialog.js");
/* harmony import */ var feedback_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! feedback.js */ "./src/feedback.js");
/* harmony import */ var files_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! files.js */ "./src/files.js");
/* harmony import */ var footer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! footer.js */ "./src/footer.js");
/* harmony import */ var editors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! editors.js */ "./src/editors.js");
/* harmony import */ var console_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! console.js */ "./src/console.js");
/**
 * @fileoverview Contains main HTML of BlockPy interface, and helper functions.
 * Combines a lot of HTML from components.
 *
 * Here's the layout:
 *  Row 1: Header and Quick Menu
 *  Row 2: Console and Feedback
 *  Row 3: File Navigation
 *  Row 4: View Row
 *  Row 5: Footer Row
 */







/**
 * The different layout options of the panes in the second row of the layout.
 * @enum {String}
 */

var SecondRowSecondPanelOptions = {
  FEEDBACK: "feedback",
  TRACE: "trace",
  NONE: "none"
};
/**
 * Setup any additional Knockout subscriptions to fire on interface changes.
 * @param self
 * @param model
 */

function makeExtraInterfaceSubscriptions(self, model) {
  // Highlight Markdown when instructions update
  var highlightTimeout = null;
  model.ui.instructions.current.subscribe(function () {
    if (highlightTimeout !== null) {
      clearTimeout(highlightTimeout);
    }

    highlightTimeout = setTimeout(function () {
      model.configuration.container.find(".blockpy-instructions pre code").map(function (i, block) {
        window.hljs.highlightBlock(block);
      });
    }, 400);
  }); // Provide Fullscreen support

  model.display.fullscreen.subscribe(function (isFullscreen) {
    self.components.server.logEvent("X-Display.Fullscreen.Request", "", "", isFullscreen.toString(), "");

    if (isFullscreen) {
      // NOTE: navigationUI could allow us to force controls to show
      model.configuration.container.parent()[0].requestFullscreen()["catch"](function (err) {
        var message = "Error attempting to enable full-screen mode: ".concat(err.message, " (").concat(err.name, ")");
        self.components.server.logEvent("X-Display.Fullscreen.Error", "", "", message, "");
        alert(message);
      }).then(function () {
        self.components.server.logEvent("X-Display.Fullscreen.Success", "", "", "", "");
        model.display.fullscreen(true);
        model.configuration.container.css("overflow-y", "auto");
      });
    } else {
      document.exitFullscreen().then(function () {
        self.components.server.logEvent("X-Display.Fullscreen.Exit", "", "", isFullscreen.toString(), "");
        model.display.fullscreen(false);
      });
    }
  });
} // TODO: Get shareable link button

function makeInterface(main) {
  return "\n<div class='blockpy-content container-fluid'>\n\n    <!-- Dialog -->\n    ".concat(dialog_js__WEBPACK_IMPORTED_MODULE_1__["DIALOG_HTML"], "\n    \n    <!-- Hidden Capture Canvas -->\n    <canvas id='capture-canvas' class='d-none' role=\"presentation\" aria-hidden=\"true\"></canvas>\n    \n    <!-- Row 1: Header and Quick Menu -->\n    <div class='row'>\n         \n         <!-- Description -->\n         <div class='col-md-10 blockpy-panel blockpy-header'\n               role='heading' aria-label='Assignment Description'>\n         \n            <!-- Assignment Name -->\n            <span role='heading' aria-level='1'\n                  class=\"blockpy-name\">\n                <strong>BlockPy: </strong> \n                <span data-bind='text: assignment.name'></span>\n            </span>\n            \n            <!-- Reset Instructions Button -->\n            <div class=\"blockpy-instructions-reset\"\n                data-bind=\"visible: ui.instructions.isChanged\">\n                <a class=\"float-right\"\n                    data-bind=\"click: ui.instructions.reset\"\n                    href=\"\">\n                    Reset instructions</a>\n            </div>\n            \n            <!-- Instructions -->\n            <div class='blockpy-instructions'\n                 data-bind=\"html: ui.instructions.current\">\n            </div>\n        </div>\n        \n        <div class='col-md-2 blockpy-panel blockpy-quick-menu'\n             role='menubar' aria-label='Quick Menu' title=\"Quick Menu\">\n            <!-- Get Shareable Link -->\n            <!--<button class=\"btn btn-outline-secondary btn-sm\">\n                Get shareable link</button>-->\n            <span data-bind=\"visible: ui.menu.isSubmitted\">\n                Your submission is ready to be reviewed!</span>\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"visible: ui.menu.canMarkSubmitted,\n                           text: ui.menu.textMarkSubmitted,\n                           click: ui.menu.clickMarkSubmitted\"></button>\n            <!-- View as instructor -->\n            <div class=\"form-check\"\n                 data-bind=\"visible: ui.role.isGrader\">\n                <input class=\"form-check-input\" type=\"checkbox\" value=\"\" id=\"blockpy-as-instructor\"\n                    data-bind=\"checked: display.instructor\">\n                <label class=\"form-check-label\" for=\"blockpy-as-instructor\">\n                    View as instructor\n                </label>\n            </div>\n            <!-- Readonly mode for spying -->\n            <div data-bind=\"if: submission.ownerId() != user.id()\">\n                Owner: <span data-bind=\"text: submission.ownerId\"></span>\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" value=\"blockpy-read-only\"\n                        data-bind=\"checked: display.readOnly\">\n                    <label class=\"form-check-label\" for=\"blockpy-read-only\">\n                        Readonly?\n                    </label>\n                </div>\n            </div>\n            \n            \n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"click: ui.menu.clickFullscreen\"\n                title=\"Full Screen\"\n            ><span class='fas',\n                           data-bind=\"class: ui.menu.textFullscreen\"\n            ></span></button>\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"click: ui.menu.editInputs, visible: ui.menu.showQueuedInputs\" title=\"Edit Inputs\"\n            ><span class='fas fa-list-alt'></span></button>\n            <span class=\"blockpy-student-error fas fa-bug\"></span>\n        </div>\n         \n    </div>\n    \n    <!-- Row 2: Console and Feedback -->\n    <!-- ko if: ui.secondRow.isAllVisible -->\n    <div class='row'>\n    \n        <!-- Console -->\n        ").concat(console_js__WEBPACK_IMPORTED_MODULE_6__["CONSOLE_HTML"], "\n         \n        <!-- Feedback -->\n        <!-- ko if: ui.secondRow.isFeedbackVisible -->\n        ").concat(feedback_js__WEBPACK_IMPORTED_MODULE_2__["FEEDBACK_HTML"], "\n        <!-- /ko -->\n        \n        <!-- Trace -->\n        <!-- ko if: ui.secondRow.isTraceVisible -->\n        ").concat(trace_js__WEBPACK_IMPORTED_MODULE_0__["TRACE_HTML"], "\n        <!-- /ko -->\n         \n    </div>\n    <!-- /ko -->\n    \n    <!-- Row 3: File Navigation -->\n    <!-- ko if: ui.files.visible -->\n    <div class='row'>\n        ").concat(files_js__WEBPACK_IMPORTED_MODULE_3__["FILES_HTML"], "\n    </div>\n    <!-- /ko -->\n    \n    <!-- Row 4: View Row -->\n    <div class=\"row\">\n        ").concat(editors_js__WEBPACK_IMPORTED_MODULE_5__["EDITORS_HTML"], "\n    </div>\n\n    <!-- Row 5: Footer Row -->    \n    <div class=\"row\">\n        ").concat(footer_js__WEBPACK_IMPORTED_MODULE_4__["FOOTER_HTML"], "\n    </div>\n    \n</div>\n    ");
}

/***/ }),

/***/ "./src/server.js":
/*!***********************!*\
  !*** ./src/server.js ***!
  \***********************/
/*! exports provided: StatusState, BlockPyServer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StatusState", function() { return StatusState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyServer", function() { return BlockPyServer; });
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage */ "./src/storage.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");


/**
 *
 * @enum {string}
 */

var StatusState = {
  READY: "ready",
  ACTIVE: "active",
  RETRYING: "retrying",
  FAILED: "failed",
  OFFLINE: "offline"
};
/**
 * Object for communicating with the external servers. This includes functionality for
 * saving and loading files, logging events, saving completions, and retrieving history.
 *
 * @constructor
 * @this {BlockPyServer}
 * @param {Object} main - The main BlockPy instance
 */

function BlockPyServer(main) {
  this.main = main; // Save URLs locally for quicker access

  this.urls = main.model.configuration.urls; // Add the LocalStorage connection

  this.storage = new _storage__WEBPACK_IMPORTED_MODULE_0__["LocalStorageWrapper"]("BLOCKPY"); // FaultResistantCache

  this.queue = {
    "logEvent": JSON.parse(this.storage.getDefault("logEvent", "[]")),
    "updateSubmission": JSON.parse(this.storage.getDefault("updateSubmission", "[]"))
  };
  this.MAX_QUEUE_SIZE = {
    "logEvent": 200,
    "updateSubmission": 50
  };
  this.TIMER_DELAY = 1000;
  this.FAIL_DELAY = 2000;
  this.timers = {};
  this.overlay = null;
  this.blockingAttempts = 0;
  this.cachedFilenames = [];
  this.createSubscriptions();
  this.checkCaches();
}
/**
 * Checks whether the IP address has changed, logging an event if that occurs.
 * @param response
 */

BlockPyServer.prototype.checkIP = function (response) {
  if (response.success) {
    if (this.storage.has("IP")) {
      var oldIP = this.storage.get("IP");

      if (oldIP !== response.ip) {
        var message = JSON.stringify({
          "old": oldIP,
          "new": response.ip
        });
        this.logEvent("X-IP.Change", undefined, undefined, message);
        this.storage.set("IP", response.ip);
      }
    } else {
      this.storage.set("IP", response.ip);
    }
  }
};
/**
 * Determines if there have been previous failures cached, and if so retries them.
 * TODO: update
 */


BlockPyServer.prototype.checkCaches = function () {
  var _this = this;

  if (this.storage.has("saveAssignment")) {
    var data = JSON.parse(this.storage.get("saveAssignment"));

    this._postLatestRetry(data, "assignment", "saveAssignment", this.TIMER_DELAY);
  }

  this.cachedFilenames.forEach(function (filename) {
    if (_this.storage.has("saveFile" + filename)) {
      var _data = JSON.parse(_this.storage.get("saveFile" + filename));

      _this._postLatestRetry(_data, filename, "saveFile", _this.TIMER_DELAY);
    }
  });
  var server = this;
  Object.keys(this.queue).forEach(function (endpoint) {
    (function pushAnyQueued(response) {
      if (response.success) {
        if (server.queue[endpoint].length) {
          var data = JSON.parse(server.queue[endpoint].pop());
          var url = server.urls[endpoint];

          server._postRetry(data, endpoint, 1000, pushAnyQueued);
        }
      }
    })({
      "success": true
    });
  });
};

BlockPyServer.prototype.createFileSubscription = function (model, filename) {
  var _this2 = this;

  model.subscribe(function (contents) {
    return _this2.main.model.display.autoSave() ? _this2.saveFile(filename, contents) : false;
  }, this);
  this.cachedFilenames.push(filename);
};
/**
 * TODO: fix
 */


BlockPyServer.prototype.createSubscriptions = function () {
  var model = this.main.model;
  this.createFileSubscription(model.submission.code, "answer.py");
  this.createFileSubscription(model.assignment.onRun, "!on_run.py");
  this.createFileSubscription(model.assignment.onEval, "!on_eval.py");
  this.createFileSubscription(model.assignment.onChange, "!on_change.py");
  this.createFileSubscription(model.assignment.instructions, "!instructions.md");
  this.createFileSubscription(model.assignment.startingCode, "^starting_code.py");
  this.createFileSubscription(model.ui.files.extraStudentFiles, "#extra_student_files.blockpy");
  this.createFileSubscription(model.ui.files.extraStartingFiles, "#extra_starting_files.blockpy");
  this.createFileSubscription(model.ui.files.extraInstructorFiles, "#extra_instructor_files.blockpy");
};

BlockPyServer.prototype.createEventLogs = function () {
  var _this3 = this;

  window.onblur = function () {
    _this3.logEvent("Session.End", undefined, undefined, undefined);
  };

  window.onfocus = function () {
    _this3.logEvent("Session.Start", undefined, undefined, undefined);
  }; // TODO: Add in beacon?

};
/**
 *
 * Some subscriptions have to happen after other things have been loaded.
 * Right now this is just after CORGIS libraries have been loaded, but maybe
 * we'll add more later and this will need to be refactored.
 *
 * TODO: fix
 *
 */


BlockPyServer.prototype.finalizeSubscriptions = function () {//this.main.model.assignment.settings.datasets.subscribe(this.saveAssignment.bind(this));
};
/**
 * Creates the default payload for any communication with the server API
 * @returns {{assignment_id: *, course_id: *, group_id: *, user_id: *, timezone: *, version: *, timestamp: *}}
 */


BlockPyServer.prototype.createServerData = function () {
  var assignment = this.main.model.assignment;
  var user = this.main.model.user;
  var submission = this.main.model.submission;
  var display = this.main.model.display;
  var now = new Date();
  var microseconds = now.getTime();
  return {
    "assignment_id": assignment.id(),
    "assignment_group_id": user.groupId(),
    "course_id": user.courseId(),
    "submission_id": submission.id(),
    "user_id": user.id(),
    "version": assignment.version(),
    "timestamp": microseconds,
    "timezone": now.getTimezoneOffset(),
    "passcode": display.passcode()
  };
};
/**
 * Updates the status and message for the relevant endpoint.
 * @param endpoint {string} one of the URL endpoints
 * @param status {StatusState}
 * @param message {string?}
 */


BlockPyServer.prototype.setStatus = function (endpoint, status, message) {
  this.main.model.status[endpoint](status);
  this.main.model.status[endpoint + "Message"](message || "");
};
/**
 * Renders an overlay on the screen that blocks operation until the system is ready.
 * The overlay gets progressively darker to indicate repeated failures.
 */


BlockPyServer.prototype.showOverlay = function (attempt) {
  this.blockingAttempts += 1;

  if (!document.getElementsByClassName("blockpy-overlay").length) {
    this.overlay = $('<div class="blockpy-overlay"> </div>');
    this.overlay.appendTo(document.body);
  }

  switch (attempt) {
    case 0:
      this.overlay.css("background-color", "#988");
      break;

    case 1:
      this.overlay.css("background-color", "#655");
      break;

    case 2:
      this.overlay.css("background-color", "#333");
      break;

    default:
      this.overlay.css("background-color", "black");
      break;
  }
};
/**
 * Undo a level of overlay; if this was the last level, removes it from the screen.
 */


BlockPyServer.prototype.hideOverlay = function () {
  this.blockingAttempts -= 1;

  if (this.blockingAttempts <= 0) {
    this.overlay.remove();
  }
};

BlockPyServer.prototype._enqueueData = function (cache, data) {
  // Ensure we have not overfilled the queue
  var length = this.queue[cache].length;
  var max = this.MAX_QUEUE_SIZE[cache];

  if (length > max) {
    this.queue[cache] = this.queue[cache].slice(length - max, max);
  } // Only add the element if it's new


  var key = JSON.stringify(data);
  var index = this.queue[cache].indexOf(key);

  if (index === -1) {
    this.queue[cache].push(key);
    this.storage.set(cache, JSON.stringify(this.queue[cache]));
  }
};

BlockPyServer.prototype._dequeueData = function (cache, data) {
  var key = JSON.stringify(data);
  var index = this.queue[cache].indexOf(key);

  if (index >= 0) {
    this.queue[cache].splice(index);
    this.storage.set(cache, JSON.stringify(this.queue[cache]));
  }
};

BlockPyServer.prototype._postRetry = function (data, endpoint, delay, callback) {
  var _this4 = this;

  // Trigger request
  var postRequest = function postRequest() {
    // Make a backup of the current post
    _this4._enqueueData(endpoint, data);

    $.post(_this4.urls[endpoint], data).done(function (response) {
      _this4._dequeueData(endpoint, data);

      if (response.success) {
        _this4.setStatus(endpoint, StatusState.READY);
      } else {
        console.error(response);

        _this4.setStatus(endpoint, StatusState.FAILED, response.message);
      }

      if (callback) {
        callback(response);
      }

      if (response.success) {
        _this4.checkIP(response.ip);
      }
    }) // If server request is the latest one, then let's try it again in a bit
    .fail(function (error, textStatus) {
      _this4.setStatus(endpoint, StatusState.RETRYING, textStatus.toString());

      _this4._postRetry(data, endpoint, delay + _this4.FAIL_DELAY, callback);
    });
  };

  if (delay === null) {
    postRequest();
  } else {
    setTimeout(postRequest, delay);
  }
};
/**
 * Make a AJAX request that, upon failure, will check to see if this was the
 * latest attempt for this `cache` marker. If so, it will attempt again until
 * successful; otherwise, it gives up the request.
 *
 * @param {Object} data - The AJAX-ready data to be posted
 * @param {String} filename - The unique name given to the relevant timer
 * @param {String} endpoint - The unique name given to the relevant cache entry
 * @param {Integer} delay - The current number of milliseconds to wait before
 trying the request again.
 */


BlockPyServer.prototype._postLatestRetry = function (data, filename, endpoint, delay) {
  var _this5 = this;

  var cache = endpoint + filename;

  var request = function request() {
    // Make a backup of the current post
    _this5.storage.set(cache, JSON.stringify(data));

    var time = _this5.storage.getTime(cache); // Send the request


    $.post(_this5.urls[endpoint], data).done(function (response) {
      if (response.success) {
        _this5.checkIP(response); // If server request is the latest one, clear it from the cache


        var cachedTime = _this5.storage.getTime(cache);

        if (time >= cachedTime) {
          _this5.storage.remove(cache);
        }

        _this5.setStatus(endpoint, StatusState.READY);
      } else {
        // This connected but failed, don't try again but let the user know why.
        _this5.setStatus(endpoint, StatusState.FAILED, response.message);

        if (response.success === false) {
          // If we're the latest one, clear it from the cache
          var _cachedTime = _this5.storage.getTime(cache);

          if (time >= _cachedTime) {
            _this5.storage.remove(cache);
          }
        }
      }
    }).fail(function (error, textStatus) {
      _this5.setStatus(endpoint, StatusState.RETRYING, textStatus.toString()); // If server request is the latest one, then let's try it again in a bit


      var cachedTime = _this5.storage.getTime(cache);

      if (time >= cachedTime) {
        _this5._postLatestRetry(data, filename, endpoint, delay + _this5.FAIL_DELAY);
      }
    });
  };

  clearTimeout(this.timers[cache]);

  if (delay === null) {
    request();
  } else {
    this.timers[cache] = setTimeout(request, delay);
  }
};

BlockPyServer.prototype._postBlocking = function (endpoint, data, attempts, success, failure) {
  var _this6 = this;

  this.showOverlay(attempts);
  $.post(this.urls[endpoint], data).done(function (response) {
    _this6.hideOverlay();

    _this6.setStatus(endpoint, StatusState.READY);

    success(response);

    _this6.checkIP(response);
  }).fail(function (e, textStatus, errorThrown) {
    if (attempts <= 0) {
      _this6.hideOverlay();

      _this6.setStatus(endpoint, StatusState.FAILED, textStatus.toString());

      if (failure) {
        failure(e, textStatus, errorThrown);
      }
    } else {
      setTimeout(function () {
        _this6.hideOverlay();

        _this6.setStatus(endpoint, StatusState.RETRYING, textStatus.toString());

        _this6._postBlocking(endpoint, data, attempts - 1, success, failure);
      }, _this6.FAIL_DELAY);
    }
  });
};

BlockPyServer.prototype.loadAssignment = function (assignment_id) {
  var _this7 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("loadAssignment")) {
    var data = this.createServerData();
    data["assignment_id"] = assignment_id;

    this._postBlocking("loadAssignment", data, 4, function (response) {
      if (response.success) {
        _this7.main.loadAssignmentData_(response);
      } else {
        _this7.setStatus("loadAssignment", StatusState.FAILED, response.message);

        _this7.main.components.dialog.ERROR_LOADING_ASSIGNMNENT(response.message);
      }
    }, function (e, textStatus, errorThrown) {
      _this7.main.components.dialog.ERROR_LOADING_ASSIGNMNENT(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  } else {
    this.setStatus("loadAssignment", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.saveAssignment = function () {
  var _this8 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("saveAssignment")) {
    var data = this.createServerData();
    data["hidden"] = model.assignment.hidden();
    data["reviewed"] = model.assignment.reviewed();
    data["public"] = model.assignment["public"]();
    data["url"] = model.assignment.url();
    data["ip_ranges"] = model.assignment.ipRanges();
    data["name"] = model.assignment.name();
    data["settings"] = Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_1__["saveAssignmentSettings"])(model);

    this._postBlocking("saveAssignment", data, 3, function () {
      return 0;
    }, function (e, textStatus, errorThrown) {
      _this8.main.components.dialog.ERROR_SAVING_ASSIGNMNENT();

      console.error(e, textStatus, errorThrown);
    });
  } else {
    this.setStatus("saveAssignment", StatusState.OFFLINE, "Server is not connected! (Save Assignment)");
  }
};

BlockPyServer.prototype.loadHistory = function (callback) {
  var _this9 = this;

  if (this.main.model.ui.server.isEndpointConnected("loadHistory")) {
    var model = this.main.model;
    var data = this.createServerData();

    this._postBlocking("loadHistory", data, 2, callback, function (e, textStatus, errorThrown) {
      _this9.main.components.dialog.ERROR_LOADING_HISTORY();

      console.error(e, textStatus, errorThrown);
    });
  }
};

BlockPyServer.prototype.logEvent = function (event_type, category, label, message, file_path) {
  if (this.main.model.display.readOnly()) {
    this.setStatus("logEvent", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("logEvent")) {
    var data = this.createServerData();
    data["event_type"] = event_type;
    data["category"] = category;
    data["label"] = label;
    data["message"] = message;
    data["file_path"] = file_path;
    this.setStatus("logEvent", StatusState.ACTIVE); // Trigger request

    this._postRetry(data, "logEvent", 0, function () {});
  } else {
    this.setStatus("logEvent", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.saveImage = function (directory, image) {
  if (this.main.model.display.readOnly()) {
    this.setStatus("saveImage", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("saveImage")) {
    var data = this.createServerData();
    data["directory"] = directory;
    data["image"] = image;
    this.setStatus("saveImage", StatusState.ACTIVE); // Trigger request

    this._postLatestRetry(data, "turtle_output", "saveImage", 0);
  } else {
    this.setStatus("saveImage", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.updateSubmissionStatus = function (newStatus) {
  var _this10 = this;

  if (this.main.model.display.readOnly()) {
    this.setStatus("updateSubmissionStatus", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("updateSubmissionStatus")) {
    var data = this.createServerData();
    data["status"] = newStatus;

    var postStatusChange = function postStatusChange(data) {
      if (data.success) {
        _this10.main.model.submission.submissionStatus(newStatus);
      }
    };

    this._postBlocking("updateSubmissionStatus", data, 2, postStatusChange, function (e, textStatus, errorThrown) {
      _this10.main.components.dialog.ERROR_UPDATING_SUBMISSION_STATUS();

      console.error(e, textStatus, errorThrown);
    });
  }
};
/**
 * This function can be used to load files and web resources.
 *
 * DEPRECATED
 */


BlockPyServer.prototype.loadFile = function (filename, type, callback, errorCallback) {
  var model = this.main.model;
  var server = this;

  if (model.ui.server.isEndpointConnected("load_file")) {
    var data = this.createServerData();
    data["filename"] = filename;
    data["type"] = type;

    this._postBlocking(this.urls.load_file, data, 5, function (response) {
      if (response.success) {
        callback(response.data);
      } else {
        errorCallback(response.message);
        server.setStatus("loadFile", StatusState.FAILED, response.message);
      }
    }, function (e, textStatus, errorThrown) {
      errorCallback("Server failure! Report to instructor");
      console.error(errorThrown);
    });
  } else {
    errorCallback("No file server available.");
    this.setStatus("loadFile", StatusState.OFFLINE, "Server is not connected! (Load File)");
  }
};

BlockPyServer.prototype.saveFile = function (filename, contents, delay) {
  if (delay === undefined) {
    delay = this.TIMER_DELAY;
  }

  var model = this.main.model;

  if (model.display.readOnly()) {
    this.setStatus("saveFile", StatusState.OFFLINE);
    return;
  }

  if (model.ui.server.isEndpointConnected("saveFile")) {
    var data = this.createServerData();
    data["filename"] = filename;
    data["code"] = contents;
    this.setStatus("saveFile", StatusState.ACTIVE);

    this._postLatestRetry(data, filename, "saveFile", delay);
  } else {
    this.setStatus("saveFile", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.updateSubmission = function (score, correct, hiddenOverride, forceUpdate) {
  var _this11 = this;

  if (this.main.model.display.readOnly()) {
    this.setStatus("updateSubmission", StatusState.OFFLINE);
    return;
  }

  var callback = this.main.model.configuration.callbacks.success;

  if (this.main.model.ui.server.isEndpointConnected("updateSubmission")) {
    var data = this.createServerData();
    data["score"] = score;
    data["correct"] = correct;
    data["hidden_override"] = hiddenOverride;
    data["force_update"] = forceUpdate;
    this.main.components.pythonEditor.bm.blockEditor.getPngFromBlocks(function (pngData, img) {
      data["image"] = pngData;

      if (img.remove) {
        img.remove();
      }

      _this11._postRetry(data, "updateSubmission", 0, function (response) {
        if (response.success) {
          _this11.setStatus("updateSubmission", StatusState.READY);
        } else {
          _this11.setStatus("updateSubmission", StatusState.FAILED, response.message);
        }

        if (!hiddenOverride && correct && callback) {
          callback(data["assignment_id"]);
        }
      });
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/skulpt_modules/coverage.js":
/*!****************************************!*\
  !*** ./src/skulpt_modules/coverage.js ***!
  \****************************************/
/*! exports provided: $sk_mod_coverage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$sk_mod_coverage", function() { return $sk_mod_coverage; });
var $sk_mod_coverage = "\n\"\"\"\nHideous fill-in replacement for Coverage, leveraging some magic from the\nUtility function. The data this returns is false - it doesn't actually\ndescribe the missing lines and all lines; it just describes the traced lines.\nBut since Pedal doesn't need the other two, it works out fine when you do:\n\nstatements - missing\n\"\"\"\n\nimport utility\n\nclass Coverage:\n    def start(self):\n        pass\n\n    def stop(self):\n        pass\n\n    def save(self):\n        pass\n\n    def _analyze(self, filename: str):\n        lines = set(utility.trace_lines())\n        # lines will be the lines that were actually executed\n        return Analysis(None, len(lines), None, set(), lines)\n\n\nclass Numbers:\n    def __init__(self, n_missing, n_statements, pc_covered):\n        self.n_missing = n_missing\n        self.n_statements = n_statements\n        self.pc_covered = pc_covered\n\n\nclass Analysis:\n    def __init__(self, n_missing, n_statements, pc_covered, missing, statements):\n        self.missing = missing\n        self.statements = statements\n        self.numbers = Numbers(n_missing, n_statements, pc_covered)\n\n\nclass python:\n    def get_python_source(self):\n        return None\n";

/***/ }),

/***/ "./src/skulpt_modules/image.js":
/*!*************************************!*\
  !*** ./src/skulpt_modules/image.js ***!
  \*************************************/
/*! exports provided: $builtinmodule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$builtinmodule", function() { return $builtinmodule; });
var $builtinmodule = function $builtinmodule(name) {
  var mod, sampleWrapper;
  mod = {
    __name__: "image"
  };

  if (!Sk.PIL) {
    Sk.PIL = {
      assets: {}
    };
  } // InstantPromise is a workaround to allow usage of the clean promise-style
  // then/catch syntax but to instantly call resolve the then/catch chain so we
  // can avoid creating Suspensions in unnecessary cases.  This is desirable
  // because Suspensions have a fairly large negative impact on overall
  // performance.  These 'instant promises' come into play when a tracer()
  // call is made with a value other than 1.  When tracer is 0 or greater than 1
  // , we can bypass the creation of a Suspension and proceed to the next line of
  // code immediately if the current line is not going to involve a screen
  // update. We determine if a real promise or InstantPromise is necessary by
  // checking FrameManager.willRenderNext()


  function InstantPromise(err, result) {
    this.lastResult = result;
    this.lastError = err;
  }

  InstantPromise.prototype.then = function (cb) {
    if (this.lastError) {
      return this;
    }

    try {
      this.lastResult = cb(this.lastResult);
    } catch (e) {
      this.lastResult = undefined;
      this.lastError = e;
    }

    return this.lastResult instanceof Promise ? this.lastResult : this;
  };

  InstantPromise.prototype["catch"] = function (cb) {
    if (this.lastError) {
      try {
        this.lastResult = cb(this.lastError);
        this.lastError = undefined;
      } catch (e) {
        this.lastResult = undefined;
        this.lastError = e;
      }
    }

    return this.lastResult instanceof Promise ? this.lastResult : this;
  };

  var buildImage = function buildImage(imageData) {};

  function getAsset(name) {
    return new Promise(function (resolve, reject) {
      if (Sk.PIL.assets[name] !== undefined) {
        //return Sk.PIL.assets[name];
        resolve(Sk.PIL.assets[name]);
      } else {
        var img = new Image();
        img.crossOrigin = "Anonymous";

        img.onload = function () {
          Sk.PIL.assets[name] = img;
          resolve(img);
        };

        img.onerror = function () {
          //throw new Error("Failed to load asset: " + name);
          reject(name);
        };

        img.src = name;
      }
    });
  }

  var image = function image($gbl, $loc) {
    // open(filename) or open(url)
    // show()
    $loc.__init__ = new Sk.builtin.func(function (self, file_or_url) {
      Sk.builtin.pyCheckArgs("__init__", arguments, 2, 2);
      Sk.builtin.pyCheckType("file_or_url", "string", Sk.builtin.checkString(file_or_url));
      self.file_or_url = file_or_url; // TODO: Change to suspension

      var imagePromise = getAsset(Sk.ffi.remapToJs(file_or_url));
      var susp = new Sk.misceval.Suspension();
      self.image = Sk.builtin.none.none$;

      susp.resume = function () {
        if (susp.data["error"]) {
          //throw new Sk.builtin.IOError(susp.data["error"].message);
          throw susp.data["error"];
        } else {//return self.image;
        }
      };

      susp.data = {
        type: "Sk.promise",
        promise: imagePromise.then(function (value) {
          self.image = value;
          self.canvas = document.createElement("canvas");
          self.canvas.width = self.image.width;
          self.canvas.height = self.image.height;
          self.canvas.getContext("2d").drawImage(self.image, 0, 0, self.image.width, self.image.height);
          self.pixels = self.canvas.getContext("2d").getImageData(0, 0, self.image.width, self.image.height).data; //return value;
        }, function (err) {
          self.image = "";
          throw err; //return err;
        })
      };
      return susp;
    });
    $loc.show = new Sk.builtin.func(function (self) {
      if (Sk.console === undefined) {
        throw new Sk.builtin.NameError("Can not resolve drawing area. Sk.console is undefined!");
      }

      var consoleData = {
        image: self.image,
        file_or_url: self.file_or_url
      };
      Sk.console.printPILImage(consoleData);
    });
    $loc.flip = new Sk.builtin.func(function (self) {
      self.image.style.transform = "scaleX(-1)";

      if (Sk.console === undefined) {
        throw new Sk.builtin.NameError("Can not resolve drawing area. Sk.console is undefined!");
      }

      return self;
    });
  };

  mod.Image = Sk.misceval.buildClass(mod, image, "Image", []);
  return mod;
};

/***/ }),

/***/ "./src/skulpt_modules/pedal_tracer.js":
/*!********************************************!*\
  !*** ./src/skulpt_modules/pedal_tracer.js ***!
  \********************************************/
/*! exports provided: $pedal_tracer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$pedal_tracer", function() { return $pedal_tracer; });
var $pedal_tracer = "\n\n\"\"\"\nWraps the tracer module in Pedal\n\"\"\"\n\nimport os\nimport utility\n        \nclass SandboxBasicTracer:\n    \"\"\"\n\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self.filename = \"student.py\"\n        self.code = None\n\n    def as_filename(self, filename, code):\n        if os.path.isabs(filename):\n            self.filename = filename\n        else:\n            self.filename = os.path.abspath(filename)\n        self.code = code\n        return self\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        pass\n\nclass SandboxNativeTracer(SandboxBasicTracer):\n    \"\"\"\n    Tracks lines covered and function calls. Possibly other things? We could track variables, if that\n    was something people wanted.\n\n    TODO: Handle multiple submission files?\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self.calls = utility.trace_calls()\n        self.lines = utility.trace_lines()\n        self.step_index = len(utility.trace_lines())\n\nTRACER_STYLES = {\n    'none': SandboxBasicTracer,\n    'native': SandboxNativeTracer\n}\n\n";

/***/ }),

/***/ "./src/skulpt_modules/sk_mod_instructor.js":
/*!*************************************************!*\
  !*** ./src/skulpt_modules/sk_mod_instructor.js ***!
  \*************************************************/
/*! exports provided: $sk_mod_instructor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$sk_mod_instructor", function() { return $sk_mod_instructor; });
/**
 * Skulpt Module for holding the Instructor API.
 *
 * This module is loaded in by getting the functions' source code from toString.
 * Isn't that crazy?
 *
 *
 */
var $sk_mod_instructor = function $sk_mod_instructor() {
  // Main module object that gets returned at the end.
  var mod = {};
  var none = Sk.builtin.none.none$;
  var prior = null;
  mod.timeit = new Sk.builtin.func(function (name) {
    Sk.builtin.pyCheckArgs("timeit", arguments, 1, 1);
    var difference;

    if (prior === null) {
      difference = 0;
    } else {
      difference = Date.now() - prior;
    }

    console.log(Sk.ffi.remapToJs(name), difference / 1000);
    prior = Date.now();
  });
  /**
   * Logs feedback to javascript console
   */

  mod.console_log = new Sk.builtin.func(function () {
    console.log(Array.prototype.slice.call(arguments).map(Sk.ffi.remapToJs));
  });
  /**
   * Logs debug to javascript console
   */

  mod.console_debug = new Sk.builtin.func(function () {
    console.log(arguments);
  });
  /**
   * This function coverts the output in the student report to a python 
   * list and returns it.
  **/

  mod.get_output = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_output", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      var output = Sk.executionReports["student"]["output"]();
      output = output.map(function (item) {
        return item.toSkulpt();
      });
      return new Sk.builtin.list(output);
    } else {
      return new Sk.builtin.list([]);
    }
  });
  /**
   * This function resets the output, particularly useful if the student
   * code is going to be rerun.
   */

  mod.reset_output = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("reset_output", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      Sk.executionReports["student"].output.removeAll();
    }

    return Sk.builtin.none.none$;
  });
  /*mod.queue_input = new Sk.builtin.func(function() {
      Sk.builtin.pyCheckArgs("queue_input", arguments, 1, Infinity);
      let args = arguments;
      for (let i = args.length-1; i >= 0; i--) {
          let input = args[i];
          Sk.builtin.pyCheckType("input", "string", Sk.builtin.checkString(input));
          Sk.queuedInput.push(Sk.ffi.remapToJs(input));
      }
  });*/

  /**
   * This function is called by instructors to get the students' code as a string.
  **/

  mod.get_program = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_program", arguments, 0, 0);
    return Sk.ffi.remapToPy(Sk.executionReports["verifier"].code);
  });
  /**
   * This function is called by instructors to get the students' code as a string.
  **/

  mod.get_evaluation = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_evaluation", arguments, 0, 0);
    return Sk.ffi.remapToPy(Sk.executionReports["student"].evaluation || "");
  });
  mod.trace_lines = new Sk.builtin.func(function () {
    if (Sk.executionReports["student"].success) {
      var lines = Sk.executionReports["student"].realLines;
      return Sk.ffi.remapToPy(lines);
    } else {
      return new Sk.builtin.list([]);
    }
  });
  mod.trace_calls = new Sk.builtin.func(function () {
    console.log("--", Sk.executionReports["student"]);

    if (Sk.executionReports["student"].success) {
      var calls = Sk.executionReports["student"].calls;
      return Sk.ffi.remapToPy(calls);
    }

    return new Sk.builtin.dict([]);
  });
  /**
   *
   */

  mod.get_student_error = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_error", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      return new Sk.builtin.tuple([none, none]);
    } else {
      var error = Sk.executionReports["student"].error,
          position = {};

      if (error && error.traceback && error.traceback.length > 0) {
        position["line"] = error.traceback[0].lineno;
      } else {
        error = none;
      }

      position = Sk.ffi.remapToPy(position);
      return new Sk.builtin.tuple([error, position]);
    }
  });
  mod.had_execution_time_error = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("had_execution_time_error", arguments, 0, 0);
    return !Sk.executionReports["student"].success && Sk.executionReports["student"].error && Sk.executionReports["student"].error.tp$name === "TimeLimitError";
  });
  var backupTime = undefined;
  mod.limit_execution_time = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("limit_execution_time", arguments, 0, 0);
    backupTime = Sk.execLimit;

    if (Sk.execLimitFunction) {
      Sk.execLimit = Sk.execLimitFunction();
      Sk.execStart = Date.now();
    }
  });
  mod.unlimit_execution_time = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("unlimit_execution_time", arguments, 0, 0);
    Sk.execLimit = backupTime;
    Sk.execStart = Date.now();
  });
  mod.suppress_scrolling = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("suppress_scrolling", arguments, 0, 0);
    Sk.executionReports.instructor.scrolling = true;
  });
  /*
  def hist(self, data, **kwargs):
      label = kwargs.get('label', None)
      self.active_plot['data'].append({'type': 'Histogram', 'values': data, 'label': label})
  def plot(self, xs, ys=None, **kwargs):
      label = kwargs.get('label', None)
      if ys == None:
          self.active_plot['data'].append({'type': 'Line', 
                                          'x': range(len(xs)), 'y': xs, 'label': label})
      else:
          self.active_plot['data'].append({'type': 'Line', 'x': xs, 'y': ys, 'label': label})
  def scatter(self, xs, ys, **kwargs):
      label = kwargs.get('label', None)
      self.active_plot['data'].append({'type': 'Scatter', 'x': xs, 'y': ys, 'label': label})
  */

  mod.get_plots = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_plots", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      var outputs = Sk.executionReports["student"]["output"]();
      outputs = outputs.filter(function (output) {
        return output.type === "plot";
      }).map(function (graph) {
        return {
          "data": graph.content.map(function (plot) {
            var newPlot = {
              "type": plot.type,
              "label": ""
            };

            if (plot.type === "line" || plot.type === "scatter") {
              newPlot["x"] = plot.data.map(function (v) {
                return v.x;
              });
              newPlot["y"] = plot.data.map(function (v) {
                return v.y;
              });
            } else if (plot.type === "hist") {
              newPlot["values"] = plot.data;
            }

            return newPlot;
          }),
          "xlabel": "",
          "ylabel": "",
          "title": "",
          "legend": false
        };
      });
      return Sk.ffi.remapToPy(outputs);
    } else {
      return Sk.ffi.remapToPy([]);
    }
  }); // Provides `student` as an object with all the data that the student declared.

  mod.StudentData = Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self) {
      //self.data = Sk.builtin.dict();
      var newDict = new Sk.builtin.dict();
      Sk.abstr.sattr(self, new Sk.builtin.str("data"), newDict, true);
      self.module = Sk.executionReports["student"].results;

      if (self.module !== undefined) {
        self.module = self.module.$d;

        for (var key in self.module) {
          if (self.module.hasOwnProperty(key)) {
            Sk.abstr.objectSetItem(newDict, Sk.ffi.remapToPy(Sk.unfixReserved(key)), self.module[key]);
          }
        }
      } else {
        self.module = {};
      }

      return Sk.builtin.none.none$;
    });

    var call_f = function call_f(kwa) {
      Sk.builtin.pyCheckArgsLen("call", arguments.length, 1, Infinity, true, true);
      var args = Array.prototype.slice.call(arguments, 1);
      var kwargs = new Sk.builtins.dict(kwa);
      var self = args[0];
      var functionName = args[1];
      args = args.slice(2);
      var inputs = kwargs.mp$lookup(new Sk.builtin.str("inputs"));

      if (inputs !== undefined) {
        inputs = Sk.ffi.remapToJs(inputs);

        if (inputs.constructor === Array) {
          inputs.forEach(function (item) {
            Sk.queuedInput.push(item);
          });
        } else {
          Sk.queuedInput.push(input);
        }
      }

      var data = self.tp$getattr(new Sk.builtin.str("data"));
      var functionObject = data.mp$lookup(functionName);
      var result = functionObject.tp$call(args);
      return result;
    };

    call_f.co_kwargs = true; //call_f.co_varnames = ["self", "function"];

    call_f.co_name = new Sk.builtin.str("call");
    $loc["call_$rn$"] = new Sk.builtin.func(call_f);
    $loc["__repr__"] = new Sk.builtin.func(function (self) {
      return new Sk.builtin.str("");
    });
    $loc.get_names_by_type = new Sk.builtin.func(function (self, type, exclude_builtins) {
      Sk.builtin.pyCheckArgs("get_names_by_type", arguments, 2, 3);

      if (exclude_builtins === undefined) {
        exclude_builtins = true;
      } else {
        Sk.builtin.pyCheckType("exclude_builtins", "boolean", Sk.builtin.checkBool(exclude_builtins));
        exclude_builtins = Sk.ffi.remapToJs(exclude_builtins);
      }

      var result = [];

      for (var property in self.module) {
        if (self.module.hasOwnProperty(property)) {
          if (self.module[property].tp$name === type.tp$name) {
            //console.log(exclude_builtins);
            if (exclude_builtins && property.startsWith("__")) {
              continue;
            }

            result.push(Sk.ffi.remapToPy(Sk.unfixReserved(property)));
          }
        }
      }

      return new Sk.builtin.list(result);
    });
    $loc.get_values_by_type = new Sk.builtin.func(function (self, type, exclude_builtins) {
      Sk.builtin.pyCheckArgs("get_values_by_type", arguments, 2, 3);

      if (exclude_builtins === undefined) {
        exclude_builtins = true;
      } else {
        Sk.builtin.pyCheckType("exclude_builtins", "boolean", Sk.builtin.checkBool(exclude_builtins));
        exclude_builtins = Sk.ffi.remapToJs(exclude_builtins);
      }

      var result = [];

      for (var property in self.module) {
        if (self.module.hasOwnProperty(property)) {
          if (self.module[property].tp$name === type.tp$name) {
            if (exclude_builtins && property.startsWith("__")) {
              continue;
            }

            result.push(self.module[property]);
          }
        }
      }

      return new Sk.builtin.list(result);
    });
  }, "StudentData");
  mod.student = Sk.misceval.callsimOrSuspend(mod.StudentData);
  mod.get_student_data = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_data", arguments, 0, 0);
    return mod.student;
  });
  mod.set_instructions = new Sk.builtin.func(function (newInstructions) {
    Sk.builtin.pyCheckArgs("set_instructions", arguments, 1, 2);
    newInstructions = Sk.ffi.remapToJs(newInstructions);
    Sk.executionReports["model"].display.changedInstructions(newInstructions);
  });
  mod.get_model_info = new Sk.builtin.func(function (keys) {
    Sk.builtin.pyCheckArgs("get_model_info", arguments, 1, 1);
    var model = Sk.executionReports["model"];
    keys = Sk.ffi.remapToJs(keys).split(".");

    for (var i = 0; i < keys.length; i++) {
      model = model[keys[i]];
    }

    return Sk.ffi.remapToPy(model());
  });
  return mod;
};

/***/ }),

/***/ "./src/storage.js":
/*!************************!*\
  !*** ./src/storage.js ***!
  \************************/
/*! exports provided: LocalStorageWrapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocalStorageWrapper", function() { return LocalStorageWrapper; });
var LOCAL_STORAGE_REF;

try {
  LOCAL_STORAGE_REF = localStorage;
  var mod = "BLOCKPY_LOCALSTORAGE_TEST";
  LOCAL_STORAGE_REF.setItem(mod, mod);
  LOCAL_STORAGE_REF.removeItem(mod);
} catch (e) {
  LOCAL_STORAGE_REF = {
    _data: {},
    setItem: function setItem(id, val) {
      return this._data[id] = String(val);
    },
    getItem: function getItem(id) {
      return this._data.hasOwnProperty(id) ? this._data[id] : null;
    },
    removeItem: function removeItem(id) {
      return delete this._data[id];
    },
    clear: function clear() {
      return this._data = {};
    }
  };
}
/**
 * Helper object for interfacing with the LocalStorage. The LocalStorage
 * browser API allows for offline storage. That API is very unsophisticated,
 * and is essentially a lame key-value store. This object sits on top
 * and provides a number of useful utilities, including rudimentarycache
 * cache expiration.
 *
 * @constructor
 * @this {LocalStorageWrapper}
 * @param {String} namespace - A namespace to use in grouping access to localstorage. This keeps access clean and organized, while also making it possible to have multiple LocalStorage connections.
 */


function LocalStorageWrapper(namespace) {
  this.namespace = namespace;
}
/**
 * A method for adding a key/value pair to LocalStorage.
 * Note that both parameters must be strings (JSON.stringify is your friend).
 *
 * @param {String} key - The name of the key.
 * @param {String} value - The value.
 */

LocalStorageWrapper.prototype.set = function (key, value) {
  LOCAL_STORAGE_REF.setItem(this.namespace + "_" + key + "_value", value);
  LOCAL_STORAGE_REF.setItem(this.namespace + "_" + key + "_timestamp", $.now());
};
/**
 * A method for removing a key from LocalStorage.
 *
 * @param {String} key - The name of the key to remove.
 */


LocalStorageWrapper.prototype.remove = function (key) {
  LOCAL_STORAGE_REF.removeItem(this.namespace + "_" + key + "_value");
  LOCAL_STORAGE_REF.removeItem(this.namespace + "_" + key + "_timestamp");
};
/**
 * A method for retrieving the value associated with the given key.
 *
 * @param {String} key - The name of the key to retrieve the value for.
 */


LocalStorageWrapper.prototype.get = function (key) {
  return LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_value");
};
/**
 * A method for retrieving the time associated with the given key.
 *
 * @param {String} key - The name of the key to retrieve the time for.
 * @returns {Integer} - The timestamp (local epoch) when the key was last set.
 */


LocalStorageWrapper.prototype.getTime = function (key) {
  return parseInt(LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_timestamp"));
};
/**
 * A method for retrieving the value associated with the given key.
 * If the key does not exist, then the default value is used instead.
 * This default will be set.
 *
 * @param {String} key - The name of the key to retrieve the value for.
 * @param {String} defaultValue - The default value to use. Must be a string.
 */


LocalStorageWrapper.prototype.getDefault = function (key, defaultValue) {
  if (this.has(key)) {
    return this.get(key);
  } else {
    this.set(key, defaultValue);
    return defaultValue;
  }
};
/**
 * A test for whether the given key is in LocalStorage.
 *
 * @param {String} key - The key to test existence for.
 */


LocalStorageWrapper.prototype.has = function (key) {
  return LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_value") !== null;
};
/**
 * A test for whether the server has the newer version. This function
 * assumes that the server trip takes about 5 seconds. This method
 * is largely deprecated.
 *
 * @param {String} key - The key to check.
 * @param {Integer} server_time - The server's time as an epoch (in milliseconds)
 */


LocalStorageWrapper.prototype.is_new = function (key, server_time) {
  var stored_time = LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_timestamp");
  return server_time >= stored_time + 5000;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/trace.js":
/*!**********************!*\
  !*** ./src/trace.js ***!
  \**********************/
/*! exports provided: TRACE_HTML, BlockPyTrace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRACE_HTML", function() { return TRACE_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyTrace", function() { return BlockPyTrace; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TRACE_HTML = "\n\n<div class=\"blockpy-trace col-md-6 blockpy-panel\"\n            role=\"region\" aria-label=\"Trace\">\n    \n    <div class=\"clearfix\">\n        <strong>Trace: </strong>\n        \n        <!-- Feedback/Trace Visibility Control -->\n        <button type='button'\n                class='btn btn-sm btn-outline-secondary float-right blockpy-hide-trace'\n                data-bind=\"click: ui.secondRow.advanceState\">\n            <span class='fas fa-eye'></span> Hide Trace\n        </button>\n    </div>\n\n    <div class=\"input-group mb-3 blockpy-trace-controls\">\n        <div class=\"input-group-prepend\">\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.first\">\n                <span class='fas fa-step-backward'></span>\n            </button>\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.backward\">\n                <span class='fas fa-backward'></span>\n            </button>\n            <span class=\"input-group-text\">Step:</span>\n            <span class=\"input-group-text\">\n                <span data-bind='text: execution.student.currentTraceStep'></span>\n                / <span data-bind='text: execution.student.lastStep'></span>\n            </span>\n        </div>\n        <div class=\"input-group-append\">\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.forward\">\n                <span class='fas fa-forward'></span>\n            </button>\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.last\">\n                <span class='fas fa-step-forward'></span>\n            </button>\n            <span class=\"input-group-text\">\n                <span data-bind='text: ui.trace.line'></span>\n            </span>\n        </div>\n    </div>\n    \n    <table class='table table-sm table-striped table-bordered table-hover'>\n        <caption>Current variables at this step</caption>\n        <thead>\n            <tr><th>Name</th><th>Type</th><th>Value</th></tr>\n        </thead>\n        <tbody data-bind=\"foreach: ui.trace.data().properties\">\n            <tr data-bind=\"visible: name != '__file__' && name != '__path__'\">\n                <td data-bind=\"text: name\"></td>\n                <td data-bind=\"text: type\"></td>\n                <td>\n                    <code data-bind=\"text: value\"></code>\n                    <!-- ko if: type == \"List\" -->\n                    \n                    <a href=\"\" data-bind=\"click: //$root.viewExactValue(type, exact_value)\">\n                    <span class='glyphicon glyphicon-new-window'></span>\n                    </a>\n                    <!-- /ko -->\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    \n</div>\n";
var BlockPyTrace = /*#__PURE__*/function () {
  function BlockPyTrace(main, tag) {
    _classCallCheck(this, BlockPyTrace);

    this.main = main;
    this.tag = tag;
    this.IGNORED_GLOBALS = ["__name__", "__doc__", "__package__", "classmethod", "property", "staticmethod"]; // this.trace.click(this.buildTraceTable.bind(this));
  }
  /**
   * Consume a set of variables traced from the execution and parse out any
   * global variables and modules.
   *
   * @param {Object} variables - a mapping of variable names to their Skupt value.
   */


  _createClass(BlockPyTrace, [{
    key: "parseGlobals",
    value: function parseGlobals(variables) {
      var result = [];
      var modules = [];

      if (!this.main.model.display.traceExecution()) {
        for (var property in variables) {
          var value = variables[property];

          if (this.IGNORED_GLOBALS.indexOf(property) === -1) {
            property = property.replace("_$rw$", "").replace("_$rn$", "");
            var parsed = void 0;

            try {
              parsed = BlockPyTrace.parseValue(property, value);
            } catch (_unused) {
              parsed = {
                "name": property,
                "type": "Unknown",
                "value": value.toString()
              };
            }

            if (parsed !== null) {
              result.push(parsed);
            } else if (value.constructor === Sk.builtin.module) {
              modules.push(value.$d.__name__.v);
            }
          }
        }
      }

      return {
        "properties": result,
        "modules": modules
      };
    }
  }], [{
    key: "parseValue",

    /**
     * Convert a Skulpt value into a more easily printable object.
     *
     * @param {String} property
     * @param {Object} value - the skulpt value
     */
    value: function parseValue(property, value, fullLength) {
      if (value === undefined) {
        return {
          "name": property,
          "type": "Unknown",
          "value": "Undefined"
        };
      }

      switch (value.constructor) {
        case Sk.builtin.func:
          return {
            "name": property,
            "type": "Function",
            "value": value.func_code.co_varnames !== undefined ? " Arguments: " + value.func_code.co_varnames.join(", ") : " No arguments"
          };

        case Sk.builtin.module:
          return null;

        case Sk.builtin.str:
          if (fullLength || value.v.length <= 32) {
            return {
              "name": property,
              "type": "String",
              "value": value.$r().v
            };
          } else {
            return {
              "name": property,
              "type": "String",
              "value": "[" + value.sq$length() + " characters not shown]"
            };
          }

        case Sk.builtin.none:
          return {
            "name": property,
            "type": "None",
            "value": "None"
          };

        case Sk.builtin.bool:
          return {
            "name": property,
            "type": "Boolean",
            "value": value.$r().v
          };

        case Sk.builtin.nmber:
          return {
            "name": property,
            "type": "int" === value.skType ? "Integer" : "Float",
            "value": value.$r().v
          };

        case Sk.builtin.int_:
          return {
            "name": property,
            "type": "Integer",
            "value": value.$r().v
          };

        case Sk.builtin.float_:
          return {
            "name": property,
            "type": "Float",
            "value": value.$r().v
          };

        case Sk.builtin.tuple:
          return {
            "name": property,
            "type": "Tuple",
            "value": value.$r().v
          };

        case Sk.builtin.list:
          if (value.v.length <= 20) {
            return {
              "name": property,
              "type": "List",
              "value": value.$r().v,
              "exact_value": value
            };
          } else {
            return {
              "name": property,
              "type": "List",
              "value": "[... " + value.v.length + " elements ...]",
              "exact_value": value
            };
          }

        case Sk.builtin.dict:
          return {
            "name": property,
            "type": "Dictionary",
            "value": value.$r().v
          };

        case Number:
          return {
            "name": property,
            "type": value % 1 === 0 ? "Integer" : "Float",
            "value": value
          };

        case String:
          return {
            "name": property,
            "type": "String",
            "value": value
          };

        case Boolean:
          return {
            "name": property,
            "type": "Boolean",
            "value": value ? "True" : "False"
          };

        default:
          return {
            "name": property,
            "type": value.tp$name === undefined ? value : value.tp$name,
            "value": value.$r === undefined ? value : value.$r().v
          };
      }
    }
  }]);

  return BlockPyTrace;
}(); // TODO: viewExactValue

/***/ }),

/***/ "./src/utilities.js":
/*!**************************!*\
  !*** ./src/utilities.js ***!
  \**************************/
/*! exports provided: indent, slug, capitalize, encodeHTML, firstDefinedValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indent", function() { return indent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slug", function() { return slug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalize", function() { return capitalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeHTML", function() { return encodeHTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "firstDefinedValue", function() { return firstDefinedValue; });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Determines if the element is in the list.
 * @param {anything} needle - The element to look for.
 * @param {Array} haystack - The list to search.
 * @return {Boolean} Whether the element exists
 */
function arrayContains(needle, haystack) {
  return haystack.indexOf(needle) > -1;
}
/**
 * Remove duplicate values from an array, preserving order.
 * Creates a new array, so is non-destructive.
 * Courtesy:
 * https://stackoverflow.com/questions/1584370/how-to-merge-two-arrays-in-javascript-and-de-duplicate-items
 *
 * @param {Array} array - The array to uniquify. Elements compared with ===.
 */


function arrayUnique(array) {
  var a = array.concat();

  for (var i = 0; i < a.length; ++i) {
    for (var j = i + 1; j < a.length; ++j) {
      if (a[i] === a[j]) {
        a.splice(j--, 1);
      }
    }
  }

  return a;
}
/**
 * A helper function for extending an array based
 * on an "addArray" and "removeArray". Any element
 * found in removeArray is removed from the first array
 * and all the elements of addArray are added.
 * Any duplicate items are removed.
 * Creates a new array, so is non-destructive.
 *
 * @param {Array} array - the array to manipulate
 * @param {Array} addArray - the elements to add to the array
 * @param {Array} removeArray - the elements to remove from the array
 * @return {Array} The modified array
 */


function expandArray(array, addArray, removeArray) {
  var copyArray = array.filter(function (item) {
    return removeArray.indexOf(item) === -1;
  });
  return arrayUnique(copyArray.concat(addArray));
}
/**
 * Deeply clones a node
 * @param {Node} node A node to clone
 * @return {Node} A clone of the given node and all its children
 */


function cloneNode(node) {
  // If the node is a text node, then re-create it rather than clone it
  var clone = node.nodeType == 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false); // Recurse     

  var child = node.firstChild;

  while (child) {
    clone.appendChild(cloneNode(child));
    child = child.nextSibling;
  }

  return clone;
}
/**
 * Indents the given string by 4 spaces. This correctly handles multi-line strings.
 *
 * @param {String} str - The string to be manipulated.
 * @returns {String} The string with four spaces added at the start of every new line.
 */


function indent(str) {
  return str.replace(/^(?=.)/gm, "    ");
}
/**
 * Turns spaces into underscores in the string, makes it lowercase.
 * @param {String} str - the string to be manipulated
 * @returns {string}
 */

function slug(str) {
  return str.replace(/\s/g, "_").toLowerCase();
}
/**
 * Capitalize the first letter of a string.
 * @param {String} s - The string to be capitalized.
 * @returns {string}
 */

function capitalize(s) {
  if (typeof s !== "string") {
    return "";
  }

  return s.charAt(0).toUpperCase() + s.slice(1);
}
/**
 * Return a random integer between [`min`, `max`].
 * 
 * @param {number} min - The lowest possible integer.
 * @param {number} max - The highest possible integer (inclusive).
 * @returns {number} A random integer.
 */

function randomInteger(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
/**
 * Encodes some text so that it can be safely written into an HTML box.
 * This includes replacing special HTML characters (&, <, >, etc.).
 *
 * @param {string} str - The text to be converted.
 * @return {string} The HTML-safe text.
 */


function encodeHTML(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
/**
 * Shuffle the blocks in the workspace
 */

if (typeof Blockly !== "undefined") {
  Blockly.WorkspaceSvg.prototype.shuffle = function () {
    var metrics = this.getMetrics();
    var width = metrics.viewWidth / 2,
        height = metrics.viewHeight;
    var blocks = this.getTopBlocks(false);
    var y = 5,
        x = 0,
        maximal_increase = height / blocks.length;

    for (var i = 0; i < blocks.length; i++) {
      // Get a block
      var block = blocks[i];
      var properties = block.getRelativeToSurfaceXY();

      if (i == 0) {
        x = 5;
      } else {
        x = -properties.x + randomInteger(10, width);
      }

      block.moveBy(x, -properties.y + y);
      y = y + randomInteger(5, maximal_increase);
    }
  };
}
/**
 * Move elements from one array to another based on a conditional check.
 * https://stackoverflow.com/questions/31887967/javascript-move-objects-from-one-array-to-another-best-approach
 */


function moveElements(source, target, moveCheck) {
  for (var i = 0; i < source.length; i++) {
    var element = source[i];

    if (moveCheck(element)) {
      source.splice(i, 1);
      target.push(element);
      i--;
    }
  }
}

function firstDefinedValue() {
  for (var i = 0; i < arguments.length; i++) {
    if (arguments[i] != null) {
      return arguments[i];
    }
  }

  return undefined;
}
/**
 * This function checks if the given object is one of the Sk.builtin objects
 * TODO: make this so we don't have to explicitly put out every option
 *          one possible thing we could do is get a string version of the 
 *          of the constructor and look for the substring "return new Sk.builtin"
 *          But I don't know how reliable that is.  Rather, it's kind of hackish.
 *          Should tehoretically belong in Sk.ffi
 * @param {object} obj - the object to be examined
 * @return {boolean} true if the object is one of the Sk.builtin types
**/

function isSkBuiltin(obj) {
  return obj instanceof Sk.builtin.dict || obj instanceof Sk.builtin.list || obj instanceof Sk.builtin.tuple || obj instanceof Sk.builtin.bool || obj instanceof Sk.builtin.int_ || obj instanceof Sk.builtin.float_ || obj instanceof Sk.builtin.str || obj instanceof Sk.builtin.lng; //var cons_str = obj.constructor + "";
  //return cons_str.indexOf("return new Sk.builtin") !== -1;
}

function isAstNode(obj) {
  return obj instanceof Object && "_astname" in obj;
}
/**
 * Should theoretically belong in Sk.ffi, but I put it here instead to not mess up the skulpt files
 * like the normal Sk.ffi.remapToPy, it doesn't work for functions or more complex objects, but it handles
 * cases where the types in obj are a mix of python SIMPLE objects and SIMPLE normal javascript objects
 * @param {object} obj - the object to be converted
 * @return {Sk.builtin.???} - returns the corresponding python object, dropping all functions and things it can't convert
**/


function mixedRemapToPy(obj) {
  var k;
  var kvs;
  var i;
  var arr; //@TODO: should theoretically check if the object is a pyhon dict or array with js objects

  if (isSkBuiltin(obj)) {
    //object is already python ready
    return obj;
  } else if (Object.prototype.toString.call(obj) === "[object Array]") {
    //object is actually a javascript array
    arr = [];

    for (i = 0; i < obj.length; ++i) {
      //for each object, convert it to a python object if it isn't one already
      var subval = obj[i];

      if (!isSkBuiltin(subval)) {
        arr.push(mixedRemapToPy(subval));
      } else {
        arr.push(subval);
      }
    }

    return new Sk.builtin.list(arr);
  } else if (obj === null) {
    //null object
    return Sk.builtin.none.none$;
  } else if (_typeof(obj) === "object") {
    if (!isSkBuiltin(obj)) {
      //assuming it's a standard dictionary
      kvs = []; //Sk.builtin.dict uses an array of key-value,key-value...

      for (k in obj) {
        //convert the key if it needs to be converted
        kvs.push(mixedRemapToPy(k)); //covert corresponding value if it needs to be converted

        kvs.push(mixedRemapToPy(obj[k]));
      } //create the new dictionary


      return new Sk.builtin.dict(kvs);
    } else {
      return obj;
    }
  } else if (typeof obj === "string") {
    return new Sk.builtin.str(obj);
  } else if (typeof obj === "number") {
    return Sk.builtin.assk$(obj);
  } else if (typeof obj === "boolean") {
    return new Sk.builtin.bool(obj);
  } else if (typeof obj === "function") {
    return new Sk.builtin.str(obj.name);
  }
}

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_jquery__;

/***/ }),

/***/ "knockout":
/*!*********************!*\
  !*** external "ko" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_knockout__;

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ibG9ja3B5L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9ibG9ja3B5L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvYmxvY2tweS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2NvbnNvbGUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jb3JnaXMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jc3MvYmxvY2tweS5jc3MiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jc3MvYm9vdHN0cmFwX3JldGhlbWUuY3NzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZGlhbG9nLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2Fic3RyYWN0X2VkaXRvci5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9hc3NpZ25tZW50X3NldHRpbmdzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2pzb24uanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lZGl0b3IvbWFya2Rvd24uanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lZGl0b3IvcHl0aG9uLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3NhbXBsZV9zdWJtaXNzaW9ucy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci90YWdzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3RleHQuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lZGl0b3IvdG9vbGJveC5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvcnMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvY29uZmlndXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvZXZhbC5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9pbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL29uX2NoYW5nZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9vbl9ldmFsLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL29uX3J1bi5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9vbl9zYW1wbGUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvcnVuLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL3NhbXBsZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9zdHVkZW50LmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZmVlZGJhY2suanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9maWxlcy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2Zvb3Rlci5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9za3VscHRfbW9kdWxlcy9jb3ZlcmFnZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL3NrdWxwdF9tb2R1bGVzL2ltYWdlLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc2t1bHB0X21vZHVsZXMvcGVkYWxfdHJhY2VyLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc2t1bHB0X21vZHVsZXMvc2tfbW9kX2luc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9zdG9yYWdlLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvdHJhY2UuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy91dGlsaXRpZXMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS9leHRlcm5hbCBcImpRdWVyeVwiIiwid2VicGFjazovL2Jsb2NrcHkvZXh0ZXJuYWwgXCJrb1wiIl0sIm5hbWVzIjpbIkVESVRPUl9WRVJTSU9OIiwiQmxvY2tQeSIsImNvbmZpZ3VyYXRpb24iLCJhc3NpZ25tZW50Iiwic3VibWlzc2lvbiIsImluaXRNb2RlbCIsInVuZGVmaW5lZCIsInNldEFzc2lnbm1lbnQiLCJpbml0TWFpbiIsImluaXRVdGlsaXRpZXMiLCJpbml0TW9kZWxNZXRob2RzIiwidHVybk9uSGFja3MiLCJpbml0SW50ZXJmYWNlIiwiYXBwbHlNb2RlbCIsImluaXRDb21wb25lbnRzIiwibWFrZUV4dHJhU3Vic2NyaXB0aW9ucyIsInN0YXJ0Iiwia2V5IiwiZGVmYXVsdFZhbHVlIiwiaW5pdGlhbENvbmZpZ3VyYXRpb25fIiwibG9jYWxTZXR0aW5nc18iLCJoYXMiLCJnZXQiLCJMb2NhbFN0b3JhZ2VXcmFwcGVyIiwibW9kZWwiLCJ1c2VyIiwiaWQiLCJrbyIsIm9ic2VydmFibGUiLCJuYW1lIiwicm9sZSIsImdldFNldHRpbmciLCJjb3Vyc2VJZCIsImdyb3VwSWQiLCJpbnN0cnVjdGlvbnMiLCJ1cmwiLCJ0eXBlIiwic3RhcnRpbmdDb2RlIiwib25SdW4iLCJvbkNoYW5nZSIsIm9uRXZhbCIsImV4dHJhSW5zdHJ1Y3RvckZpbGVzIiwib2JzZXJ2YWJsZUFycmF5IiwiZXh0cmFTdGFydGluZ0ZpbGVzIiwiZm9ya2VkSWQiLCJmb3JrZWRWZXJzaW9uIiwib3duZXJJZCIsInZlcnNpb24iLCJ0YWdzIiwic2FtcGxlU3VibWlzc2lvbnMiLCJyZXZpZXdlZCIsImhpZGRlbiIsImlwUmFuZ2VzIiwic2V0dGluZ3MiLCJtYWtlQXNzaWdubWVudFNldHRpbmdzTW9kZWwiLCJjb2RlIiwiZXh0cmFGaWxlcyIsImVuZHBvaW50Iiwic2NvcmUiLCJjb3JyZWN0Iiwic3VibWlzc2lvblN0YXR1cyIsImdyYWRpbmdTdGF0dXMiLCJkaXNwbGF5IiwiZmlsZW5hbWUiLCJpbnN0cnVjdG9yIiwibXV0ZVByaW50ZXIiLCJweXRob25Nb2RlIiwiRGlzcGxheU1vZGVzIiwiU1BMSVQiLCJoaXN0b3J5TW9kZSIsImF1dG9TYXZlIiwiYmlnQ29uc29sZSIsInByZXZpb3VzQ29uc29sZUhlaWdodCIsImN1cnJlbnRDb25zb2xlSGVpZ2h0Iiwic2Vjb25kUm93U2Vjb25kUGFuZWwiLCJTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMiLCJGRUVEQkFDSyIsInRyYWNlRXhlY3V0aW9uIiwibG9hZGluZ0RhdGFzZXRzIiwiY2hhbmdlZEluc3RydWN0aW9ucyIsInRyaWdnZXJPbkNoYW5nZSIsImRpcnR5U3VibWlzc2lvbiIsImZ1bGxzY3JlZW4iLCJwYXNzY29kZSIsImNsZWFySW5wdXRzIiwiZWRpdG9yVmVyc2lvbiIsInJlYWRPbmx5IiwidG9TdHJpbmciLCJzdGF0dXMiLCJsb2FkQXNzaWdubWVudCIsIlN0YXR1c1N0YXRlIiwiUkVBRFkiLCJsb2FkQXNzaWdubWVudE1lc3NhZ2UiLCJsb2FkSGlzdG9yeSIsImxvYWRIaXN0b3J5TWVzc2FnZSIsImxvYWRGaWxlIiwibG9hZEZpbGVNZXNzYWdlIiwibG9hZERhdGFzZXQiLCJsb2FkRGF0YXNldE1lc3NhZ2UiLCJsb2dFdmVudCIsImxvZ0V2ZW50TWVzc2FnZSIsInNhdmVJbWFnZSIsInNhdmVJbWFnZU1lc3NhZ2UiLCJzYXZlRmlsZSIsInNhdmVGaWxlTWVzc2FnZSIsInNhdmVBc3NpZ25tZW50Iiwic2F2ZUFzc2lnbm1lbnRNZXNzYWdlIiwidXBkYXRlU3VibWlzc2lvbiIsInVwZGF0ZVN1Ym1pc3Npb25NZXNzYWdlIiwidXBkYXRlU3VibWlzc2lvblN0YXR1cyIsInVwZGF0ZVN1Ym1pc3Npb25TdGF0dXNNZXNzYWdlIiwib25FeGVjdXRpb24iLCJleGVjdXRpb24iLCJyZXBvcnRzIiwib3V0cHV0IiwiaW5wdXQiLCJpbnB1dEluZGV4Iiwic3R1ZGVudCIsImN1cnJlbnRTdGVwIiwibGFzdFN0ZXAiLCJjdXJyZW50TGluZSIsImxhc3RMaW5lIiwiY3VycmVudFRyYWNlRGF0YSIsImN1cnJlbnRUcmFjZVN0ZXAiLCJyZXN1bHRzIiwiZ2xvYmFscyIsImNhbGxzIiwic3lzbW9kdWxlcyIsImZlZWRiYWNrIiwibWVzc2FnZSIsImNhdGVnb3J5IiwibGFiZWwiLCJsaW5lc0Vycm9yIiwibGluZXNVbmNvdmVyZWQiLCJjYWxsYmFja3MiLCJzZXJ2ZXJDb25uZWN0ZWQiLCJibG9ja2x5UGF0aCIsImF0dGFjaG1lbnRQb2ludCIsImNvbnRhaW5lciIsInVybHMiLCJjb25zdGFudHMiLCJndWkiLCJtYWtlSW50ZXJmYWNlIiwiJCIsImh0bWwiLCJhc3NpZ25tZW50X2lkIiwiY29tcG9uZW50cyIsInNlcnZlciIsInNhbXBsZXMiLCJzdGFydGluZ19jb2RlIiwibG9hZENvbmNhdGVuYXRlZEZpbGUiLCJleHRyYV9zdGFydGluZ19maWxlcyIsImxvYWROb1N1Ym1pc3Npb24iLCJncmFkaW5nX3N0YXR1cyIsInN1Ym1pc3Npb25fc3RhdHVzIiwidXNlcl9pZCIsImNvdXJzZV9pZCIsImV4dHJhX2ZpbGVzIiwiZGF0YSIsImNvbnNvbGUiLCJsb2ciLCJyZXNldEludGVyZmFjZSIsImZpbGVTeXN0ZW0iLCJkaXNtb3VudEV4dHJhRmlsZXMiLCJ3YXNTZXJ2ZXJDb25uZWN0ZWQiLCJmb3JrZWRfaWQiLCJmb3JrZWRfdmVyc2lvbiIsImlwX3JhbmdlcyIsIm9uX2NoYW5nZSIsIm5ld0ZpbGUiLCJvbl9ldmFsIiwib25fcnVuIiwib3duZXJfaWQiLCJsb2FkVGFncyIsImxvYWRTYW1wbGVTdWJtaXNzaW9ucyIsInNhbXBsZV9zdWJtaXNzaW9ucyIsImV4dHJhX2luc3RydWN0b3JfZmlsZXMiLCJsb2FkQXNzaWdubWVudFNldHRpbmdzIiwibG9hZFN1Ym1pc3Npb24iLCJjb3JnaXMiLCJsb2FkRGF0YXNldHMiLCJweXRob25FZGl0b3IiLCJibSIsInJlZnJlc2giLCJzZXRTdGF0dXMiLCJzZWxmIiwidWkiLCJpc0dyYWRlciIsInB1cmVDb21wdXRlZCIsImlzQ2hhbmdlZCIsImN1cnJlbnQiLCJ1dGlsaXRpZXMiLCJtYXJrZG93biIsInJlc2V0IiwibWVudSIsInRleHRGdWxsc2NyZWVuIiwiY2xpY2tGdWxsc2NyZWVuIiwiZWRpdElucHV0cyIsImRpYWxvZyIsIkVESVRfSU5QVVRTIiwiY2FuTWFya1N1Ym1pdHRlZCIsImNhbkNsb3NlIiwidGV4dE1hcmtTdWJtaXR0ZWQiLCJpc0NvbXBsZXRlZCIsImlzU3VibWl0dGVkIiwiY2xpY2tNYXJrU3VibWl0dGVkIiwiYWxlcnQiLCJlbmdpbmUiLCJkZWxheWVkUnVuIiwidG9Mb3dlckNhc2UiLCJzaG93UXVldWVkSW5wdXRzIiwiaGlkZVF1ZXVlZElucHV0cyIsInNlY29uZFJvdyIsImlzQWxsVmlzaWJsZSIsImhpZGVNaWRkbGVQYW5lbCIsImlzRmVlZGJhY2tWaXNpYmxlIiwiaXNUcmFjZVZpc2libGUiLCJUUkFDRSIsImlzQ29uc29sZVNob3dWaXNpYmxlIiwic3dpdGNoTGFiZWwiLCJhZHZhbmNlU3RhdGUiLCJjdXJyZW50UGFuZWwiLCJOT05FIiwic2l6ZSIsImhpZGVFdmFsdWF0ZSIsIkFDVElWRSIsImJhZGdlIiwidHJhY2UiLCJsaW5lIiwic3RlcCIsInRyYWNlRGF0YSIsImZpcnN0IiwiYmFja3dhcmQiLCJwcmV2aW91cyIsIk1hdGgiLCJtYXgiLCJmb3J3YXJkIiwibmV4dCIsIm1pbiIsImxhc3QiLCJmaWxlcyIsInZpc2libGUiLCJoaWRlRmlsZXMiLCJoYXNDb250ZW50cyIsInBhdGgiLCJzb21lIiwiZmlsZSIsImxlbmd0aCIsImFkZCIsIm5vcm1hbFRvb2xib3giLCJibG9ja0VkaXRvciIsIlRPT0xCT1hFUyIsIkpTT04iLCJzdHJpbmdpZnkiLCJTYW1wbGVTdWJtaXNzaW9uIiwiQmxhbmsiLCJuZXdGaWxlRGlhbG9nIiwiZGVsZXRlRmlsZSIsImV4dHJhU3R1ZGVudEZpbGVzIiwib2JzZXJ2ZUNvbmNhdGVuYXRlZEZpbGUiLCJkaXNwbGF5RmlsZW5hbWUiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJlZGl0b3JzIiwiZ2V0RWRpdG9yIiwidmlldyIsImhpZGVFZGl0b3JzIiwibWFwIiwic3Vic3RyIiwibWFrZU1vZGVsRmlsZSIsImNvbnRlbnRzIiwiY2FuU2F2ZSIsImNhbkRlbGV0ZSIsIlVOREVMRVRBQkxFX0ZJTEVTIiwiaW5kZXhPZiIsImNhblJlbmFtZSIsIlVOUkVOQU1BQkxFX0ZJTEVTIiwidXBsb2FkIiwidXBsb2FkRmlsZSIsImJpbmQiLCJkb3dubG9hZCIsImRvd25sb2FkRmlsZSIsImltcG9ydERhdGFzZXQiLCJvcGVuRGlhbG9nIiwicHl0aG9uIiwiY29kZU1pcnJvciIsInRleHRFZGl0b3IiLCJzZXRPcHRpb24iLCJnZXRPcHRpb24iLCJ1cGRhdGVNb2RlIiwibmV3TW9kZSIsIm9sZFB5dGhvbk1vZGUiLCJpc0hpc3RvcnlBdmFpbGFibGUiLCJpc0VuZHBvaW50Q29ubmVjdGVkIiwidHVybk9mZkhpc3RvcnlNb2RlIiwidXBkYXRlRWRpdG9yIiwic2V0UmVhZE9ubHkiLCJ0dXJuT25IaXN0b3J5TW9kZSIsInJlc3BvbnNlIiwic3VjY2VzcyIsImhpc3RvcnkiLCJsb2FkIiwiRVJST1JfTE9BRElOR19ISVNUT1JZIiwidG9nZ2xlSGlzdG9yeU1vZGUiLCJtb3ZlVG9TdGFydCIsIm1vdmVQcmV2aW91cyIsIm1vdmVOZXh0IiwibW9zdFJlY2VudCIsIm1vdmVUb01vc3RSZWNlbnQiLCJ1c2UiLCJzYXZlIiwiYnVpbGRFZGl0b3IiLCJuZXdET00iLCJpbmRleCIsIm5ld0VsZW1lbnQiLCJlZGl0b3IiLCJieU5hbWUiLCJleGVjdXRlIiwiaXNSdW5uaW5nIiwicnVuIiwiZXZhbHVhdGUiLCJtZXNzYWdlcyIsImNhcGl0YWxpemUiLCJmb3JjZSIsImV2ZW50IiwiYXNzaWdubWVudEZvcmNlTG9hZEJ1dHRvbiIsInRhcmdldCIsInBhcmVudCIsImZhZGVPdXQiLCJmYWRlSW4iLCJmciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJlIiwiYXNzaWdubWVudFN1Ym1pc3Npb24iLCJwYXJzZSIsInJlc3VsdCIsImxvYWRBc3NpZ25tZW50RGF0YV8iLCJmaWxlTmFtZSIsInJlYWRBc1RleHQiLCJ2YWwiLCJtYWtlRXh0cmFJbnRlcmZhY2VTdWJzY3JpcHRpb25zIiwiU2siLCJidWlsdGluRmlsZXMiLCJpbWFnZU1vZHVsZSIsImFwcGx5QmluZGluZ3MiLCJtYWluIiwidGV4dCIsIkVhc3lNREUiLCJwcm90b3R5cGUiLCJCbG9ja1B5RGlhbG9nIiwiZmluZCIsIkJsb2NrUHlGZWVkYmFjayIsIkJsb2NrUHlUcmFjZSIsIkJsb2NrUHlDb25zb2xlIiwiQmxvY2tQeUVuZ2luZSIsIkJsb2NrUHlGaWxlU3lzdGVtIiwiRWRpdG9ycyIsIkJsb2NrUHlTZXJ2ZXIiLCJCbG9ja1B5Q29yZ2lzIiwiQmxvY2tQeUhpc3RvcnkiLCJzdWJzY3JpYmUiLCJjaGFuZ2VkIiwidXNlclN1cHBsaWVkUGFzc2NvZGUiLCJwcm9tcHQiLCJTVEFSVF9FVkFMX0hUTUwiLCJORVdfQ09OU09MRV9MSU5FX0hUTUwiLCJDT05TT0xFX0hUTUwiLCJDb25zb2xlTGluZVR5cGUiLCJURVhUIiwiSFRNTCIsIlBMT1QiLCJJTUFHRSIsIlBZR0FNRSIsIlRVUlRMRSIsIkVWQUwiLCJTVEFSVF9FVkFMIiwiVkFMVUUiLCJJTlBVVCIsIlRFU1RfQ0FTRSIsIkNvbnNvbGVMaW5lIiwiY29udGVudCIsIm9yaWdpbiIsImN1cnJGaWxlbmFtZSIsImV4ZWN1dGlvbkJ1ZmZlciIsImZmaSIsInJlbWFwVG9QeSIsInJlbW92ZSIsIkNvbnNvbGVMaW5lVHVydGxlIiwiYWRkQ2xhc3MiLCJ3aGVyZSIsInByZXBlbmQiLCJ0b3AiLCJwb3NpdGlvbiIsInNjcm9sbFRvcCIsIkNvbnNvbGVMaW5lUHlnYW1lIiwicHlnYW1lT2JqIiwiaW5pdGlhbGl6ZWQiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmQiLCJjbGVhbnVwIiwiY2xlYW51cEZ1bmN0aW9uIiwibGlzdGVuZXJzIiwiQ29uc29sZUxpbmVJbWFnZSIsIkNvbnNvbGVMaW5lUGxvdCIsIkNvbnNvbGVMaW5lVGV4dCIsImVuY29kZWRUZXh0IiwiZW5jb2RlSFRNTCIsInRyaW0iLCJsaW5lRGF0YSIsInRvb2x0aXAiLCJDb25zb2xlTGluZVZhbHVlIiwiQ29uc29sZUxpbmVJbnB1dCIsInByb21wdE1lc3NhZ2UiLCJpbnB1dEZvcm0iLCJpbnB1dEJ0biIsImlucHV0R3JvdXAiLCJpbnB1dEJveCIsImlucHV0TXNnIiwibWFrZUludGVyYWN0aXZlIiwiYnV0dG9uIiwicmVzb2x2ZU9uQ2xpY2siLCJzdWJtaXR0ZWRQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzdWJtaXRGb3JtIiwidXNlcklucHV0dGVkVmFsdWUiLCJxdWV1ZWRJbnB1dCIsInB1c2giLCJwcm9wIiwiY2xpY2siLCJrZXl1cCIsImtleUNvZGUiLCJmb2N1cyIsIkNvbnNvbGVMaW5lRXZhbHVhdGUiLCJDb25zb2xlTGluZVN0YXJ0RXZhbHVhdGUiLCJ0YWciLCJwcmludGVyVGFnIiwiTUlOSU1VTV9XSURUSCIsIk1JTklNVU1fSEVJR0hUIiwiREVGQVVMVF9IRUlHSFQiLCJoZWlnaHQiLCJjbGVhciIsInJlbW92ZUFsbCIsImxpbmVCdWZmZXIiLCJwbG90QnVmZmVyIiwiZW1wdHkiLCJ0dXJ0bGVMaW5lIiwiVHVydGxlR3JhcGhpY3MiLCJnZXRUdXJ0bGVMaW5lIiwid2lkdGgiLCJnZXRXaWR0aCIsImdldEhlaWdodCIsImFzc2V0cyIsImxvYWRBc3NldCIsInB5Z2FtZUxpbmUiLCJyZW5kZXIiLCJjdXJyZW50UHJpbnRlckRpbWVuc2lvbiIsInNhdmVUdXJ0bGVPdXRwdXQiLCJjdHgiLCJnZXRDb250ZXh0IiwiaW1nIiwiSW1hZ2UiLCJkYXRhVXJsIiwidG9EYXRhVVJMIiwicGFnZSIsImVhY2giLCJhdHRyIiwic2hvdyIsImhpZGUiLCJsaW5lVGV4dCIsImZsdXNoIiwiY2hhckF0Iiwic3BsaXRMaW5lcyIsInNwbGl0IiwiYWRkQ29udGVudCIsImkiLCJwbG90cyIsImltYWdlRGF0YSIsImltYWdlIiwiaW1hZ2VCdWZmZXIiLCJ2YWx1ZSIsInByaW50ZWRWYWx1ZSIsImlucHV0QnVmZmVyIiwic3RhcnRFdmFsdWF0aW9uIiwiYW5pbWF0ZSIsIl9JTVBPUlRFRF9EQVRBU0VUUyIsIl9JTVBPUlRFRF9DT01QTEVURV9EQVRBU0VUUyIsInNldEJ1dHRvbkxvYWRlZCIsImJ0biIsInJlbW92ZUNsYXNzIiwibG9hZGVkRGF0YXNldHMiLCJzaWxlbnRseSIsImltcG9ydHMiLCJkYXRhc2V0cyIsImZvckVhY2giLCJCbG9ja01pcnJvckJsb2NrRWRpdG9yIiwiRVhUUkFfVE9PTFMiLCJhcHBseSIsInNsdWciLCJ3aGVuIiwiZG9uZSIsImZvcmNlQmxvY2tSZWZyZXNoIiwicmVtYWtlVG9vbGJveCIsImZhaWwiLCJhcmd1bWVudHMiLCJlcnJvciIsImFsd2F5cyIsImZpbmFsaXplU3Vic2NyaXB0aW9ucyIsInVybF9yZXRyaWV2YWxzIiwicm9vdCIsImltcG9ydERhdGFzZXRzIiwiZ2V0RGF0YXNldCIsImdldFNjcmlwdCIsImdldENvbXBsZXRlIiwiZ2V0U2t1bHB0IiwiZ2V0QmxvY2tseSIsInRleHRUb0Jsb2NrcyIsImhpZGRlbkltcG9ydHMiLCJnZXRKU09OIiwiYmxvY2tweSIsImRvY3VtZW50YXRpb24iLCJib2R5IiwiT2JqZWN0Iiwia2V5cyIsInNvcnQiLCJzbHVnZ2VkTmFtZSIsInRpdGxlTmFtZSIsImltZ1NyYyIsInRpdGxlIiwib3ZlcnZpZXciLCJhcHBlbmRUbyIsIkRJQUxPR19IVE1MIiwidGl0bGVUYWciLCJib2R5VGFnIiwiZm9vdGVyVGFnIiwib2theUJ1dHRvbiIsImNsb3NlQnV0dG9uIiwieWVzIiwibm8iLCJtb2RhbCIsImNsb3NlIiwib25jbG9zZSIsImRyYWdnYWJsZSIsIm9uIiwiY29uZmlybSIsInllc1RleHQiLCJBU1NJR05NRU5UX1ZFUlNJT05fQ0hBTkdFRCIsIkVSUk9SX0xPQURJTkdfQVNTSUdOTU5FTlQiLCJyZWFzb24iLCJFUlJPUl9TSE9XX1NUVURFTlRfRVJST1IiLCJQT1NJVElWRV9GRUVEQkFDS19GVUxMIiwiU0NSRUVOU0hPVF9CTE9DS1MiLCJFUlJPUl9VUERBVElOR19TVUJNSVNTSU9OX1NUQVRVUyIsImlucHV0VGV4dCIsImpvaW4iLCJjaGVja2VkIiwiaW5wdXRzIiwiZmlsZVJlYWRlciIsInNsdWdnaWZ5IiwicmVwbGFjZSIsImV4dGVuc2lvbiIsIm1pbWV0eXBlIiwiYmxvYiIsIkJsb2IiLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJtc1NhdmVPck9wZW5CbG9iIiwibXNTYXZlQmxvYiIsInRlbXBvcmFyeURvd25sb2FkTGluayIsImhyZWYiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwiQWJzdHJhY3RFZGl0b3IiLCJjaGFuZ2VFZGl0b3IiLCJ3YXRjaEZpbGUiLCJ1cGRhdGVkIiwib25GaWxlVXBkYXRlZCIsImRlbGV0ZWQiLCJvbkZpbGVEZWxldGVkIiwibmV3RmlsZW5hbWUiLCJvbGRFZGl0b3IiLCJnZXRGaWxlIiwidHJhY2tDdXJyZW50RmlsZSIsIm5ld0VkaXRvciIsInN0b3BXYXRjaGluZ0ZpbGUiLCJoYW5kbGUiLCJwYXJzZUZpbGVuYW1lIiwiQVNTSUdOTUVOVF9TRVRUSU5HUyIsImdldERvY3VtZW50YXRpb24iLCJtYWtlU3RhcnRWaWV3VGFiIiwiaWNvbiIsIm1vZGUiLCJBU1NJR05NRU5UX1NFVFRJTkdTX0JPT0xFQU5fQ09NUE9ORU5UU19IVE1MIiwiZmlsdGVyIiwic2V0dGluZyIsInByZXR0eU5hbWUiLCJ3b3JkIiwidG9VcHBlckNhc2UiLCJBU1NJR05NRU5UX1NFVFRJTkdTX0VESVRPUl9IVE1MIiwiQkxPQ0siLCJzYXZlQXNzaWdubWVudFNldHRpbmdzIiwiY2xpZW50TmFtZSIsInNlcnZlck5hbWUiLCJzdGFydF92aWV3IiwiZmllbGRUeXBlIiwiY29uZmlnVmFsdWUiLCJBc3NpZ25tZW50U2V0dGluZ3NWaWV3IiwiZGlydHkiLCJjdXJyZW50TGlzdGVuZXIiLCJ1cGRhdGVIYW5kbGUiLCJuZXdDb250ZW50cyIsIkFzc2lnbm1lbnRTZXR0aW5ncyIsImV4dGVuc2lvbnMiLCJjb25zdHJ1Y3RvciIsInRlbXBsYXRlIiwiSlNPTl9FRElUT1JfSFRNTCIsIkpzb25FZGl0b3JWaWV3IiwiQ29kZU1pcnJvciIsImZyb21UZXh0QXJlYSIsInNob3dDdXJzb3JXaGVuU2VsZWN0aW5nIiwibGluZU51bWJlcnMiLCJmaXJzdExpbmVOdW1iZXIiLCJpbmRlbnRVbml0IiwidGFiU2l6ZSIsImluZGVudFdpdGhUYWJzIiwiZXh0cmFLZXlzIiwiY20iLCJibHVyIiwiY3VycmVudFN1YnNjcmlwdGlvbiIsInNldFRpbWVvdXQiLCJzZXRWYWx1ZSIsImdldFZhbHVlIiwiZGlzcG9zZSIsIm9mZiIsIkpzb25FZGl0b3IiLCJNQVJLRE9XTl9FRElUT1JfSFRNTCIsIk1hcmtkb3duRWRpdG9yVmlldyIsIm1kZSIsImVsZW1lbnQiLCJhdXRvRG93bmxvYWRGb250QXdlc29tZSIsImZvcmNlU3luYyIsIm1pbkhlaWdodCIsInJlbmRlcmluZ0NvbmZpZyIsImNvZGVTeW50YXhIaWdobGlnaHRpbmciLCJjb2RlbWlycm9yIiwiTWFya2Rvd25FZGl0b3IiLCJtYWtlVGFiIiwiUFlUSE9OX0VESVRPUl9IVE1MIiwiSElTVE9SWV9UT09MQkFSX0hUTUwiLCJjb252ZXJ0SXB5bmJUb1B5dGhvbiIsImlweW5iIiwiaXNVc2FibGUiLCJjZWxsIiwiY2VsbF90eXBlIiwic291cmNlIiwibWFrZVB5dGhvbiIsImNlbGxzIiwiUHl0aG9uRWRpdG9yVmlldyIsIkJsb2NrbHkiLCJzZXRQYXJlbnRDb250YWluZXIiLCJCbG9ja01pcnJvciIsInRvb2xib3giLCJpbWFnZURvd25sb2FkSE9vayIsIm9sZFVybCIsImltYWdlVXBsb2FkSG9vayIsImltYWdlTGl0ZXJhbEhvb2siLCJtYWtlU3Vic2NyaXB0aW9ucyIsImxpbmVFcnJvclN1YnNjcmlwdGlvbiIsImxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24iLCJtYWtlUGVyQXNzaWdubWVudFN1YnNjcmlwdGlvbnMiLCJ3b3Jrc3BhY2UiLCJjb25maWd1cmVDb250ZXh0TWVudSIsIm9wdGlvbnMiLCJlbmFibGVkIiwiY2FsbGJhY2siLCJvbGRGaWxlbmFtZSIsImN1cnJlbnRCTUxpc3RlbmVyIiwiYWRkQ2hhbmdlTGlzdGVuZXIiLCJpc1BhcnNvbnMiLCJsaW5lcyIsInNldEhpZ2hsaWdodGVkTGluZXMiLCJkZWxldGVGaWxlTG9jYWxseV8iLCJzZXRDb2RlIiwiY2xlYXJIaWdobGlnaHRlZExpbmVzIiwiZ2V0Q29kZSIsInJlbW92ZUNoYW5nZUxpc3RlbmVyIiwiY2xlYXJMaW5lU3Vic2NyaXB0aW9ucyIsInNldE1vZGUiLCJlbmFibGVCbG9ja3MiLCJyZWxvYWRUb29sYm94IiwiZW5hYmxlSW1hZ2VzIiwiaW1hZ2VNb2RlIiwic2V0SW1hZ2VNb2RlIiwiY3VzdG9tVG9vbGJveCIsImRlY2lkZUlmTm90RWRpdGFibGUiLCJvbmx5VXBsb2FkcyIsImlzUmVhZE9ubHkiLCJlbmRzV2l0aCIsIlB5dGhvbkVkaXRvciIsIlN1Ym1pc3Npb25TdGF0dXNlcyIsIlVOS05PV04iLCJQQVNTRUQiLCJGQUlMRUQiLCJFUlJPUiIsIlNLSVBQRUQiLCJjb3VudCIsIlNBTVBMRV9TVUJNSVNTSU9OU19IVE1MIiwiYmluZGluZ0hhbmRsZXJzIiwiY29kZU1pcnJvckluc3RhbmNlIiwiaW5pdCIsInZhbHVlQWNjZXNzb3IiLCJhbGxCaW5kaW5ncyIsInZpZXdNb2RlbCIsImJpbmRpbmdDb250ZXh0Iiwic2V0U2l6ZSIsInVwZGF0ZSIsIlNhbXBsZVN1Ym1pc3Npb25zVmlldyIsImNvZGVNaXJyb3JzIiwiU2FtcGxlU3VibWlzc2lvbnMiLCJUQUdTX0VESVRPUl9IVE1MIiwiVGFnc0VkaXRvclZpZXciLCJUYWdzRWRpdG9yIiwiVEVYVF9FRElUT1JfSFRNTCIsIlRleHRFZGl0b3JWaWV3IiwiVGV4dEVkaXRvciIsIlRPT0xCT1hfRURJVE9SX0hUTUwiLCJUb29sYm94RWRpdG9yVmlldyIsIlRvb2xib3hFZGl0b3IiLCJFZGl0b3JzRW51bSIsIlNVQk1JU1NJT04iLCJBU1NJR05NRU5UIiwiSU5TVFJVQ1RJT05TIiwiT05fUlVOIiwiT05fQ0hBTkdFIiwiT05fRVZBTCIsIlNUQVJUSU5HX0NPREUiLCJTQU1QTEVfU1VCTUlTU0lPTlMiLCJJTlNUUlVDVE9SX0ZJTEUiLCJTUEVDSUFMX05BTUVTUEFDRVMiLCJBVkFJTEFCTEVfRURJVE9SUyIsIkVESVRPUlNfSFRNTCIsInJlZ2lzdGVyZWRfIiwiZXh0ZW5zaW9uc18iLCJieU5hbWVfIiwicmVnaXN0ZXJFZGl0b3IiLCJpbnN0YW5jZSIsImV4aXQiLCJlbnRlciIsInNwYWNlIiwibGFzdEluZGV4T2YiLCJleGVjdXRpb25Nb2RlbCIsImNvbmZpZ3VyYXRpb25zIiwiUnVuQ29uZmlndXJhdGlvbiIsImV2YWwiLCJFdmFsQ29uZmlndXJhdGlvbiIsIk9uUnVuQ29uZmlndXJhdGlvbiIsIk9uQ2hhbmdlQ29uZmlndXJhdGlvbiIsIk9uRXZhbENvbmZpZ3VyYXRpb24iLCJjb25maWd1cmUiLCJnZXRTa3VscHRPcHRpb25zIiwib25FeGVjdXRpb25CZWdpbiIsIm9uRXhlY3V0aW9uRW5kIiwicmVwb3J0IiwicmVzZXRTdHVkZW50TW9kZWwiLCJyZXNldFJlcG9ydHMiLCJyZXNldEV4ZWN1dGlvbkJ1ZmZlciIsInRoZW4iLCJmYWlsdXJlIiwiZGlzYWJsZUZlZWRiYWNrIiwicHJvdmlkZVNlY3JldEVycm9yIiwic2hvd0Vycm9ycyIsImV4ZWN1dGlvbkVuZF8iLCJldmFsdWF0aW9uSW5wdXQiLCJ1c2VySW5wdXQiLCJtaXNjZXZhbCIsImFzeW5jVG9Qcm9taXNlIiwiaW1wb3J0TWFpbldpdGhCb2R5IiwiRklMRU5BTUUiLCJwcm9ncmFtcyIsInNhdmVDb2RlIiwidmVyaWZ5Q29kZSIsInVwZGF0ZVBhcnNlIiwicnVuSW5zdHJ1Y3RvckNvZGUiLCJtb2R1bGUiLCJleGVjdXRpb25SZXBvcnRzIiwicHJlc2VudEZlZWRiYWNrIiwiJGQiLCJFTVBUWV9NT0RVTEUiLCJDb25maWd1cmF0aW9uIiwiaW5Ccm93c2VyIiwib3BlbkZpbGUiLCJyZXF1ZXN0c0dldCIsInRpbWVvdXQiLCJvcGVuVVJMIiwidGltZW91dEhhbmRsZXIiLCJ0aW1lUGFzc2VkIiwiZXhlY0xpbWl0IiwiZGlzYWJsZVRpbWVvdXQiLCJnZXRUaW1lb3V0UHJvbXB0IiwiZGVsYXkiLCJwYXJzZUludCIsImV4ZWNMaW1pdEZ1bmN0aW9uIiwiSW5maW5pdHkiLCJsb25nVGltZW91dCIsIl9fZnV0dXJlX18iLCJweXRob24zIiwicmVhZCIsImltcG9ydEZpbGUiLCJmaWxld3JpdGUiLCJ3cml0ZUZpbGUiLCJwcmludCIsImlucHV0ZnVuIiwiaW5wdXRmdW5UYWtlc1Byb21wdCIsImltYWdlUHJveHkiLCJnZXRJbWFnZVByb3h5IiwicmV0YWluR2xvYmFscyIsIndhcm4iLCJtb2NrVXJsRGF0YSIsImJ1aWx0aW4iLCJJT0Vycm9yIiwiaGFzT3duUHJvcGVydHkiLCJmaWxlRGF0YSIsInJlYWRGaWxlIiwiRXJyb3IiLCJzdG9wIiwicG9wIiwiYWZ0ZXJTaW5nbGVFeGVjdXRpb24iLCJiZWZvcmVDYWxsIiwicHJpbnRWYWx1ZSIsInJlbWFwVG9KcyIsIl8iLCIkciIsInJlamVjdCIsIngiLCJpc0RvY3N0cmluZyIsIlN0dWRlbnRDb25maWd1cmF0aW9uIiwiVVRJTElUWV9NT0RVTEVfQ09ERSIsIiRza19tb2RfaW5zdHJ1Y3RvciIsIkNPVkVSQUdFX01PRFVMRV9DT0RFIiwiJHNrX21vZF9jb3ZlcmFnZSIsIkluc3RydWN0b3JDb25maWd1cmF0aW9uIiwiJHBlZGFsX3RyYWNlciIsIiRtYWluIiwic3RyIiwicXVpY2skbG9va3VwIiwiZGVsJGl0ZW0iLCJmb3VuZCIsInNlYXJjaEZvckZpbGUiLCJPU0Vycm9yIiwibmV4dElucHV0IiwiY2xlYXJUaW1lb3V0IiwiV1JBUF9JTlNUUlVDVE9SX0NPREUiLCJzdHVkZW50Q29kZSIsImluc3RydWN0b3JDb2RlIiwicXVpY2siLCJpc1NhZmUiLCJzYWZlQ29kZSIsImluZGVudGVkQ29kZSIsImluZGVudCIsImRpc2FibGVUaWZhIiwic3R1ZGVudENvZGVTYWZlIiwiZXZhbHVhdGlvbiIsImR1bW15T3V0U2FuZGJveCIsImxpbmVPZmZzZXQiLCJORVdfTElORV9SRUdFWCIsIlNVQ0NFU1MiLCJTQ09SRSIsIm9sZFNjb3JlIiwiSElERSIsInNjcm9sbGluZyIsInNjcm9sbFRvQm90dG9tIiwidHAkbmFtZSIsInByZXNlbnRJbnRlcm5hbEVycm9yIiwidGlmYUFuYWx5c2lzIiwic2tpcF90aWZhIiwiT25TYW1wbGVDb25maWd1cmF0aW9uIiwiQm9vbGVhbiIsImNsZWFySW5wdXQiLCJmaW5pc2hUdXJ0bGVzIiwiYmVnaW5FdmFsIiwicGFyc2VyIiwidmVyaWZpZXIiLCJTYW1wbGVDb25maWd1cmF0aW9uIiwiaXNGb3JiaWRkZW4iLCJsb2NhbHMiLCJsaW5lTnVtYmVyIiwiY29sdW1uTnVtYmVyIiwicGFyc2VHbG9iYWxzIiwicHJvcGVydGllcyIsIm1vZHVsZXMiLCJmdW5jdGlvbk5hbWUiLCJwb3NhcmdzIiwia3dhcmdzIiwic3R1ZGVudE1vZGVsIiwiYXJncyIsImFzdCIsInZpc2l0ZWRMaW5lcyIsIlNldCIsInZpc2l0Qm9keSIsIm5vZGUiLCJsaW5lbm8iLCJzdGF0ZW1lbnQiLCJvcmVsc2UiLCJmaW5hbGJvZHkiLCJBcnJheSIsImZyb20iLCJhc3RGcm9tUGFyc2UiLCJjc3QiLCJmbGFncyIsImdldExpbmVzIiwicHJlc2VudFJ1bkVycm9yIiwiZXJyb3JCdXR0b24iLCJGRUVEQkFDS19IVE1MIiwiZmVlZGJhY2tNb2RlbCIsInBvc2l0aXZlIiwib2Zmc2V0IiwidmlzaWJpbGl0eUJ1ZmZlciIsInRvcE9mRWxlbWVudCIsImJvdHRvbU9mRWxlbWVudCIsImJvdHRvbU9mU2NyZWVuIiwidG9wT2ZTY3JlZW4iLCJjbGVhclBvc2l0aXZlRmVlZGJhY2siLCJleGVjdXRpb25SZXN1bHRzIiwiTUVTU0FHRSIsIkNBVEVHT1JZIiwiTEFCRUwiLCJEQVRBIiwicG9zaXRpdmVzIiwiUE9TSVRJVkUiLCJoaWRlU2NvcmUiLCJibG9jayIsImhsanMiLCJoaWdobGlnaHRCbG9jayIsImZpbmRGaXJzdEVycm9yTGluZSIsInN0dWRlbnRSZXBvcnQiLCJ1bmNvdmVyZWRMaW5lcyIsInBvc2l0aXZlRGF0YSIsImFkZFBvc2l0aXZlRmVlZGJhY2siLCJjb2xvciIsIm9uY2xpY2siLCJ0b0VuZCIsImNzcyIsImhvdmVyIiwidXBkYXRlRmVlZGJhY2siLCJub3RpZnlGZWVkYmFja1VwZGF0ZSIsInNjcm9sbEludG9WaWV3IiwianVzdF9yZXR1cm4iLCJjb252ZXJ0U2t1bHB0RXJyb3IiLCJmaWxlbmFtZUV4ZWN1dGVkIiwidHJhY2ViYWNrIiwiZnJhbWUiLCJzY29wZSIsImZlZWRiYWNrRGF0YSIsImxvY2F0aW9uIiwidHAkZ2V0YXR0ciIsImZyaWVuZGx5TmFtZSIsImhpZGVJZkVtcHR5Iiwibm90SW5zdHJ1Y3RvciIsImluc3RydWN0b3JGaWxlQ2xhc3MiLCJoaWRlSWZOb3RJbnN0cnVjdG9yIiwiRklMRVNfSFRNTCIsIk5FV19JTlNUUlVDVE9SX0ZJTEVfRElBTE9HX0hUTUwiLCJTVEFSVElOR19GSUxFUyIsIkJBU0lDX05FV19GSUxFUyIsIklOU1RSVUNUT1JfRElSRUNUT1JZIiwiU1RVREVOVF9ESVJFQ1RPUlkiLCJTZWFyY2hNb2RlcyIsIkVWRVJZV0hFUkUiLCJTVEFSVF9XSVRIX0lOU1RSVUNUT1IiLCJPTkxZX1NUVURFTlRfRklMRVMiLCJERUxFVEFCTEVfU0lNUExFX0ZJTEVTIiwiQmxvY2tQeUZpbGUiLCJvd25lciIsIm1ha2VNb2NrTW9kZWxGaWxlIiwiY29uY2F0ZW5hdGVkRmlsZSIsIm1vZGVsRmlsZUxpc3QiLCJtb2RlbEZpbGVzIiwiY3JlYXRlQ29uY2F0ZW5hdGVkRmlsZSIsImZpbGVzXyIsIm1vdW50RmlsZXMiLCJ3YXRjaE1vZGVsIiwid2F0Y2hlc18iLCJ2aXNpYmxpdHkiLCJ0b2dnbGUiLCJmaWxlc3lzdGVtIiwiZmlsZUFycmF5IiwiY2hhbmdlcyIsImNoYW5nZSIsIm1vZGVsRmlsZSIsIm5vdGlmeVdhdGNoZXMiLCJvYnNlcnZlSW5BcnJheV8iLCJhcnJheSIsImNvZGVCdW5kbGUiLCJleGlzdGluZ0ZpbGUiLCJvYnNlcnZlRmlsZV8iLCJzdHVkZW50U2VhcmNoIiwic2VhcmNoTW9kZSIsInNwZWNpYWxGaWxlIiwic2VhcmNoRm9yU3BlY2lhbEZpbGVzXyIsInN0dWRlbnRWZXJzaW9uIiwic2VhcmNoRm9yRmlsZUluTGlzdF8iLCJnZW5lcmF0ZWRWZXJzaW9uIiwiZGVmYXVsdFZlcnNpb24iLCJmaXJzdERlZmluZWRWYWx1ZSIsImluc3RydWN0b3JWZXJzaW9uIiwiaGlkZGVuVmVyc2lvbiIsInN0YXJ0aW5nVmVyc2lvbiIsIm1vZGVsTGlzdCIsImtpbmQiLCJmaWxldHlwZSIsIm5hbWVzcGFjZSIsImV4dGVuc2lvblJlZ2V4IiwiZXhlYyIsInByZWZpeCIsInN1Ym1pdCIsInByZXZlbnREZWZhdWx0IiwiRk9PVEVSX0hUTUwiLCJjdXJyZW50SWQiLCJlZGl0RXZlbnRzIiwic2VsZWN0b3IiLCJlZGl0SWQiLCJlbnRyeSIsImZpbGVfcGF0aCIsImV2ZW50X3R5cGUiLCJSRU1BUF9FVkVOVF9UWVBFUyIsImRpc3BsYXllZCIsInByZXR0eVByaW50RGF0ZVRpbWUiLCJjbGllbnRfdGltZXN0YW1wIiwiZGlzYWJsZSIsIm9wdGlvbiIsImRpc2FibGVkIiwiaXNFZGl0RXZlbnQiLCJldnQiLCJtb250aE5hbWVzIiwid2Vla0RheXMiLCJpc1NhbWVEYXkiLCJzZWNvbmQiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJnZXRGdWxsWWVhciIsInRpbWVTdHJpbmciLCJub3ciLCJEYXRlIiwicGFzdCIsInRvTG9jYWxlVGltZVN0cmluZyIsImRheVN0ciIsImdldERheSIsIm1vbnRoU3RyIiwiZGF0ZSIsImdldEhpc3RvcnkiLCJyZXZlcnNlIiwicmVkdWNlIiwiY29tcGxldGUiLCJlbGVtIiwiY29tcGxldGVfc3RyIiwidGltZSIsIm5ld19saW5lIiwiaGlnaGxpZ2h0VGltZW91dCIsImlzRnVsbHNjcmVlbiIsInJlcXVlc3RGdWxsc2NyZWVuIiwiZXJyIiwiZXhpdEZ1bGxzY3JlZW4iLCJUUkFDRV9IVE1MIiwiUkVUUllJTkciLCJPRkZMSU5FIiwic3RvcmFnZSIsInF1ZXVlIiwiZ2V0RGVmYXVsdCIsIk1BWF9RVUVVRV9TSVpFIiwiVElNRVJfREVMQVkiLCJGQUlMX0RFTEFZIiwidGltZXJzIiwib3ZlcmxheSIsImJsb2NraW5nQXR0ZW1wdHMiLCJjYWNoZWRGaWxlbmFtZXMiLCJjcmVhdGVTdWJzY3JpcHRpb25zIiwiY2hlY2tDYWNoZXMiLCJjaGVja0lQIiwib2xkSVAiLCJpcCIsInNldCIsIl9wb3N0TGF0ZXN0UmV0cnkiLCJwdXNoQW55UXVldWVkIiwiX3Bvc3RSZXRyeSIsImNyZWF0ZUZpbGVTdWJzY3JpcHRpb24iLCJjcmVhdGVFdmVudExvZ3MiLCJvbmJsdXIiLCJvbmZvY3VzIiwiY3JlYXRlU2VydmVyRGF0YSIsIm1pY3Jvc2Vjb25kcyIsImdldFRpbWUiLCJnZXRUaW1lem9uZU9mZnNldCIsInNob3dPdmVybGF5IiwiYXR0ZW1wdCIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJoaWRlT3ZlcmxheSIsIl9lbnF1ZXVlRGF0YSIsImNhY2hlIiwiX2RlcXVldWVEYXRhIiwic3BsaWNlIiwicG9zdFJlcXVlc3QiLCJwb3N0IiwidGV4dFN0YXR1cyIsInJlcXVlc3QiLCJjYWNoZWRUaW1lIiwiX3Bvc3RCbG9ja2luZyIsImF0dGVtcHRzIiwiZXJyb3JUaHJvd24iLCJFUlJPUl9TQVZJTkdfQVNTSUdOTU5FTlQiLCJkaXJlY3RvcnkiLCJuZXdTdGF0dXMiLCJwb3N0U3RhdHVzQ2hhbmdlIiwiZXJyb3JDYWxsYmFjayIsImxvYWRfZmlsZSIsImhpZGRlbk92ZXJyaWRlIiwiZm9yY2VVcGRhdGUiLCJnZXRQbmdGcm9tQmxvY2tzIiwicG5nRGF0YSIsIiRidWlsdGlubW9kdWxlIiwibW9kIiwic2FtcGxlV3JhcHBlciIsIl9fbmFtZV9fIiwiUElMIiwiSW5zdGFudFByb21pc2UiLCJsYXN0UmVzdWx0IiwibGFzdEVycm9yIiwiY2IiLCJidWlsZEltYWdlIiwiZ2V0QXNzZXQiLCJjcm9zc09yaWdpbiIsIm9uZXJyb3IiLCJzcmMiLCIkZ2JsIiwiJGxvYyIsIl9faW5pdF9fIiwiZnVuYyIsImZpbGVfb3JfdXJsIiwicHlDaGVja0FyZ3MiLCJweUNoZWNrVHlwZSIsImNoZWNrU3RyaW5nIiwiaW1hZ2VQcm9taXNlIiwic3VzcCIsIlN1c3BlbnNpb24iLCJub25lIiwibm9uZSQiLCJyZXN1bWUiLCJwcm9taXNlIiwiZHJhd0ltYWdlIiwicGl4ZWxzIiwiZ2V0SW1hZ2VEYXRhIiwiTmFtZUVycm9yIiwiY29uc29sZURhdGEiLCJwcmludFBJTEltYWdlIiwiZmxpcCIsInN0eWxlIiwidHJhbnNmb3JtIiwiYnVpbGRDbGFzcyIsInByaW9yIiwidGltZWl0IiwiZGlmZmVyZW5jZSIsImNvbnNvbGVfbG9nIiwiY29uc29sZV9kZWJ1ZyIsImdldF9vdXRwdXQiLCJpdGVtIiwidG9Ta3VscHQiLCJsaXN0IiwicmVzZXRfb3V0cHV0IiwiZ2V0X3Byb2dyYW0iLCJnZXRfZXZhbHVhdGlvbiIsInRyYWNlX2xpbmVzIiwicmVhbExpbmVzIiwidHJhY2VfY2FsbHMiLCJkaWN0IiwiZ2V0X3N0dWRlbnRfZXJyb3IiLCJ0dXBsZSIsImhhZF9leGVjdXRpb25fdGltZV9lcnJvciIsImJhY2t1cFRpbWUiLCJsaW1pdF9leGVjdXRpb25fdGltZSIsImV4ZWNTdGFydCIsInVubGltaXRfZXhlY3V0aW9uX3RpbWUiLCJzdXBwcmVzc19zY3JvbGxpbmciLCJnZXRfcGxvdHMiLCJvdXRwdXRzIiwiZ3JhcGgiLCJwbG90IiwibmV3UGxvdCIsInYiLCJ5IiwiU3R1ZGVudERhdGEiLCJuZXdEaWN0IiwiYWJzdHIiLCJzYXR0ciIsIm9iamVjdFNldEl0ZW0iLCJ1bmZpeFJlc2VydmVkIiwiY2FsbF9mIiwia3dhIiwicHlDaGVja0FyZ3NMZW4iLCJjYWxsIiwiYnVpbHRpbnMiLCJtcCRsb29rdXAiLCJmdW5jdGlvbk9iamVjdCIsInRwJGNhbGwiLCJjb19rd2FyZ3MiLCJjb19uYW1lIiwiZ2V0X25hbWVzX2J5X3R5cGUiLCJleGNsdWRlX2J1aWx0aW5zIiwiY2hlY2tCb29sIiwicHJvcGVydHkiLCJnZXRfdmFsdWVzX2J5X3R5cGUiLCJjYWxsc2ltT3JTdXNwZW5kIiwiZ2V0X3N0dWRlbnRfZGF0YSIsInNldF9pbnN0cnVjdGlvbnMiLCJuZXdJbnN0cnVjdGlvbnMiLCJnZXRfbW9kZWxfaW5mbyIsIkxPQ0FMX1NUT1JBR0VfUkVGIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJfZGF0YSIsIlN0cmluZyIsImdldEl0ZW0iLCJpc19uZXciLCJzZXJ2ZXJfdGltZSIsInN0b3JlZF90aW1lIiwiSUdOT1JFRF9HTE9CQUxTIiwidmFyaWFibGVzIiwicGFyc2VkIiwicGFyc2VWYWx1ZSIsImZ1bGxMZW5ndGgiLCJmdW5jX2NvZGUiLCJjb192YXJuYW1lcyIsInNxJGxlbmd0aCIsImJvb2wiLCJubWJlciIsInNrVHlwZSIsImludF8iLCJmbG9hdF8iLCJOdW1iZXIiLCJhcnJheUNvbnRhaW5zIiwibmVlZGxlIiwiaGF5c3RhY2siLCJhcnJheVVuaXF1ZSIsImEiLCJjb25jYXQiLCJqIiwiZXhwYW5kQXJyYXkiLCJhZGRBcnJheSIsInJlbW92ZUFycmF5IiwiY29weUFycmF5IiwiY2xvbmVOb2RlIiwiY2xvbmUiLCJub2RlVHlwZSIsImNyZWF0ZVRleHROb2RlIiwibm9kZVZhbHVlIiwiY2hpbGQiLCJmaXJzdENoaWxkIiwibmV4dFNpYmxpbmciLCJzIiwicmFuZG9tSW50ZWdlciIsImZsb29yIiwicmFuZG9tIiwiV29ya3NwYWNlU3ZnIiwic2h1ZmZsZSIsIm1ldHJpY3MiLCJnZXRNZXRyaWNzIiwidmlld1dpZHRoIiwidmlld0hlaWdodCIsImJsb2NrcyIsImdldFRvcEJsb2NrcyIsIm1heGltYWxfaW5jcmVhc2UiLCJnZXRSZWxhdGl2ZVRvU3VyZmFjZVhZIiwibW92ZUJ5IiwibW92ZUVsZW1lbnRzIiwibW92ZUNoZWNrIiwiaXNTa0J1aWx0aW4iLCJvYmoiLCJsbmciLCJpc0FzdE5vZGUiLCJtaXhlZFJlbWFwVG9QeSIsImsiLCJrdnMiLCJhcnIiLCJzdWJ2YWwiLCJhc3NrJCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87UUNWQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRkE7Ozs7QUFJQTtBQUNBO0FBQ0E7Q0FFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUEs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QUFHLENBQUN2MUIsSUFBSixDQUFTcTFCLGNBQWMsQ0FBQ0gsR0FBRyxDQUFDSSxDQUFELENBQUosQ0FBdkI7QUFDSCxPQVJnQixDQVNqQjs7O0FBQ0EsYUFBTyxJQUFJOTZCLEVBQUUsQ0FBQ2llLE9BQUgsQ0FBV2tXLElBQWYsQ0FBb0I0RyxHQUFwQixDQUFQO0FBQ0gsS0FYRCxNQVdLO0FBQ0QsYUFBT0wsR0FBUDtBQUNIO0FBQ0osR0FmTSxNQWVBLElBQUksT0FBT0EsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQ2hDLFdBQU8sSUFBSTE2QixFQUFFLENBQUNpZSxPQUFILENBQVd5QixHQUFmLENBQW1CZ2IsR0FBbkIsQ0FBUDtBQUNILEdBRk0sTUFFQSxJQUFJLE9BQU9BLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUNoQyxXQUFPMTZCLEVBQUUsQ0FBQ2llLE9BQUgsQ0FBV2lkLEtBQVgsQ0FBaUJSLEdBQWpCLENBQVA7QUFDSCxHQUZNLE1BRUEsSUFBSSxPQUFPQSxHQUFQLEtBQWUsU0FBbkIsRUFBOEI7QUFDakMsV0FBTyxJQUFJMTZCLEVBQUUsQ0FBQ2llLE9BQUgsQ0FBVzhaLElBQWYsQ0FBb0IyQyxHQUFwQixDQUFQO0FBQ0gsR0FGTSxNQUVBLElBQUcsT0FBT0EsR0FBUCxLQUFlLFVBQWxCLEVBQThCO0FBQ2pDLFdBQU8sSUFBSTE2QixFQUFFLENBQUNpZSxPQUFILENBQVd5QixHQUFmLENBQW1CZ2IsR0FBRyxDQUFDbnVDLElBQXZCLENBQVA7QUFDSDtBQUNKLEM7Ozs7Ozs7Ozs7O0FDblFELG9EOzs7Ozs7Ozs7OztBQ0FBLHNEIiwiZmlsZSI6ImJsb2NrcHkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJqUXVlcnlcIiksIHJlcXVpcmUoXCJrb1wiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcImJsb2NrcHlcIiwgW1wialF1ZXJ5XCIsIFwia29cIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiYmxvY2tweVwiXSA9IGZhY3RvcnkocmVxdWlyZShcImpRdWVyeVwiKSwgcmVxdWlyZShcImtvXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJibG9ja3B5XCJdID0gZmFjdG9yeShyb290W1wialF1ZXJ5XCJdLCByb290W1wia29cIl0pO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfanF1ZXJ5X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfa25vY2tvdXRfXykge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2Jsb2NrcHkuanNcIik7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgU3RhcnRpbmcgcG9pbnQgb2YgdGhlIEJsb2NrUHkgYXBwbGljYXRpb24sIGNvbnRhaW5pbmcgdGhlIG1haW5cbiAqIEJsb2NrUHkgY2xhc3MuXG4gKi9cbmltcG9ydCBcIi4vY3NzL2Jsb2NrcHkuY3NzXCI7XG5pbXBvcnQgXCIuL2Nzcy9ib290c3RyYXBfcmV0aGVtZS5jc3NcIjtcbmltcG9ydCAkIGZyb20gXCJqcXVlcnlcIjtcbmltcG9ydCB7JGJ1aWx0aW5tb2R1bGUgYXMgaW1hZ2VNb2R1bGV9IGZyb20gXCJza3VscHRfbW9kdWxlcy9pbWFnZVwiO1xuLy9pbXBvcnQgeyRidWlsdGlubW9kdWxlIGFzIG1hdHBsb3RsaWJNb2R1bGV9IGZyb20gXCJza3VscHRfbW9kdWxlcy9tYXRwbG90bGliMlwiO1xuaW1wb3J0IHtMb2NhbFN0b3JhZ2VXcmFwcGVyfSBmcm9tIFwic3RvcmFnZS5qc1wiO1xuaW1wb3J0IHtFZGl0b3JzRW51bX0gZnJvbSBcImVkaXRvcnMuanNcIjtcbmltcG9ydCB7RGlzcGxheU1vZGVzfSBmcm9tIFwiZWRpdG9yL3B5dGhvbi5qc1wiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcInNlcnZlci5qc1wiO1xuaW1wb3J0IHttYWtlSW50ZXJmYWNlLCBtYWtlRXh0cmFJbnRlcmZhY2VTdWJzY3JpcHRpb25zLCBTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnN9IGZyb20gXCJpbnRlcmZhY2UuanNcIjtcbmltcG9ydCB7RWRpdG9yc30gZnJvbSBcImVkaXRvcnMuanNcIjtcbmltcG9ydCB7XG4gICAgQmxvY2tQeUZpbGVTeXN0ZW0sXG4gICAgbG9hZENvbmNhdGVuYXRlZEZpbGUsXG4gICAgbWFrZU1vZGVsRmlsZSxcbiAgICBvYnNlcnZlQ29uY2F0ZW5hdGVkRmlsZSxcbiAgICBVTkRFTEVUQUJMRV9GSUxFUyxcbiAgICBVTlJFTkFNQUJMRV9GSUxFU1xufSBmcm9tIFwiLi9maWxlc1wiO1xuaW1wb3J0IHt1cGxvYWRGaWxlLCBkb3dubG9hZEZpbGV9IGZyb20gXCIuL2VkaXRvci9hYnN0cmFjdF9lZGl0b3JcIjtcbmltcG9ydCB7QmxvY2tQeUVuZ2luZX0gZnJvbSBcImVuZ2luZS5qc1wiO1xuaW1wb3J0IHtCbG9ja1B5VHJhY2V9IGZyb20gXCIuL3RyYWNlXCI7XG5pbXBvcnQge0Jsb2NrUHlDb25zb2xlfSBmcm9tIFwiLi9jb25zb2xlXCI7XG5pbXBvcnQge0Jsb2NrUHlGZWVkYmFja30gZnJvbSBcImZlZWRiYWNrLmpzXCI7XG5pbXBvcnQge0Jsb2NrUHlTZXJ2ZXJ9IGZyb20gXCIuL3NlcnZlclwiO1xuaW1wb3J0IHtCbG9ja1B5RGlhbG9nfSBmcm9tIFwiLi9kaWFsb2dcIjtcbmltcG9ydCB7bG9hZEFzc2lnbm1lbnRTZXR0aW5ncywgbWFrZUFzc2lnbm1lbnRTZXR0aW5nc01vZGVsfSBmcm9tIFwiLi9lZGl0b3IvYXNzaWdubWVudF9zZXR0aW5nc1wiO1xuaW1wb3J0IHtCbG9ja1B5Q29yZ2lzLCBfSU1QT1JURURfQ09NUExFVEVfREFUQVNFVFMsIF9JTVBPUlRFRF9EQVRBU0VUU30gZnJvbSBcIi4vY29yZ2lzXCI7XG5pbXBvcnQge0Jsb2NrUHlIaXN0b3J5fSBmcm9tIFwiLi9oaXN0b3J5XCI7XG5pbXBvcnQge2NhcGl0YWxpemV9IGZyb20gXCIuL3V0aWxpdGllc1wiO1xuaW1wb3J0IHtTYW1wbGVTdWJtaXNzaW9ufSBmcm9tIFwiLi9lZGl0b3Ivc2FtcGxlX3N1Ym1pc3Npb25zXCI7XG5cbmV4cG9ydCB7X0lNUE9SVEVEX0NPTVBMRVRFX0RBVEFTRVRTLCBfSU1QT1JURURfREFUQVNFVFN9O1xuXG5jb25zdCBFRElUT1JfVkVSU0lPTiA9IFwiNS4xLjFcIjtcblxuLyoqXG4gKiBNYWpvciBlbnRyeSBwb2ludCBmb3IgY3JlYXRpbmcgYSBCbG9ja1B5IGluc3RhbmNlLlxuICogVHdvIG1vc3QgaW1wb3J0YW50IGZpZWxkcyBhcmUgYG1vZGVsYCBhbmQgYGNvbXBvbmVudHNgLlxuICogVGhlIGBtb2RlbGAgaG9sZHMgYWxsIHRoZSBkYXRhIGFib3V0IHRoZSBpbnRlcmZhY2UuXG4gKiBUaGUgYGNvbXBvbmVudHNgIGFyZSByZWZlcmVuY2VzIHRvIHRoZSBkaXNwYXJhdGUgcGFydHMgb2YgQmxvY2tQeS5cbiAqXG4gKiBNb3N0IG9mIHRoaXMgY2xhc3NlcyBkZWZpbml0aW9uIGlzIGp1c3QgaW5pdGlhbGl6aW5nIHRoZSBtb2RlbCBhbmQgdXBkYXRpbmdcbiAqIGl0IG9uIGFuIGFzc2lnbm1lbnQgc3dpdGNoLlxuICovXG5leHBvcnQgY2xhc3MgQmxvY2tQeSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ3VyYXRpb24gLSBVc2VyIGxldmVsIHNldHRpbmdzIChlLmcuLCB3aGF0IGVkaXRvciBtb2RlLCB3aGV0aGVyIHRvIG11dGUgc2VtYW50aWMgZXJyb3JzLCBldGMuKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhc3NpZ25tZW50IC0gQXNzaWdubWVudCBsZXZlbCBzZXR0aW5ncyAoZGF0YSBhYm91dCB0aGUgbG9hZGVkIGFzc2lnbm1lbnQsIHVzZXIsIHN1Ym1pc3Npb24sIGV0Yy4pXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN1Ym1pc3Npb24gLSBJbmNsdWRlcyB0aGUgc291cmNlIGNvZGUgb2YgYW55IHByb2dyYW1zIHRvIGJlIGxvYWRlZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24sIGFzc2lnbm1lbnQsIHN1Ym1pc3Npb24pIHtcbiAgICAgICAgdGhpcy5pbml0TW9kZWwoY29uZmlndXJhdGlvbik7XG4gICAgICAgIGlmIChhc3NpZ25tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXNzaWdubWVudChjb25maWd1cmF0aW9uLCBhc3NpZ25tZW50LCBzdWJtaXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRNYWluKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEJsb2NrUHkgb2JqZWN0IGJ5IGluaXRpYWxpemluZyBpdHMgaW50ZXJmYWNlLFxuICAgICAqIG1vZGVsLCBhbmQgY29tcG9uZW50cy5cbiAgICAgKlxuICAgICAqL1xuICAgIGluaXRNYWluKCkge1xuICAgICAgICB0aGlzLmluaXRVdGlsaXRpZXMoKTtcbiAgICAgICAgdGhpcy5pbml0TW9kZWxNZXRob2RzKCk7XG4gICAgICAgIHRoaXMudHVybk9uSGFja3MoKTtcbiAgICAgICAgdGhpcy5pbml0SW50ZXJmYWNlKCk7XG4gICAgICAgIHRoaXMuYXBwbHlNb2RlbCgpO1xuICAgICAgICB0aGlzLmluaXRDb21wb25lbnRzKCk7XG4gICAgICAgIHRoaXMubWFrZUV4dHJhU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGRlZmF1bHQgdmFsdWUgb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gdGhlIGtleSB0byBsb29rIHVwIGEgdmFsdWUgZm9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRWYWx1ZSAtIGlmIHRoZSBrZXkgaXMgbm90IGZvdW5kIGFueXdoZXJlLCB1c2UgdGhpcyB2YWx1ZVxuICAgICAqL1xuICAgIGdldFNldHRpbmcoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uXykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbENvbmZpZ3VyYXRpb25fW2tleV07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sb2NhbFNldHRpbmdzXy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTZXR0aW5nc18uZ2V0KGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZGVsIHRvIGl0cyBkZWZhdWx0cy5cbiAgICAgKlxuICAgICAqIENhdGVnb3JpZXM6XG4gICAgICogICAqIHVzZXI6IHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgdXNlciAoc3RvcmVkIHRvIHNlcnZlcilcbiAgICAgKiAgICogYXNzaWdubWVudDogdmFsdWVzIGZvciB0aGUgY3VycmVudCBhc3NpZ25tZW50IChzdG9yZWQgdG8gc2VydmVyKVxuICAgICAqICAgKiBzdWJtaXNzaW9uOiB2YWx1ZXMgZm9yIHRoZSBjdXJyZW50IHN1Ym1pc3Npb24gKHN0b3JlZCB0byBzZXJ2ZXIpXG4gICAgICogICAqIGRpc3BsYXk6IGZsYWdzIHJlbGF0ZWQgdG8gY3VycmVudCB2aXNpYmlsaXR5IChzdG9yZWQgdG8gbG9jYWxTZXR0aW5ncylcbiAgICAgKiAgICogc3RhdHVzOiBtZXNzYWdlcyByZWxhdGVkIHRvIGN1cnJlbnQgc3RhdHVzIChub3Qgc3RvcmVkKVxuICAgICAqICAgKiBleGVjdXRpb246IHZhbHVlcyByZWxhdGVkIHRvIGxhc3QgcnVuIChub3Qgc3RvcmVkKVxuICAgICAqICAgKiBjb25maWd1cmF0aW9uOiBjb25zdGFudCB2YWx1ZXMgcmVsYXRlZCB0byBzZXR1cCAobm90IHN0b3JlZClcbiAgICAgKi9cbiAgICBpbml0TW9kZWwoY29uZmlndXJhdGlvbikge1xuICAgICAgICAvLyBDb25uZWN0IHRvIGxvY2FsIHN0b3JhZ2VcbiAgICAgICAgdGhpcy5sb2NhbFNldHRpbmdzXyA9IG5ldyBMb2NhbFN0b3JhZ2VXcmFwcGVyKFwibG9jYWxTZXR0aW5nc1wiKTtcbiAgICAgICAgdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl8gPSBjb25maWd1cmF0aW9uO1xuXG4gICAgICAgIHRoaXMubW9kZWwgPSB7XG4gICAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICAgICAgaWQ6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcInVzZXIuaWRcIl0pLFxuICAgICAgICAgICAgICAgIG5hbWU6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcInVzZXIubmFtZVwiXSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciB5b3UgYXJlIGFuIE93bmVyIChjYW4gbW9kaWZ5IHRoZSBhc3NpZ25tZW50KSwgR3JhZGVyIChjYW4gdmlld1xuICAgICAgICAgICAgICAgICAqIHRoZSBhc3NpZ25tZW50cycgaW5mb3JtYXRpb24pIG9yIFN0dWRlbnQgKGNhbiBub3Qgc2VlIGFueSBpbnN0cnVjdG9yIHN0dWZmKS5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByb2xlOiBrby5vYnNlcnZhYmxlKHRoaXMuZ2V0U2V0dGluZyhcInVzZXIucm9sZVwiLCBcIm93bmVyXCIpKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDdXJyZW50IGNvdXJzZSBmb3IgdGhpcyB1c2VyXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY291cnNlSWQ6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcInVzZXIuY291cnNlX2lkXCJdKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDdXJyZW50IGFzc2lnbm1lbnQgZ3JvdXAgdGhhdCB0aGlzIHVzZXIgaXMgaW5zaWRlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ3JvdXBJZDoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1widXNlci5ncm91cF9pZFwiXSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3NpZ25tZW50OiB7XG4gICAgICAgICAgICAgICAgaWQ6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgbmFtZToga28ub2JzZXJ2YWJsZShcIlNjcmF0Y2ggQ2FudmFzXCIpLFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uczoga28ub2JzZXJ2YWJsZShcIldlbGNvbWUgdG8gQmxvY2tQeS4gVHJ5IGVkaXRpbmcgYW5kIHJ1bm5pbmcgdGhlIGNvZGUgYmVsb3cuXCIpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBodW1hbi1mcmllbmRseSBVUkwgdG8gdXNlIGFzIGEgc2hvcnRjdXQgZm9yIHRoaXMgYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHVybDoga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3YXJuaW5nIG1lc3NhZ2UgaWYgbWF6ZVxuICAgICAgICAgICAgICAgIHR5cGU6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgc3RhcnRpbmdDb2RlOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LnN0YXJ0aW5nX2NvZGVcIl0gfHwgXCJcIiksXG4gICAgICAgICAgICAgICAgb25SdW46IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQub25fcnVuXCJdIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50Lm9uX2NoYW5nZVwiXSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICBvbkV2YWw6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQub25fZXZhbFwiXSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICBleHRyYUluc3RydWN0b3JGaWxlczoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICBleHRyYVN0YXJ0aW5nRmlsZXM6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgZm9ya2VkSWQ6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgZm9ya2VkVmVyc2lvbjoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICBvd25lcklkOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIGNvdXJzZUlkOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgdGFnczoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICBzYW1wbGVTdWJtaXNzaW9uczoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICByZXZpZXdlZDoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5yZXZpZXdlZFwiXSksXG4gICAgICAgICAgICAgICAgcHVibGljOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LnB1YmxpY1wiXSksXG4gICAgICAgICAgICAgICAgaGlkZGVuOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LmhpZGRlblwiXSksXG4gICAgICAgICAgICAgICAgaXBSYW5nZXM6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQuaXBfcmFuZ2VzXCJdKSxcbiAgICAgICAgICAgICAgICBzZXR0aW5nczogbWFrZUFzc2lnbm1lbnRTZXR0aW5nc01vZGVsKGNvbmZpZ3VyYXRpb24pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgICAgICAgIGlkOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIGNvZGU6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcInN1Ym1pc3Npb24uY29kZVwiXSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgICBleHRyYUZpbGVzOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIHVybDoga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICBlbmRwb2ludDoga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICBzY29yZToga28ub2JzZXJ2YWJsZSgwKSxcbiAgICAgICAgICAgICAgICBjb3JyZWN0OiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ25tZW50SWQgaW5mZXJyZWQgZnJvbSBhc3NpZ25tZW50LmlkXG4gICAgICAgICAgICAgICAgLy8gY291cnNlSWQgaW5mZXJyZWQgZnJvbSB1c2VyLmNvdXJzZUlkXG4gICAgICAgICAgICAgICAgLy8gdXNlcklkIGluZmVycmVkIGZyb20gdXNlci5pZFxuICAgICAgICAgICAgICAgIC8vIGFzc2lnbm1lbnRWZXJzaW9uIGluZmVycmVkIGZyb20gYXNzaWdubWVudC52ZXJzaW9uXG4gICAgICAgICAgICAgICAgdmVyc2lvbjoga28ub2JzZXJ2YWJsZSgwKSxcbiAgICAgICAgICAgICAgICBzdWJtaXNzaW9uU3RhdHVzOiBrby5vYnNlcnZhYmxlKFwiU3RhcnRlZFwiKSxcbiAgICAgICAgICAgICAgICBncmFkaW5nU3RhdHVzOiBrby5vYnNlcnZhYmxlKFwiTm90UmVhZHlcIiksXG4gICAgICAgICAgICAgICAgb3duZXJJZDoga28ub2JzZXJ2YWJsZShudWxsKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDdXJyZW50bHkgdmlzaWJsZSBGaWxlLCBpZiBhcHBsaWNhYmxlXG4gICAgICAgICAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmaWxlbmFtZToga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBiZSBwcmVzZW50ZWQgd2l0aCB0aGUgaW5zdHJ1Y3RvciBzZXR0aW5ncyBhbmQgZmlsZXNcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpbnN0cnVjdG9yOiBrby5vYnNlcnZhYmxlKFwiXCIrdGhpcy5nZXRTZXR0aW5nKFwiZGlzcGxheS5pbnN0cnVjdG9yXCIsIFwiZmFsc2VcIik9PT1cInRydWVcIiksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gcHJldmVudCB0aGUgcHJpbnRlciBmcm9tIHNob3dpbmcgdGhpbmdzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbXV0ZVByaW50ZXI6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIChQeXRob24gVmlld3MpIFRoZSBjdXJyZW50IGVkaXRvciBtb2RlLlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtEaXNwbGF5TW9kZXN9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcHl0aG9uTW9kZToga28ub2JzZXJ2YWJsZSh0aGlzLmdldFNldHRpbmcoXCJkaXNwbGF5LnB5dGhvbi5tb2RlXCIsIERpc3BsYXlNb2Rlcy5TUExJVCkpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IEhpc3RvcnkgbW9kZSBpcyBlbmdhZ2VkLlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGhpc3RvcnlNb2RlOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBiZSBhdXRvLXNhdmluZyBjaGFuZ2VzIGluIFB5dGhvbiBlZGl0b3JcbiAgICAgICAgICAgICAgICAgKiBJZiBhbiBpbnRlZ2VyLCBzcGVjaWZpZXMgdGhlIGRlbGF5IHRoYXQgc2hvdWxkIGJlIHVzZWQgKG1pY3Jvc2Vjb25kcykuXG4gICAgICAgICAgICAgICAgICogVGhpcyBpcyBuZXZlciBvbiBpbiBub24tUHl0aG9uIGVkaXRvcnMuXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2x8aW50fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGF1dG9TYXZlOiBrby5vYnNlcnZhYmxlKHRydWUpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBjb25zb2xlIGlzIGZ1bGwgd2lkdGggYW5kIGZlZWRiYWNrIGlzIGhpZGRlblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGJpZ0NvbnNvbGU6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBoZWlnaHQgdG8gdXNlIGZvciB0aGUgY29uc29sZS5cbiAgICAgICAgICAgICAgICAgKiAgICBJZiBudWxsLCB0aGVuIGxldCB0aGUgaGVpZ2h0IHJlbWFpbiB1bmNoYW5nZWRcbiAgICAgICAgICAgICAgICAgKiAgICBJZiBhIG51bWJlciwgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwcmV2aW91c0NvbnNvbGVIZWlnaHQ6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgY3VycmVudENvbnNvbGVIZWlnaHQ6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hpY2ggcGFuZWwgdG8gc2hvdyBpbiB0aGUgc2Vjb25kIHJvdydzIHNlY29uZCBjb2x1bW5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7U2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNlY29uZFJvd1NlY29uZFBhbmVsOiBrby5vYnNlcnZhYmxlKFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5GRUVEQkFDSyksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gYmUgdHJhY2luZyB0aGUgY29kZSByaWdodCBub3dcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0cmFjZUV4ZWN1dGlvbjoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGxpc3Qgb2YgcHJvbWlzZXMgdG8gc3RpbGwgcmVzb2x2ZSB3aGlsZSBsb2FkaW5nIGRhdGFzZXRzXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5PFByb21pc2U+fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGxvYWRpbmdEYXRhc2V0czoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgdGVtcG9yYXJ5IGNoYW5nZWQgdmFsdWUgb2YgdGhlIGluc3RydWN0aW9ucyBoYXZlIGJlZW4gY2hhbmdlZCBmcm9tIHdoYXQgaXMgaW4gdGhlIGFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjaGFuZ2VkSW5zdHJ1Y3Rpb25zOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEEgaG9sZGVyIGZvciB0aGUgdGltZXIgdG8gdHJpZ2dlciBvbi1jaGFuZ2VzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdHJpZ2dlck9uQ2hhbmdlOiBudWxsLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlIGN1cnJlbnQgZmVlZGJhY2sgYW5kIG91dHB1dCBjb3JyZXNwb25kcyB0byB0aGUgY3VycmVudCBzdWJtaXNzaW9uLlxuICAgICAgICAgICAgICAgICAqIFRoaXMgd291bGQgYmUgZmFsc2UgaWYgdGhlcmUgaXMgbm8gZmVlZGJhY2svb3V0cHV0IChpLmUuLCBjb2RlIGhhcyBub3QgYmVlbiBydW4pLFxuICAgICAgICAgICAgICAgICAqIG9yIGlmIHRoZSB1c2VyIGhhcyBtb2RpZmllZCB0aGUgc3VibWlzc2lvbiBhZnRlciB0aGUgbGFzdCBydW4gKGUuZy4sIGJ5IGVkaXRpbmdcbiAgICAgICAgICAgICAgICAgKiB0aGUgdGV4dCkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGlydHlTdWJtaXNzaW9uOiBrby5vYnNlcnZhYmxlKHRydWUpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqICBXaGV0aGVyIG9yIG5vdCB0byBtYWtlIHRoZSBCbG9ja1B5IGVsZW1lbnQgaW4gRlVMTCBTQ1JFRU4gbW9kZS4gU2FkbHksIG5vdCBmdWxsc2NyZWVuXG4gICAgICAgICAgICAgICAgICogIHdpdGhpbiB0aGUgd2luZG93LCBidXQgRlVMTCBTQ1JFRU4uIFZlcnkgYWdncmVzc2l2ZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdWxsc2NyZWVuOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBVc2VyLXN1cHBsaWVkIHBhc3Njb2RlIHRvIGNvbXBhcmUgb24gdGhlIHNlcnZlciBhZ2FpbnN0IHRoZSBjdXJyZW50IHBhc3Njb2RlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHBhc3Njb2RlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGNsZWFyIG91dCBpbnB1dHMgYWZ0ZXIgYSBydW4vb25fcnVuIGN5Y2xlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2xlYXJJbnB1dHM6IGtvLm9ic2VydmFibGUodHJ1ZSksXG4gICAgICAgICAgICAgICAgZWRpdG9yVmVyc2lvbjogRURJVE9SX1ZFUlNJT04sXG4gICAgICAgICAgICAgICAgcmVhZE9ubHk6IGtvLm9ic2VydmFibGUodGhpcy5nZXRTZXR0aW5nKFwiZGlzcGxheS5yZWFkX29ubHlcIiwgXCJmYWxzZVwiKS50b1N0cmluZygpPT09XCJ0cnVlXCIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgbG9hZEFzc2lnbm1lbnQ6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIGxvYWRBc3NpZ25tZW50TWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGxvYWRIaXN0b3J5OiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBsb2FkSGlzdG9yeU1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBsb2FkRmlsZToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgbG9hZEZpbGVNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgbG9hZERhdGFzZXQ6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIGxvYWREYXRhc2V0TWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGxvZ0V2ZW50OiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBsb2dFdmVudE1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBzYXZlSW1hZ2U6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHNhdmVJbWFnZU1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBzYXZlRmlsZToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGVNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgc2F2ZUFzc2lnbm1lbnQ6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHNhdmVBc3NpZ25tZW50TWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIHVwZGF0ZVN1Ym1pc3Npb246IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVN1Ym1pc3Npb25NZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgdXBkYXRlU3VibWlzc2lvblN0YXR1czoga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgdXBkYXRlU3VibWlzc2lvblN0YXR1c01lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBvbkV4ZWN1dGlvbjoga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhlY3V0aW9uOiB7XG4gICAgICAgICAgICAgICAgLy8gSW5mb3JtYXRpb24gYWJvdXQgaW4tcHJvZ3Jlc3MgZXhlY3V0aW9uc1xuICAgICAgICAgICAgICAgIHJlcG9ydHM6IHt9LFxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgT3V0cHV0IG9iamVjdHNcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgLy8gTGlzdCBvZiBpbnB1dHRlZCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgaW5wdXRJbmRleDoga28ub2JzZXJ2YWJsZSgwKSxcbiAgICAgICAgICAgICAgICAvLyBJbmZvcm1hdGlvbiByZWxhdGVkIHRvIGEgc3R1ZGVudCBydW5cbiAgICAgICAgICAgICAgICBzdHVkZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cjogdGhlIGZpbGVuYW1lIHRoYXQgd2FzIGxhc3QgZXhlY3V0ZWQgYW5kIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGVzZSByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGVwOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBsYXN0TGluZToga28ub2JzZXJ2YWJsZSgwKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgb2Ygc2ltcGxlIG9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYWNlRGF0YToga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2VTdGVwOiBrby5vYnNlcnZhYmxlKDApLFxuICAgICAgICAgICAgICAgICAgICAvLyBBY3R1YWwgZXhlY3V0aW9uIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsczoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbHM6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbHM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN5c21vZHVsZXM6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gSW5mb3JtYXRpb24gcmVsYXRlZCB0byBmZWVkYmFjayBmcm9tIHRoZSBpbnN0cnVjdG9yIHJ1blxuICAgICAgICAgICAgICAgIGZlZWRiYWNrOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0ciAobWFya2Rvd24pXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJSZWFkeVwiKSxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW46IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICBsaW5lc0Vycm9yOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgICAgICBsaW5lc1VuY292ZXJlZDoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3VsdHMgb2YgdGhlIGxhc3QgZXhlY3V0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IG51bGwsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRnVuY3Rpb25zIHRvIGZpcmUgd2hlbiBjZXJ0YWluIGV2ZW50cyBvY2N1clxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogV2hlbiB0aGUgc3R1ZGVudCBnZXRzIGEgc3VjY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgXCJzdWNjZXNzXCI6IHRoaXMuaW5pdGlhbENvbmZpZ3VyYXRpb25fW1wiY2FsbGJhY2suc3VjY2Vzc1wiXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBzZXJ2ZXIgaXMgY29ubmVjdGVkLlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNlcnZlckNvbm5lY3RlZDoga28ub2JzZXJ2YWJsZSh0aGlzLmdldFNldHRpbmcoXCJzZXJ2ZXIuY29ubmVjdGVkXCIsIHRydWUpKSxcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmdcbiAgICAgICAgICAgICAgICBibG9ja2x5UGF0aDogdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl9bXCJibG9ja2x5LnBhdGhcIl0sXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudFBvaW50OiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uX1tcImF0dGFjaG1lbnQucG9pbnRcIl0sXG4gICAgICAgICAgICAgICAgLy8gSlF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICAgICAgICAgICAgICAvLyBNYXBzIGNvZGVzICgnbG9nX2V2ZW50JywgJ3NhdmVfY29kZScpIHRvIFVSTHNcbiAgICAgICAgICAgICAgICB1cmxzOiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uX1tcInVybHNcIl0gfHwge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgaW50ZXJmYWNlXG4gICAgICovXG4gICAgaW5pdEludGVyZmFjZSgpIHtcbiAgICAgICAgbGV0IGNvbnN0YW50cyA9IHRoaXMubW9kZWwuY29uZmlndXJhdGlvbjtcbiAgICAgICAgbGV0IGd1aSA9IG1ha2VJbnRlcmZhY2UodGhpcyk7XG4gICAgICAgIGNvbnN0YW50cy5jb250YWluZXIgPSAkKGNvbnN0YW50cy5hdHRhY2htZW50UG9pbnQpLmh0bWwoJChndWkpKTtcbiAgICB9O1xuXG4gICAgbG9hZEFzc2lnbm1lbnQoYXNzaWdubWVudF9pZCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuc2VydmVyLmxvYWRBc3NpZ25tZW50KGFzc2lnbm1lbnRfaWQpO1xuICAgIH1cblxuICAgIGxvYWRUYWdzKHRhZ3MpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBhIEpTT04gbGlzdCByZXByZXNlbnRpbmcgdGFnc1xuICAgIH1cblxuICAgIGxvYWRTYW1wbGVTdWJtaXNzaW9ucyhzYW1wbGVzKSB7XG4gICAgICAgIC8vIEFscmVhZHkgYSBKU09OIGxpc3QgcmVwcmVzZW50aW5nIHNhbXBsZXNcbiAgICB9XG5cbiAgICBsb2FkTm9TdWJtaXNzaW9uKGFzc2lnbm1lbnQpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoYXNzaWdubWVudC5zdGFydGluZ19jb2RlKTtcbiAgICAgICAgbG9hZENvbmNhdGVuYXRlZEZpbGUoYXNzaWdubWVudC5leHRyYV9zdGFydGluZ19maWxlcywgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMpO1xuICAgIH1cblxuICAgIGxvYWRTdWJtaXNzaW9uKHN1Ym1pc3Npb24sIGFzc2lnbm1lbnQpIHtcbiAgICAgICAgaWYgKCFzdWJtaXNzaW9uKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBTY2FyaWVyIFwiWW91IGFyZSBub3QgbG9nZ2VkIGluIG1lc3NhZ2VcIlxuICAgICAgICAgICAgdGhpcy5sb2FkTm9TdWJtaXNzaW9uKGFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFdoYXQgaWYgc3VibWlzc2lvbnMnIGFzc2lnbm1lbnQgdmVyc2lvbiBhbmQgdGhlIGFzc2lnbm1lbnRzJyB2ZXJzaW9uIGNvbmZsaWN0P1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uaWQoc3VibWlzc2lvbi5pZCk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5jb2RlKHN1Ym1pc3Npb24uY29kZSk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KHN1Ym1pc3Npb24uY29ycmVjdCk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5zY29yZShzdWJtaXNzaW9uLnNjb3JlKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmVuZHBvaW50KHN1Ym1pc3Npb24uZW5kcG9pbnQpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24udXJsKHN1Ym1pc3Npb24udXJsKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLnZlcnNpb24oc3VibWlzc2lvbi52ZXJzaW9uKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmdyYWRpbmdTdGF0dXMoc3VibWlzc2lvbi5ncmFkaW5nX3N0YXR1cyk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5zdWJtaXNzaW9uU3RhdHVzKHN1Ym1pc3Npb24uc3VibWlzc2lvbl9zdGF0dXMpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24ub3duZXJJZChzdWJtaXNzaW9uLnVzZXJfaWQpO1xuICAgICAgICB0aGlzLm1vZGVsLnVzZXIuY291cnNlSWQoc3VibWlzc2lvbi5jb3Vyc2VfaWQpO1xuICAgICAgICBsb2FkQ29uY2F0ZW5hdGVkRmlsZShzdWJtaXNzaW9uLmV4dHJhX2ZpbGVzLCB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcyk7XG4gICAgfVxuXG4gICAgbG9hZEFzc2lnbm1lbnREYXRhXyhkYXRhKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICB0aGlzLnJlc2V0SW50ZXJmYWNlKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5maWxlU3lzdGVtLmRpc21vdW50RXh0cmFGaWxlcygpO1xuICAgICAgICBsZXQgd2FzU2VydmVyQ29ubmVjdGVkID0gdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLnNlcnZlckNvbm5lY3RlZCgpO1xuICAgICAgICB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb24uc2VydmVyQ29ubmVjdGVkKGZhbHNlKTtcbiAgICAgICAgbGV0IGFzc2lnbm1lbnQgPSBkYXRhLmFzc2lnbm1lbnQ7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5pZChhc3NpZ25tZW50LmlkKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnZlcnNpb24oYXNzaWdubWVudC52ZXJzaW9uKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmNvdXJzZUlkKGFzc2lnbm1lbnQuY291cnNlX2lkKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmZvcmtlZElkKGFzc2lnbm1lbnQuZm9ya2VkX2lkKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmZvcmtlZFZlcnNpb24oYXNzaWdubWVudC5mb3JrZWRfdmVyc2lvbik7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5oaWRkZW4oYXNzaWdubWVudC5oaWRkZW4pO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQucmV2aWV3ZWQoYXNzaWdubWVudC5yZXZpZXdlZCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5wdWJsaWMoYXNzaWdubWVudC5wdWJsaWMpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQudHlwZShhc3NpZ25tZW50LnR5cGUpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQudXJsKGFzc2lnbm1lbnQudXJsKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmlwUmFuZ2VzKGFzc2lnbm1lbnQuaXBfcmFuZ2VzKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50Lmluc3RydWN0aW9ucyhhc3NpZ25tZW50Lmluc3RydWN0aW9ucyk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5uYW1lKGFzc2lnbm1lbnQubmFtZSk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZShhc3NpZ25tZW50Lm9uX2NoYW5nZSB8fCBudWxsKTtcbiAgICAgICAgaWYgKGFzc2lnbm1lbnQub25fY2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKFwiIW9uX2NoYW5nZS5weVwiLCBhc3NpZ25tZW50Lm9uX2NoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbChhc3NpZ25tZW50Lm9uX2V2YWwgfHwgbnVsbCk7XG4gICAgICAgIGlmIChhc3NpZ25tZW50Lm9uX2V2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUoXCIhb25fZXZhbC5weVwiLCBhc3NpZ25tZW50Lm9uX2V2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5vblJ1bihhc3NpZ25tZW50Lm9uX3J1bik7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5zdGFydGluZ0NvZGUoYXNzaWdubWVudC5zdGFydGluZ19jb2RlKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50Lm93bmVySWQoYXNzaWdubWVudC5vd25lcl9pZCk7XG4gICAgICAgIHRoaXMubG9hZFRhZ3MoYXNzaWdubWVudC50YWdzKTtcbiAgICAgICAgdGhpcy5sb2FkU2FtcGxlU3VibWlzc2lvbnMoYXNzaWdubWVudC5zYW1wbGVfc3VibWlzc2lvbnMpO1xuICAgICAgICBsb2FkQ29uY2F0ZW5hdGVkRmlsZShhc3NpZ25tZW50LmV4dHJhX2luc3RydWN0b3JfZmlsZXMsIHRoaXMubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyk7XG4gICAgICAgIGxvYWRDb25jYXRlbmF0ZWRGaWxlKGFzc2lnbm1lbnQuZXh0cmFfc3RhcnRpbmdfZmlsZXMsIHRoaXMubW9kZWwuYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMpO1xuICAgICAgICBsb2FkQXNzaWdubWVudFNldHRpbmdzKHRoaXMubW9kZWwsIGFzc2lnbm1lbnQuc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLmxvYWRTdWJtaXNzaW9uKGRhdGEuc3VibWlzc2lvbiwgYXNzaWdubWVudCk7XG4gICAgICAgIHRoaXMubW9kZWwuZGlzcGxheS5kaXJ0eVN1Ym1pc3Npb24odHJ1ZSk7XG4gICAgICAgIHRoaXMubW9kZWwuZGlzcGxheS5jaGFuZ2VkSW5zdHJ1Y3Rpb25zKG51bGwpO1xuICAgICAgICB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb24uc2VydmVyQ29ubmVjdGVkKHdhc1NlcnZlckNvbm5lY3RlZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5jb3JnaXMubG9hZERhdGFzZXRzKHRydWUpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLnJlZnJlc2goKTtcblxuICAgICAgICB0aGlzLmNvbXBvbmVudHMuc2VydmVyLnNldFN0YXR1cyhcInNhdmVGaWxlXCIsIFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICB9XG5cbiAgICBpbml0TW9kZWxNZXRob2RzKCkge1xuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIG1vZGVsLnVpID0ge1xuICAgICAgICAgICAgcm9sZToge1xuICAgICAgICAgICAgICAgIGlzR3JhZGVyOiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC51c2VyLnJvbGUoKSA9PT0gXCJvd25lclwiIHx8IG1vZGVsLnVzZXIucm9sZSgpID09PSBcImdyYWRlclwiKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc3RydWN0aW9uczoge1xuICAgICAgICAgICAgICAgIGlzQ2hhbmdlZDoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuY2hhbmdlZEluc3RydWN0aW9ucygpICE9PSBudWxsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwudWkuaW5zdHJ1Y3Rpb25zLmlzQ2hhbmdlZCgpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXRpbGl0aWVzLm1hcmtkb3duKG1vZGVsLmRpc3BsYXkuY2hhbmdlZEluc3RydWN0aW9ucygpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnV0aWxpdGllcy5tYXJrZG93bihtb2RlbC5hc3NpZ25tZW50Lmluc3RydWN0aW9ucygpKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgcmVzZXQ6ICgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuY2hhbmdlZEluc3RydWN0aW9ucyhudWxsKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lbnU6IHtcbiAgICAgICAgICAgICAgICB0ZXh0RnVsbHNjcmVlbjoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIChtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4oKSkgPyBcImZhLWNvbXByZXNzLWFycm93cy1hbHRcIiA6IFwiZmEtZXhwYW5kLWFycm93cy1hbHRcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgY2xpY2tGdWxsc2NyZWVuOiAoKSA9PntcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5mdWxsc2NyZWVuKCFtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4oKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlZGl0SW5wdXRzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5kaWFsb2cuRURJVF9JTlBVVFMoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhbk1hcmtTdWJtaXR0ZWQ6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LmhpZGRlbigpIHx8IG1vZGVsLmFzc2lnbm1lbnQucmV2aWV3ZWQoKSB8fFxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmNhbkNsb3NlKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHRleHRNYXJrU3VibWl0dGVkOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwudWkubWVudS5pc0NvbXBsZXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWwudXNlci5ncm91cElkKCkgPyBcIlByb2JsZW0gY2xvc2VkXCIgOiBcIkFzc2lnbm1lbnQgY2xvc2VkXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZWwudWkubWVudS5pc1N1Ym1pdHRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJSZW9wZW4gZm9yIGVkaXRpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlbC5kaXNwbGF5LmRpcnR5U3VibWlzc2lvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJSdW5cIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbW9kZWwuYXNzaWdubWVudC5oaWRkZW4oKSAmJiBtb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3QoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlN1Ym1pdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTdWJtaXQgZWFybHlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGNsaWNrTWFya1N1Ym1pdHRlZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwudWkubWVudS5pc0NvbXBsZXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChcIllvdSBjYW5ub3QgcmVvcGVuIGNsb3NlZCBhc3NpZ25tZW50cy4gQ29udGFjdCBhIGdyYWRlciFcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZWwudWkubWVudS5pc1N1Ym1pdHRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb25TdGF0dXMoXCJpblByb2dyZXNzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGVsLmRpc3BsYXkuZGlydHlTdWJtaXNzaW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5lbmdpbmUuZGVsYXllZFJ1bigpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci51cGRhdGVTdWJtaXNzaW9uU3RhdHVzKFwiU3VibWl0dGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc1N1Ym1pdHRlZDoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIChtb2RlbC5hc3NpZ25tZW50LnJldmlld2VkKCkgfHwgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5jYW5DbG9zZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdWJtaXNzaW9uLnN1Ym1pc3Npb25TdGF0dXMoKS50b0xvd2VyQ2FzZSgpID09PSBcInN1Ym1pdHRlZFwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc0NvbXBsZXRlZDoga28ucHVyZUNvbXB1dGVkKCgpPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3VibWlzc2lvbi5zdWJtaXNzaW9uU3RhdHVzKCkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb21wbGV0ZWRcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgc2hvd1F1ZXVlZElucHV0czoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVRdWV1ZWRJbnB1dHMoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWNvbmRSb3c6IHtcbiAgICAgICAgICAgICAgICBpc0FsbFZpc2libGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAhbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlTWlkZGxlUGFuZWwoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaXNGZWVkYmFja1Zpc2libGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsKCkgPT09IFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5GRUVEQkFDS1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaXNUcmFjZVZpc2libGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsKCkgPT09IFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5UUkFDRVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaXNDb25zb2xlU2hvd1Zpc2libGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC51aS5zZWNvbmRSb3cuaXNGZWVkYmFja1Zpc2libGUoKSB8fCBtb2RlbC51aS5zZWNvbmRSb3cuaXNUcmFjZVZpc2libGUoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgc3dpdGNoTGFiZWw6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCgpICE9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiVmlldyBUcmFjZVwiIDogXCJcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYWR2YW5jZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50UGFuZWwgPSBtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhbmVsKCkgPT09IFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5OT05FKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZWwoU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLkZFRURCQUNLKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UGFuZWwoKSA9PT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLlRSQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZWwoU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLk5PTkUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lbChTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuVFJBQ0UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmVsKFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5OT05FKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uc29sZToge1xuICAgICAgICAgICAgICAgIHNpemU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsKCkgPT09IFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5OT05FID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sLW1kLTEyXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2wtbWQtNlwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBoaWRlRXZhbHVhdGU6IGtvLnB1cmVDb21wdXRlZCggKCk9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVFdmFsdWF0ZSgpIHx8ICFtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5nbG9iYWxzKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKCkgPT09IFN0YXR1c1N0YXRlLkFDVElWRVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmZWVkYmFjazoge1xuICAgICAgICAgICAgICAgIGJhZGdlOiBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmNhdGVnb3J5KCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLW5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5jYXRlZ29yeSgpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLW5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJydW50aW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtcnVudGltZS1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN5bnRheFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLXN5bnRheC1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVkaXRvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLXN5bnRheC1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImludGVybmFsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtaW50ZXJuYWwtZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZW1hbnRpY1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFuYWx5emVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtc2VtYW50aWMtZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmZWVkYmFja1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc3RydWN0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1mZWVkYmFjay1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbXBsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtcHJvYmxlbS1jb21wbGV0ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc3RydWN0aW9uc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLWluc3RydWN0aW9uc1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vIGVycm9yc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLW5vLWVycm9yc1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5leGVjdXRpb24uZmVlZGJhY2suY2F0ZWdvcnkoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlbC5leGVjdXRpb24uZmVlZGJhY2suY2F0ZWdvcnkoKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJydW50aW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUnVudGltZSBFcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN5bnRheFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlN5bnRheCBFcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVkaXRvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVkaXRvciBFcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImludGVybmFsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiSW50ZXJuYWwgRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZW1hbnRpY1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFuYWx5emVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQWxnb3JpdGhtIEVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmVlZGJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdGlvbnNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJJbnN0cnVjdGlvbnNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiSW5jb3JyZWN0IEFuc3dlclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbXBsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQ29tcGxldGVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJubyBlcnJvcnNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBlcnJvcnNcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2U6IHtcbiAgICAgICAgICAgICAgICBoYXM6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VEYXRhKCkgIT09IG51bGxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGxpbmU6IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGVwID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdFN0ZXAgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhY2VEYXRhID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNlRGF0YSB8fCBzdGVwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyB0cmFjZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGVwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJCZWZvcmUgcnVuXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gbGFzdFN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkZpbmlzaGVkIHJ1blwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogd2h5IGFyZSB0aGVzZSBudW1iZXJzIHdvbmt5P1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTGluZSBcIisodHJhY2VEYXRhW3N0ZXBdLmxpbmUtMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBmaXJzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKDApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmFja3dhcmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZpb3VzID0gTWF0aC5tYXgoMCwgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCgpIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAocHJldmlvdXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZm9yd2FyZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IE1hdGgubWluKG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCksIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKG5leHQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGFzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGF0YToga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0U3RlcCA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0cmFjZURhdGEgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhY2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBsYXN0U3RlcDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2VEYXRhW3N0ZXAgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlRGF0YVtzdGVwXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGVzOiB7XG4gICAgICAgICAgICAgICAgdmlzaWJsZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpIHx8ICFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVGaWxlcygpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBoYXNDb250ZW50czogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhbnN3ZXIucHlcIjogcmV0dXJuIG1vZGVsLnN1Ym1pc3Npb24uY29kZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFpbnN0cnVjdGlvbnMubWRcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIW9uX2NoYW5nZS5weVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZSgpICE9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFvbl9ldmFsLnB5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCgpICE9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj9tb2NrX3VybHMuYmxvY2tweVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcygpLnNvbWUoZmlsZSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUoKSA9PT0gXCI/bW9ja191cmxzLmJsb2NrcHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP3Rvb2xib3guYmxvY2tweVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcygpLnNvbWUoZmlsZSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUoKSA9PT0gXCI/dG9vbGJveC5ibG9ja3B5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiF0YWdzLmJsb2NrcHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQudGFncygpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQuc2FtcGxlU3VibWlzc2lvbnMoKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/bW9ja191cmxzLmJsb2NrcHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/dGFncy5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP3NldHRpbmdzLmJsb2NrcHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKHBhdGgpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/dG9vbGJveC5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vcm1hbFRvb2xib3ggPSBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLmJsb2NrRWRpdG9yLlRPT0xCT1hFU1tcIm5vcm1hbFwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxUb29sYm94ID0gSlNPTi5zdHJpbmdpZnkobm9ybWFsVG9vbGJveCwgbnVsbCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShwYXRoLCBub3JtYWxUb29sYm94KTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zYW1wbGVTdWJtaXNzaW9ucyhbU2FtcGxlU3VibWlzc2lvbi5CbGFuaygpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhb25fY2hhbmdlLnB5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZShcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gZml4IGV4dHJhZmlsZXMgZm9yIGluc3RydWN0b3IgYW5kIHN0dWRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhb25fZXZhbC5weVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQub25FdmFsKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGVEaWFsb2coXCJpbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHVkZW50XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZURpYWxvZyhcInN0dWRlbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0YXJ0aW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZURpYWxvZyhcInN0YXJ0aW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKHBhdGgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLmRlbGV0ZUZpbGUobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV4dHJhU3R1ZGVudEZpbGVzOiBvYnNlcnZlQ29uY2F0ZW5hdGVkRmlsZShtb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMpLFxuICAgICAgICAgICAgICAgIGV4dHJhSW5zdHJ1Y3RvckZpbGVzOiBvYnNlcnZlQ29uY2F0ZW5hdGVkRmlsZShtb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKSxcbiAgICAgICAgICAgICAgICBleHRyYVN0YXJ0aW5nRmlsZXM6IG9ic2VydmVDb25jYXRlbmF0ZWRGaWxlKG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFTdGFydGluZ0ZpbGVzKSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RmlsZW5hbWU6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiP21vY2tfdXJscy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlVSTCBEYXRhXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiP3Rvb2xib3guYmxvY2tweVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJUb29sYm94XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aChcIiZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWRpdG9yczoge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IGtvLnB1cmVDb21wdXRlZCggKCk9PlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZWRpdG9ycy5nZXRFZGl0b3IobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdmlldzoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICghbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkgJiYgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlRWRpdG9ycygpKSA/IFwiTm9uZVwiIDpcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5maWxlbmFtZSgpID8gbW9kZWwudWkuZWRpdG9ycy5jdXJyZW50KCkgOiBcIk5vbmVcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1GaWxlLlJlc2V0XCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdWJtaXNzaW9uLmNvZGUobW9kZWwuYXNzaWdubWVudC5zdGFydGluZ0NvZGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcyhtb2RlbC5hc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcygpLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlbmFtZSA9IGZpbGUuZmlsZW5hbWUoKS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VNb2RlbEZpbGUoZmlsZW5hbWUsIGZpbGUuY29udGVudHMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FuU2F2ZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICFtb2RlbC5kaXNwbGF5LmF1dG9TYXZlKCkpLFxuICAgICAgICAgICAgICAgIGNhbkRlbGV0ZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICghbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlRmlsZXMoKSB8fCBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgVU5ERUxFVEFCTEVfRklMRVMuaW5kZXhPZihtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkpID09PSAtMSksXG4gICAgICAgICAgICAgICAgY2FuUmVuYW1lOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgKCFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVGaWxlcygpIHx8IG1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpKSAmJlxuICAgICAgICAgICAgICAgICAgICBVTlJFTkFNQUJMRV9GSUxFUy5pbmRleE9mKG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSkgPT09IC0xKSxcbiAgICAgICAgICAgICAgICB1cGxvYWQ6IHVwbG9hZEZpbGUuYmluZChzZWxmKSxcbiAgICAgICAgICAgICAgICBkb3dubG9hZDogZG93bmxvYWRGaWxlLmJpbmQoc2VsZiksXG4gICAgICAgICAgICAgICAgaW1wb3J0RGF0YXNldDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuY29yZ2lzLm9wZW5EaWFsb2coKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHB5dGhvbjoge1xuICAgICAgICAgICAgICAgICAgICBmdWxsc2NyZWVuOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29kZU1pcnJvciA9IHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0udGV4dEVkaXRvci5jb2RlTWlycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY29kZU1pcnJvci5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTW9kZTogKG5ld01vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLVZpZXcuQ2hhbmdlXCIsIFwiXCIsIFwiXCIsIG5ld01vZGUsIG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUobmV3TW9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpID09PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5vbGRQeXRob25Nb2RlID0gbmV3TW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaXNIaXN0b3J5QXZhaWxhYmxlOiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJsb2FkSGlzdG9yeVwiKSksXG4gICAgICAgICAgICAgICAgICAgIHR1cm5PZmZIaXN0b3J5TW9kZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci51cGRhdGVFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3Iuc2V0UmVhZE9ubHkoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5oaXN0b3J5TW9kZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHR1cm5Pbkhpc3RvcnlNb2RlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvYWRIaXN0b3J5KChyZXNwb25zZSkgPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmhpc3RvcnkubG9hZChyZXNwb25zZS5oaXN0b3J5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5oaXN0b3J5TW9kZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5zZXRSZWFkT25seSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX0xPQURJTkdfSElTVE9SWSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0b2dnbGVIaXN0b3J5TW9kZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnVpLmVkaXRvcnMucHl0aG9uLnR1cm5PZmZIaXN0b3J5TW9kZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC51aS5lZGl0b3JzLnB5dGhvbi50dXJuT25IaXN0b3J5TW9kZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoaXN0b3J5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogKCk9Pnsgc2VsZi5jb21wb25lbnRzLmhpc3RvcnkubW92ZVRvU3RhcnQoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzOiAoKT0+eyBzZWxmLmNvbXBvbmVudHMuaGlzdG9yeS5tb3ZlUHJldmlvdXMoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6ICgpPT57IHNlbGYuY29tcG9uZW50cy5oaXN0b3J5Lm1vdmVOZXh0KCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3N0UmVjZW50OiAoKT0+eyBzZWxmLmNvbXBvbmVudHMuaGlzdG9yeS5tb3ZlVG9Nb3N0UmVjZW50KCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2U6ICgpPT57IHNlbGYuY29tcG9uZW50cy5oaXN0b3J5LnVzZSgpOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICAgICAgICAgIHNhdmU6ICgpID0+IHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIuc2F2ZUFzc2lnbm1lbnQoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2FtcGxlU3VibWlzc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRFZGl0b3I6IChuZXdET00sIGluZGV4LCBuZXdFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWRpdG9yID0gc2VsZi5jb21wb25lbnRzLmVkaXRvcnMuYnlOYW1lKFwiU2FtcGxlIFN1Ym1pc3Npb25zXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmJ1aWxkRWRpdG9yKG5ld0RPTSwgaW5kZXgsIG5ld0VsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleGVjdXRlOiB7XG4gICAgICAgICAgICAgICAgaXNSdW5uaW5nOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKCkgPT09IFN0YXR1c1N0YXRlLkFDVElWRVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgcnVuOiAoKSA9PlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZW5naW5lLmRlbGF5ZWRSdW4oKSxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZTogKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmVuZ2luZS5ldmFsdWF0ZSgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VydmVyOiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiAoZW5kcG9pbnQgPT5cbiAgICAgICAgICAgICAgICAgICAgXCJzZXJ2ZXItc3RhdHVzLVwiICsgbW9kZWwuc3RhdHVzW2VuZHBvaW50XSgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc0VuZHBvaW50Q29ubmVjdGVkOiAoZW5kcG9pbnQpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24uc2VydmVyQ29ubmVjdGVkKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi51cmxzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi51cmxzW2VuZHBvaW50XSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgY2FwaXRhbGl6ZShtb2RlbC5zdGF0dXMubG9hZEFzc2lnbm1lbnRNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5zYXZlQXNzaWdubWVudE1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLmxvYWRIaXN0b3J5TWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMubG9hZEZpbGVNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5zYXZlRmlsZU1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLmxvYWREYXRhc2V0TWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMubG9nRXZlbnRNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5zYXZlSW1hZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLnVwZGF0ZVN1Ym1pc3Npb25NZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy51cGRhdGVTdWJtaXNzaW9uU3RhdHVzTWVzc2FnZSgpIHx8IFwiXCIpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBmb3JjZToge1xuICAgICAgICAgICAgICAgICAgICBsb2FkQXNzaWdubWVudDogKGRhdGEsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xldCBmaWxlSGFuZGxlciA9ICQoXCIuYmxvY2tweS1mb3JjZS1sb2FkLWFzc2lnbm1lbnQtZmlsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhc3NpZ25tZW50Rm9yY2VMb2FkQnV0dG9uID0gJChldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9maWxlSGFuZGxlci5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJChldmVudC50YXJnZXQpLnBhcmVudCgpLmZhZGVPdXQoMTAwKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHVzZXIgdG8gdXBsb2FkIGEgZmlsZSBjb250YWluaW5nIGFuIGFzc2lnbm1lbnQgc3VibWlzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlcyA9IGFzc2lnbm1lbnRGb3JjZUxvYWRCdXR0b25bMF0uZmlsZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFzc2lnbm1lbnRTdWJtaXNzaW9uID0gSlNPTi5wYXJzZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9hZEFzc2lnbm1lbnREYXRhXyhhc3NpZ25tZW50U3VibWlzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIuZmlsZU5hbWUgPSBmaWxlc1swXS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIucmVhZEFzVGV4dChmaWxlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25tZW50Rm9yY2VMb2FkQnV0dG9uLnZhbChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU3VibWlzc2lvbjogKGRhdGEsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb24oc2VsZi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5tb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGV2ZW50LnRhcmdldCkuZmFkZU91dCgxMDApLmZhZGVJbigxMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgbWFrZUV4dHJhSW50ZXJmYWNlU3Vic2NyaXB0aW9ucyhzZWxmLCBtb2RlbCk7XG4gICAgfVxuXG4gICAgdHVybk9uSGFja3MoKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJUT0RPXCIpO1xuICAgICAgICBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL2ltYWdlLmpzXCJdID0gaW1hZ2VNb2R1bGUudG9TdHJpbmcoKTtcbiAgICAgICAgLy9Tay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL21hdHBsb3RsaWIvcHlwbG90L19faW5pdF9fLmpzXCJdID0gbWF0cGxvdGxpYk1vZHVsZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5cyB0aGUgS25vY2tvdXRKUyBiaW5kaW5ncyB0byB0aGUgbW9kZWwsIGluc3RhbnRpYXRpbmcgdGhlIHZhbHVlcyBpbnRvIHRoZVxuICAgICAqIEhUTUwuXG4gICAgICovXG4gICAgYXBwbHlNb2RlbCgpIHtcbiAgICAgICAga28uYXBwbHlCaW5kaW5ncyh0aGlzLm1vZGVsKTtcbiAgICB9XG5cbiAgICBpbml0VXRpbGl0aWVzKCkge1xuICAgICAgICBsZXQgbWFpbiA9IHRoaXM7XG4gICAgICAgIHRoaXMudXRpbGl0aWVzID0ge1xuICAgICAgICAgICAgbWFya2Rvd246ICh0ZXh0KSA9PiB0ZXh0ID8gRWFzeU1ERS5wcm90b3R5cGUubWFya2Rvd24odGV4dCkgOiBcIjxwPjwvcD5cIlxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGluaXRDb21wb25lbnRzKCkge1xuICAgICAgICBsZXQgY29udGFpbmVyID0gdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lcjtcbiAgICAgICAgbGV0IGNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMgPSB7fTtcbiAgICAgICAgbGV0IG1haW4gPSB0aGlzO1xuICAgICAgICAvLyBFYWNoIG9mIHRoZXNlIGNvbXBvbmVudHMgd2lsbCB0YWtlIHRoZSBCbG9ja1B5IGluc3RhbmNlLCBhbmQgcG9zc2libHkgYVxuICAgICAgICAvLyByZWZlcmVuY2UgdG8gdGhlIHJlbGV2YW50IEhUTUwgbG9jYXRpb24gd2hlcmUgaXQgd2lsbCBiZSBlbWJlZGRlZC5cbiAgICAgICAgY29tcG9uZW50cy5kaWFsb2cgPSBuZXcgQmxvY2tQeURpYWxvZyhtYWluLCBjb250YWluZXIuZmluZChcIi5ibG9ja3B5LWRpYWxvZ1wiKSk7XG4gICAgICAgIGNvbXBvbmVudHMuZmVlZGJhY2sgPSBuZXcgQmxvY2tQeUZlZWRiYWNrKG1haW4sIGNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktZmVlZGJhY2tcIikpO1xuICAgICAgICBjb21wb25lbnRzLnRyYWNlID0gbmV3IEJsb2NrUHlUcmFjZShtYWluKTtcbiAgICAgICAgY29tcG9uZW50cy5jb25zb2xlID0gbmV3IEJsb2NrUHlDb25zb2xlKG1haW4sIGNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktY29uc29sZVwiKSk7XG4gICAgICAgIGNvbXBvbmVudHMuZW5naW5lID0gbmV3IEJsb2NrUHlFbmdpbmUobWFpbik7XG4gICAgICAgIGNvbXBvbmVudHMuZmlsZVN5c3RlbSA9IG5ldyBCbG9ja1B5RmlsZVN5c3RlbShtYWluKTtcbiAgICAgICAgY29tcG9uZW50cy5lZGl0b3JzID0gbmV3IEVkaXRvcnMobWFpbiwgY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1lZGl0b3JcIikpO1xuICAgICAgICAvLyBDb252ZW5pZW50IHNob3J0Y3V0IGRpcmVjdGx5IHRvIFB5dGhvbkVkaXRvclxuICAgICAgICBjb21wb25lbnRzLnB5dGhvbkVkaXRvciA9IHRoaXMuY29tcG9uZW50cy5lZGl0b3JzLmJ5TmFtZShcInB5dGhvblwiKTtcbiAgICAgICAgY29tcG9uZW50cy5zZXJ2ZXIgPSBuZXcgQmxvY2tQeVNlcnZlcihtYWluKTtcbiAgICAgICAgY29tcG9uZW50cy5jb3JnaXMgPSBuZXcgQmxvY2tQeUNvcmdpcyhtYWluKTtcbiAgICAgICAgY29tcG9uZW50cy5oaXN0b3J5ID0gbmV3IEJsb2NrUHlIaXN0b3J5KG1haW4sIGNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktaGlzdG9yeS10b29sYmFyXCIpKTtcbiAgICB9XG5cbiAgICBtYWtlRXh0cmFTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICB0aGlzLm1vZGVsLmRpc3BsYXkuY2hhbmdlZEluc3RydWN0aW9ucy5zdWJzY3JpYmUoKGNoYW5nZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLUluc3RydWN0aW9ucy5DaGFuZ2VcIiwgXCJcIiwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCwgXCJpbnN0cnVjdGlvbnMubWRcIik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLm1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoXCJhbnN3ZXIucHlcIik7XG4gICAgfVxuXG4gICAgcmVzZXRJbnRlcmZhY2UoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5lbmdpbmUucmVzZXQoKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0UGFzc2NvZGUoKSB7XG4gICAgICAgIGxldCB1c2VyU3VwcGxpZWRQYXNzY29kZSA9IHByb21wdChcIlBsZWFzZSBlbnRlciB0aGUgcGFzc2NvZGUuXCIpO1xuICAgICAgICB0aGlzLm1vZGVsLmRpc3BsYXkucGFzc2NvZGUodXNlclN1cHBsaWVkUGFzc2NvZGUpO1xuICAgIH1cblxufVxuXG4iLCJpbXBvcnQge2VuY29kZUhUTUx9IGZyb20gXCIuL3V0aWxpdGllc1wiO1xuXG4vKipcbiAqIEV2YWx1YXRlIGJ1dHRvbiBIVE1MIHRlbXBsYXRlXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5jb25zdCBTVEFSVF9FVkFMX0hUTUwgPSBgXG48YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tc20gYnRuLW91dGxpbmUgZmxvYXQtcmlnaHQgYmxvY2tweS1idG4tZXZhbFwiPlxuICAgIEV2YWx1YXRlXG48L2J1dHRvbj5gO1xuXG4vKipcbiAqIEhUTUwgdGVtcGxhdGUgZm9yIGEgbmV3IGxpbmUgaW4gdGhlIGNvbnNvbGUuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5jb25zdCBORVdfQ09OU09MRV9MSU5FX0hUTUwgPSBcIjxkaXY+PC9kaXY+XCI7XG5cbi8qKlxuICogSFRNTCB0ZW1wbGF0ZSBmb3IgdGhlIGVudGlyZSBjb25zb2xlIGFyZWFcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBDT05TT0xFX0hUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz0nY29sLW1kLTYgYmxvY2tweS1wYW5lbCBibG9ja3B5LWNvbnNvbGUnXG4gICAgICAgICAgcm9sZT1cInJlZ2lvblwiIGFyaWEtbGFiZWw9XCJDb25zb2xlXCJcbiAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGFzczogdWkuY29uc29sZS5zaXplXCI+XG4gICAgICAgICAgXG4gICAgICAgIDwhLS0gRmVlZGJhY2svVHJhY2UgVmlzaWJpbGl0eSBDb250cm9sIC0tPlxuICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbidcbiAgICAgICAgICAgICAgICBjbGFzcz0nYnRuIGJ0bi1zbSBidG4tb3V0bGluZS1zZWNvbmRhcnkgZmxvYXQtcmlnaHQgYmxvY2tweS1zaG93LWZlZWRiYWNrJ1xuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuc2Vjb25kUm93LmlzQ29uc29sZVNob3dWaXNpYmxlLCBjbGljazogdWkuc2Vjb25kUm93LmFkdmFuY2VTdGF0ZVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1leWUnPjwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgXG4gICAgICAgIDxzdHJvbmc+Q29uc29sZTo8L3N0cm9uZz5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9J2Jsb2NrcHktcHJpbnRlciBibG9ja3B5LXByaW50ZXItZGVmYXVsdCc+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgPC9kaXY+YDtcblxuLyoqXG4gKiBBbGwgdGhlIHBvc3NpYmxlIHR5cGVzIGZvciBhIGxpbmUgaW4gdGhlIGNvbnNvbGUuXG4gKiBAZW51bVxuICovXG5leHBvcnQgbGV0IENvbnNvbGVMaW5lVHlwZSA9IHtcbiAgICBURVhUOiBcInRleHRcIixcbiAgICBIVE1MOiBcImh0bWxcIixcbiAgICBQTE9UOiBcInBsb3RcIixcbiAgICBJTUFHRTogXCJpbWFnZVwiLFxuICAgIFBZR0FNRTogXCJweWdhbWVcIixcbiAgICBUVVJUTEU6IFwidHVydGxlXCIsXG4gICAgRVZBTDogXCJldmFsXCIsXG4gICAgU1RBUlRfRVZBTDogXCJzdGFydF9ldmFsXCIsXG4gICAgVkFMVUU6IFwidmFsdWVcIixcbiAgICBJTlBVVDogXCJpbnB1dFwiLFxuICAgIFRFU1RfQ0FTRTogXCJ0ZXN0X2Nhc2VcIlxufTtcblxuLyoqXG4gKiBBYnN0cmFjdCB2ZXJzaW9uIG9mIGEgbGluZSBpbiB0aGUgY29uc29sZS4gQWxsIG90aGVyIGNvbnNvbGUgbGluZXNcbiAqIHNob3VsZCBleHRlbmQgdGhpcyBjbGFzcy4gQ3JpdGljYWxseSwgdGhleSBuZWVkIHRvIGltcGxlbWVudCBhIHJlbmRlciBmdW5jdGlvbi5cbiAqL1xuY2xhc3MgQ29uc29sZUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHR5cGUsIGNvbnRlbnQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSBiYWNrIHRvIHRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2UuXG4gICAgICAgICAqIEBjb25zdFxuICAgICAgICAgKiBAdHlwZSB7QmxvY2tQeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXRlZ29yaXplcyB3aGF0IGtpbmQgb2YgbGluZSB0aGlzIGlzICh0ZXh0L2h0bWwvcGxvdC9ldGMuKVxuICAgICAgICAgKiBAdHlwZSB7Q29uc29sZUxpbmVUeXBlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhY3R1YWwgZGF0YSBzdG9yZWQgb24gdGhpcyBsaW5lLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGFkYXRhIGFib3V0IHdoZXJlIHRoZSBsaW5lIG9yaWdpbmF0ZWQgZnJvbSBpbiB0aGUgY29kZS5cbiAgICAgICAgICogQHR5cGUge3tmaWxlbmFtZTogc3RyaW5nLCBsaW5lOiBudW1iZXIsIHN0ZXA6IG51bWJlcn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWdpbiA9IHtcbiAgICAgICAgICAgIGZpbGVuYW1lOiBTay5jdXJyRmlsZW5hbWUsXG4gICAgICAgICAgICBzdGVwOiBtYWluLmNvbXBvbmVudHMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5zdGVwLFxuICAgICAgICAgICAgbGluZTogbWFpbi5jb21wb25lbnRzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIubGluZVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEhUTUwgY29udGVudCBzdG9yZWQgb24gdGhpcyBsaW5lLCBtZWFudCB0byBiZSByZW5kZXJlZFxuICAgICAgICAgKiB0byB0aGUgdXNlci5cbiAgICAgICAgICogQHR5cGUgeyp8alF1ZXJ5LmZuLmluaXR8alF1ZXJ5fEhUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5odG1sID0gJChcIjxkaXY+PC9kaXY+XCIsIHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogIFwiYmxvY2tweS1wcmludGVyLW91dHB1dFwiLFxuICAgICAgICAgICAgXCJkYXRhLWNvbnRhaW5lclwiOiBtYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uYXR0YWNobWVudFBvaW50LFxuICAgICAgICAgICAgXCJkYXRhLXRvZ2dsZVwiOiBcInRvb2x0aXBcIixcbiAgICAgICAgICAgIFwiZGF0YS1wbGFjZW1lbnRcIjogXCJhdXRvXCIsXG4gICAgICAgICAgICBcImRhdGEtc3RlcFwiOiB0aGlzLm9yaWdpbi5zdGVwLFxuICAgICAgICAgICAgXCJ0aXRsZVwiOiBcIlN0ZXAgXCIgKyB0aGlzLm9yaWdpbi5zdGVwICsgXCIsIExpbmUgXCIgKyB0aGlzLm9yaWdpbi5saW5lXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhpcyBsaW5lIHNob3VsZCBiZSB2aXNpYmxlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aXNpYmxlID0gIW1haW4ubW9kZWwuZGlzcGxheS5tdXRlUHJpbnRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFNrdWxwdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbnNvbGUgbGluZSdzIGNvbnRlbnQuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgdG9Ta3VscHQoKSB7XG4gICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KHRoaXMuY29udGVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoaXMgY29uc29sZSBsaW5lIGJ5IGRlbGV0aW5nIGl0cyBIVE1MIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGRlbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5odG1sLnJlbW92ZSgpO1xuICAgIH1cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVUdXJ0bGUgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG4gICAgLy8gVE9ETzogQ2FwdHVyZSB0dXJ0bGUgY29tbWFuZHMgZm9yIHRyYWNpbmcgcHVycG9zZXNcbiAgICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5UVVJUTEUpO1xuICAgICAgICB0aGlzLmh0bWwuYWRkQ2xhc3MoXCJibG9ja3B5LWNvbnNvbGUtdHVydGxlLW91dHB1dFwiKTtcbiAgICB9XG5cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgd2hlcmUucHJlcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgLy90aGlzLmh0bWxbMF0uc2Nyb2xsSW50b1ZpZXcoeyBiZWhhdmlvcjogXCJzbW9vdGhcIiB9KTtcbiAgICAgICAgICAgIHZhciB0b3AgPSB0aGlzLmh0bWwucG9zaXRpb24oKS50b3A7XG4gICAgICAgICAgICAvLyQoJ2h0bWwnKS5zY3JvbGxUb3AodG9wKTtcbiAgICAgICAgICAgICQoXCJodG1sXCIpLnNjcm9sbFRvcCgwKTtcbiAgICAgICAgICAgIC8vdGhpcy5odG1sLnRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVQeWdhbWUgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgc2l6ZSwgZnVsbHNjcmVlbiwgcHlnYW1lT2JqKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5QWUdBTUUpO1xuICAgICAgICB0aGlzLmh0bWwuYWRkQ2xhc3MoXCJibG9ja3B5LWNvbnNvbGUtcHlnYW1lLW91dHB1dFwiKTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5mdWxsc2NyZWVuID0gZnVsbHNjcmVlbjtcbiAgICAgICAgdGhpcy5weWdhbWVPYmogPSBweWdhbWVPYmo7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAvL1NrLm1haW5fY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJteUNhbnZhc1wiKTtcbiAgICB9XG5cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5odG1sLmFwcGVuZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICB3aGVyZS5wcmVwZW5kKHRoaXMuaHRtbCk7XG4gICAgICAgICAgICB2YXIgdG9wID0gdGhpcy5odG1sLnBvc2l0aW9uKCkudG9wO1xuICAgICAgICAgICAgJChcImh0bWxcIikuc2Nyb2xsVG9wKDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgLy8gU3RhcnRzIG9mZiBhcyBhIG5vLW9wXG4gICAgfVxuXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwID0gKCkgPT4ge307XG4gICAgfVxuXG4gICAgZmluYWxpemUoY2xlYW51cEZ1bmN0aW9uLCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xlYW51cCA9ICgpID0+IGNsZWFudXBGdW5jdGlvbih0aGlzLnB5Z2FtZU9iaiwgbGlzdGVuZXJzKTtcbiAgICB9XG5cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVJbWFnZSBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCBjb250ZW50KSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5JTUFHRSwgY29udGVudCk7XG4gICAgICAgIHRoaXMuaHRtbC5hZGRDbGFzcyhcImJsb2NrcHktY29uc29sZS1pbWFnZS1vdXRwdXRcIik7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICB0aGlzLmh0bWwuYXBwZW5kKHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIC8vdGhpcy5odG1sLnRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVQbG90IGV4dGVuZHMgQ29uc29sZUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIGNvbnRlbnQpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLlBMT1QsIGNvbnRlbnQpO1xuICAgICAgICB0aGlzLmh0bWwuYWRkQ2xhc3MoXCJibG9ja3B5LWNvbnNvbGUtcGxvdC1vdXRwdXRcIik7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIHdoZXJlLmFwcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgLy90aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZVRleHQgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG5cbiAgICBhZGRDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gdGhpcy5jb250ZW50ICsgY29udGVudDtcbiAgICB9XG5cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgbGV0IGVuY29kZWRUZXh0ID0gZW5jb2RlSFRNTCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKCFlbmNvZGVkVGV4dCB8fCBlbmNvZGVkVGV4dC50cmltKCkubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgICAgICBlbmNvZGVkVGV4dCA9IFwiXFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGluZURhdGEgPSAkKFwiPHNhbXA+PC9zYW1wPlwiLCB7IFwiaHRtbFwiOiBlbmNvZGVkVGV4dCB9KTtcbiAgICAgICAgICAgIHRoaXMuaHRtbC5hcHBlbmQobGluZURhdGEpO1xuICAgICAgICAgICAgd2hlcmUuYXBwZW5kKHRoaXMuaHRtbCk7XG4gICAgICAgICAgICB0aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZVZhbHVlIGV4dGVuZHMgQ29uc29sZUxpbmUge1xuXG4gICAgY29uc3RydWN0b3IobWFpbiwgY29udGVudCkge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuVkFMVUUsIGNvbnRlbnQpO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICBsZXQgZW5jb2RlZFRleHQgPSBlbmNvZGVIVE1MKHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICBsZXQgbGluZURhdGEgPSAkKFwiPGNvZGU+PC9jb2RlPlwiLCB7IFwiaHRtbFwiOiBlbmNvZGVkVGV4dCB9KTtcbiAgICAgICAgICAgIHRoaXMuaHRtbC5hcHBlbmQobGluZURhdGEpO1xuICAgICAgICAgICAgd2hlcmUuYXBwZW5kKHRoaXMuaHRtbCk7XG4gICAgICAgICAgICB0aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZUlucHV0IGV4dGVuZHMgQ29uc29sZUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHByb21wdE1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLklOUFVULCBwcm9tcHRNZXNzYWdlKTtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIElucHV0IGJveCBmb3IgcmVjZWl2aW5nIGlucHV0KCkgZnJvbSB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqL1xuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICAvLyBQZXJmb3JtIGFueSBuZWNlc3NhcnkgY2xlYW5pbmdcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgLy8gSW5wdXQgZm9ybVxuICAgICAgICAgICAgbGV0IGlucHV0Rm9ybSA9ICQoXCI8aW5wdXQgdHlwZT0ndGV4dCcgLz5cIik7XG4gICAgICAgICAgICAvLyBFbnRlciBidXR0b25cbiAgICAgICAgICAgIGxldCBpbnB1dEJ0biA9ICQoXCI8YnV0dG9uPjwvYnV0dG9uPlwiLCB7XCJodG1sXCI6IFwiRW50ZXJcIn0pO1xuICAgICAgICAgICAgLy8gR3JvdXAgZm9ybSBhbmQgYnV0dG9uXG4gICAgICAgICAgICBsZXQgaW5wdXRHcm91cCA9ICQoXCI8ZGl2PjwvZGl2PlwiLCB7XCJjbGFzc1wiOiBcImJsb2NrcHktY29uc29sZS1pbnB1dFwifSk7XG4gICAgICAgICAgICBpbnB1dEdyb3VwLmFwcGVuZChpbnB1dEZvcm0pO1xuICAgICAgICAgICAgaW5wdXRHcm91cC5hcHBlbmQoaW5wdXRCdG4pO1xuICAgICAgICAgICAgLy8gUHJvbXB0IGJveCwgbmV3IGxpbmUsIGlucHV0IGdyb3VwXG4gICAgICAgICAgICBsZXQgaW5wdXRCb3ggPSAkKFwiPGRpdj48L2Rpdj5cIik7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50ICE9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuY29kZWRUZXh0ID0gZW5jb2RlSFRNTCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGxldCBpbnB1dE1zZyA9ICQoXCI8c2FtcD48L3NhbXA+XCIsICB7XCJodG1sXCI6IGVuY29kZWRUZXh0fSk7XG4gICAgICAgICAgICAgICAgaW5wdXRCb3guYXBwZW5kKGlucHV0TXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0Qm94LmFwcGVuZCgkKFwiPGJyPlwiKSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kKGlucHV0R3JvdXApO1xuICAgICAgICAgICAgLy8gUmVuZGVyXG4gICAgICAgICAgICB0aGlzLmh0bWwuYXBwZW5kKGlucHV0Qm94KTtcbiAgICAgICAgICAgIHdoZXJlLmFwcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgLy8gTWFrZSBpdCBpbnRlcmFjdGl2ZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZUludGVyYWN0aXZlKGlucHV0Rm9ybSwgaW5wdXRCdG4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH07XG5cbiAgICBtYWtlSW50ZXJhY3RpdmUoaW5wdXQsIGJ1dHRvbikge1xuICAgICAgICBsZXQgcmVzb2x2ZU9uQ2xpY2s7XG4gICAgICAgIGxldCBzdWJtaXR0ZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmVPbkNsaWNrID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBpbnB1dEluZGV4ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dEluZGV4KCk7XG4gICAgICAgIGxldCBzdWJtaXRGb3JtID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHVzZXJJbnB1dHRlZFZhbHVlID0gaW5wdXQudmFsKCk7XG4gICAgICAgICAgICBTay5xdWV1ZWRJbnB1dC5wdXNoKHVzZXJJbnB1dHRlZFZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleChpbnB1dEluZGV4KzEpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCgpLnB1c2godXNlcklucHV0dGVkVmFsdWUpO1xuICAgICAgICAgICAgcmVzb2x2ZU9uQ2xpY2sodXNlcklucHV0dGVkVmFsdWUpO1xuICAgICAgICAgICAgaW5wdXQucHJvcChcImRpc2FibGVkXCIsIHRydWUpO1xuICAgICAgICAgICAgYnV0dG9uLnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH07XG4gICAgICAgIGJ1dHRvbi5jbGljayhzdWJtaXRGb3JtKTtcbiAgICAgICAgaW5wdXQua2V5dXAoKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgc3VibWl0Rm9ybSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgaWYgKGlucHV0SW5kZXggPCB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgdXNlcklucHV0dGVkVmFsdWUgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KClbaW5wdXRJbmRleF07XG4gICAgICAgICAgICBpbnB1dC52YWwodXNlcklucHV0dGVkVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dEluZGV4KGlucHV0SW5kZXgrMSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBpbnB1dC5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnV0dG9uLnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodXNlcklucHV0dGVkVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Ym1pdHRlZFByb21pc2U7XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZUV2YWx1YXRlIGV4dGVuZHMgQ29uc29sZUxpbmVJbnB1dCB7XG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICBzdXBlcihtYWluLCBcIkV2YWx1YXRlOlwiKTtcbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lU3RhcnRFdmFsdWF0ZSBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5TVEFSVF9FVkFMKTtcbiAgICAgICAgdGhpcy5odG1sLmFwcGVuZCgkKFNUQVJUX0VWQUxfSFRNTCkpO1xuICAgICAgICB0aGlzLmh0bWwuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnVpLmV4ZWN1dGUuZXZhbHVhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCbG9ja1B5Q29uc29sZSB7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgZm9yIG1hbmFnaW5nIHRoZSBjb25zb2xlLCB3aXRoIGZlYXR1cmVzIGZvciB0aGluZ3MgbGlrZSBwcmludGluZywgcGxvdHRpbmcsIGV2YWxpbmcsIGlucHV0aW5nLlxuICAgICAqIFRoZSBcInByaW50ZXJcIiBpcyB0aGUgcmVnaW9uIHdoZXJlIHdlIHB1dCB0aGluZ3MsIGFzIG9wcG9zZWQgdG8gdGhlIGNvbnNvbGUgYXMgYSB3aG9sZS5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZyAtIFRoZSBIVE1MIG9iamVjdCB0aGlzIGlzIGF0dGFjaGVkIHRvLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMucHJpbnRlclRhZyA9IHRhZy5maW5kKFwiLmJsb2NrcHktcHJpbnRlclwiKTtcblxuICAgICAgICB0aGlzLk1JTklNVU1fV0lEVEggPSAyMDA7XG4gICAgICAgIHRoaXMuTUlOSU1VTV9IRUlHSFQgPSAyMDA7XG4gICAgICAgIHRoaXMuREVGQVVMVF9IRUlHSFQgPSB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCk7IC8vIExldCBDU1MgZGVmaW5lIHRoaXNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHJldmlvdXNDb25zb2xlSGVpZ2h0KHRoaXMuREVGQVVMVF9IRUlHSFQpO1xuXG4gICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5vdXRwdXQ7XG4gICAgICAgIC8vdGhpcy5pbnB1dCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgIC8vIFRPRE86IElmIHRoZSB1c2VyIG1vZGlmaWVzIGEgZmlsZSwgdGhlbiBtYWtlIHRoZSBjb25zb2xlIGxvb2sgZmFkZWQgYSBsaXR0bGVcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHN0YXR1cyBvZiB0aGUgcHJpbnRlciwgaW5jbHVkaW5nIHJlbW92aW5nIGFueSB0ZXh0IGluIGl0IGFuZFxuICAgICAqIGZpeGluZyBpdHMgc2l6ZS5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgdGhpcy5saW5lQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wbG90QnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmludGVyVGFnLmVtcHR5KCk7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGhhc24ndCBjaGFuZ2VkIHRoZSBjb25zb2xlIHNpemUsIHdlJ2xsIHJlc2V0IGl0XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQoKSA9PT0gdGhpcy5wcmludGVyVGFnLmhlaWdodCgpKSB7XG4gICAgICAgICAgICB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KHRoaXMuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHJldmlvdXNDb25zb2xlSGVpZ2h0KHRoaXMucHJpbnRlclRhZy5oZWlnaHQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnR1cnRsZUxpbmUgPSBudWxsO1xuICAgICAgICBTay5UdXJ0bGVHcmFwaGljcyA9IHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5nZXRUdXJ0bGVMaW5lLmJpbmQodGhpcyksXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmdldEhlaWdodCgpLFxuICAgICAgICAgICAgYXNzZXRzOiB0aGlzLmxvYWRBc3NldC5iaW5kKHRoaXMpXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5weWdhbWVMaW5lID0gbnVsbDtcbiAgICB9O1xuXG4gICAgbG9hZEFzc2V0KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgZ2V0VHVydGxlTGluZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudHVydGxlTGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50dXJ0bGVMaW5lID0gbmV3IENvbnNvbGVMaW5lVHVydGxlKHRoaXMubWFpbik7XG4gICAgICAgICAgICB0aGlzLnR1cnRsZUxpbmUucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBoYXNuJ3QgY2hhbmdlZCB0aGUgY29uc29sZSBzaXplLCB3ZSdsbCBkbyBzb1xuICAgICAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnByZXZpb3VzQ29uc29sZUhlaWdodCgpID09PSB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFByaW50ZXJEaW1lbnNpb24gPSB0aGlzLnByaW50ZXJUYWcud2lkdGgoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KGN1cnJlbnRQcmludGVyRGltZW5zaW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQodGhpcy5wcmludGVyVGFnLmhlaWdodCgpKTtcbiAgICAgICAgICAgICAgICBTay5UdXJ0bGVHcmFwaGljcy5oZWlnaHQgPSBjdXJyZW50UHJpbnRlckRpbWVuc2lvbi00MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50dXJ0bGVMaW5lLmh0bWxbMF07XG4gICAgfVxuXG4gICAgZmluaXNoVHVydGxlcygpIHtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnNhdmVUdXJ0bGVPdXRwdXQoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHVydGxlTGluZSkge1xuICAgICAgICAgICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnR1cnRsZUxpbmUuaHRtbC5maW5kKFwiY2FudmFzXCIpLmxhc3QoKVswXTtcbiAgICAgICAgICAgICAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgICAgICBsZXQgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGFVcmwgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5zYXZlSW1hZ2UoXCJ0dXJ0bGVfb3V0cHV0XCIsIGRhdGFVcmwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBXaGF0IGlmIHRoZXJlIGFyZSBubyB0dXJ0bGVzIHRvIHNhdmU/XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0dXJ0bGVzIHNob3VsZCBiZSBiYXNlZCBvbiB0aGUgY3VycmVudCB3aWR0aFxuICAgIG5ld1R1cnRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLk1JTklNVU1fV0lEVEgsIHRoaXMucHJpbnRlclRhZy53aWR0aCgpLTQwKTtcbiAgICB9XG5cbiAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLk1JTklNVU1fSEVJR0hULCB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCkrNDApO1xuICAgIH1cblxuICAgIGlzTXV0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5tdXRlUHJpbnRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgZWFjaCBwcmludGVkIGVsZW1lbnQgaW4gdGhlIHByaW50ZXIgYW5kIG1ha2VzIGl0IGhpZGRlblxuICAgICAqIG9yIHZpc2libGUsIGRlcGVuZGluZyBvbiB3aGF0IHN0ZXAgd2UncmUgb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcCAtIFRoZSBjdXJyZW50IHN0ZXAgb2YgdGhlIGV4ZWN1dGVkIHByb2dyYW0gdGhhdCB3ZSdyZSBvbjsgZWFjaCBlbGVtZW50IGluIHRoZSBwcmludGVyIG11c3QgYmUgbWFya2VkIHdpdGggYSBcImRhdGEtc3RlcFwiIHByb3BlcnR5IHRvIHJlc29sdmUgdGhpcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcGFnZSAtIERlcHJlY2F0ZWQsIG5vdCBzdXJlIHdoYXQgdGhpcyBldmVuIGRvZXMuXG4gICAgICovXG4gICAgc3RlcFByaW50ZXIoc3RlcCwgcGFnZSkge1xuICAgICAgICB0aGlzLnByaW50ZXJUYWcuZmluZChcIi5ibG9ja3B5LXByaW50ZXItb3V0cHV0XCIpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoJCh0aGlzKS5hdHRyKFwiZGF0YS1zdGVwXCIpIDw9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnNob3coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmludCBhIGxpbmUgdG8gdGhlIG9uLXNjcmVlbiBwcmludGVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lVGV4dCAtIEEgbGluZSBvZiB0ZXh0IHRvIGJlIHByaW50ZWQgb3V0LlxuICAgICAqL1xuICAgIHByaW50KGxpbmVUZXh0KSB7XG4gICAgICAgIC8vIEVtcHR5IHN0cmluZ3MgbWVhbnMgZG8gbm90aGluZy5cbiAgICAgICAgLy8gcHJpbnQoXCJcIiwgZW5kPVwiXCIpXG4gICAgICAgIGlmICghbGluZVRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmx1c2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKGxpbmVUZXh0LmNoYXJBdChsaW5lVGV4dC5sZW5ndGgtMSkgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGZsdXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BsaXRMaW5lcyA9IGxpbmVUZXh0LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICBpZiAodGhpcy5saW5lQnVmZmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVCdWZmZXIgPSBuZXcgQ29uc29sZUxpbmVUZXh0KHRoaXMubWFpbiwgQ29uc29sZUxpbmVUeXBlLlRFWFQsIHNwbGl0TGluZXNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5saW5lQnVmZmVyLmFkZENvbnRlbnQoc3BsaXRMaW5lc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaT0xOyBpIDwgc3BsaXRMaW5lcy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dC5wdXNoKHRoaXMubGluZUJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLmxpbmVCdWZmZXIucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgICAgICB0aGlzLmxpbmVCdWZmZXIgPSBuZXcgQ29uc29sZUxpbmVUZXh0KHRoaXMubWFpbiwgQ29uc29sZUxpbmVUeXBlLlRFWFQsIHNwbGl0TGluZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbHVzaCkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXQucHVzaCh0aGlzLmxpbmVCdWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5saW5lQnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICAgICAgdGhpcy5saW5lQnVmZmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIHBsb3QocGxvdHMpIHtcbiAgICAgICAgdGhpcy5wbG90QnVmZmVyID0gbmV3IENvbnNvbGVMaW5lUGxvdCh0aGlzLm1haW4sIHBsb3RzKTtcbiAgICAgICAgdGhpcy5wbG90QnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICByZXR1cm4gdGhpcy5wbG90QnVmZmVyO1xuICAgIH1cblxuICAgIHB5Z2FtZShzaXplLCBmdWxsc2NyZWVuLCBweWdhbWVPYmopIHtcbiAgICAgICAgaWYgKHRoaXMucHlnYW1lTGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5weWdhbWVMaW5lID0gbmV3IENvbnNvbGVMaW5lUHlnYW1lKHRoaXMubWFpbiwgc2l6ZSwgZnVsbHNjcmVlbiwgcHlnYW1lT2JqKTtcbiAgICAgICAgICAgIHRoaXMucHlnYW1lTGluZS5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5weWdhbWVMaW5lO1xuICAgIH1cblxuICAgIHByaW50UElMSW1hZ2UoaW1hZ2VEYXRhKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVEVTVFwiLCBpbWFnZURhdGEuaW1hZ2UpO1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyID0gbmV3IENvbnNvbGVMaW5lSW1hZ2UodGhpcy5tYWluLCBpbWFnZURhdGEuaW1hZ2UpO1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZUJ1ZmZlcjtcbiAgICB9XG5cbiAgICBwcmludFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGxldCBwcmludGVkVmFsdWUgPSBuZXcgQ29uc29sZUxpbmVWYWx1ZSh0aGlzLm1haW4sIHZhbHVlKTtcbiAgICAgICAgcHJpbnRlZFZhbHVlLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICByZXR1cm4gcHJpbnRlZFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHJlZ2lzdGVycyBhIFByb21pc2UgZnJvbSB0aGUgSW5wdXQgYm94XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb21wdE1lc3NhZ2UgLSBNZXNzYWdlIHRvIGRpc3BsYXkgdG8gdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbnB1dChwcm9tcHRNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuaW5wdXRCdWZmZXIgPSBuZXcgQ29uc29sZUxpbmVJbnB1dCh0aGlzLm1haW4sIHByb21wdE1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dEJ1ZmZlci5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICB9O1xuXG5cbiAgICBldmFsdWF0ZSgpIHtcbiAgICAgICAgdGhpcy5pbnB1dEJ1ZmZlciA9IG5ldyBDb25zb2xlTGluZUV2YWx1YXRlKHRoaXMubWFpbik7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0QnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgIH1cblxuICAgIGJlZ2luRXZhbCgpIHtcbiAgICAgICAgbGV0IHN0YXJ0RXZhbHVhdGlvbiA9IG5ldyBDb25zb2xlTGluZVN0YXJ0RXZhbHVhdGUodGhpcy5tYWluKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0RXZhbHVhdGlvbi5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmNvbmRpdGlvbmFsbHkgc2Nyb2xsIHRvIHRoZSBib3R0b20gb2YgdGhlIHdpbmRvdy5cbiAgICAgKlxuICAgICAqL1xuICAgIHNjcm9sbFRvQm90dG9tKCkge1xuICAgICAgICB0aGlzLnRhZy5hbmltYXRlKHtcbiAgICAgICAgICAgIHNjcm9sbFRvcDogdGhpcy50YWcucHJvcChcInNjcm9sbEhlaWdodFwiKSAtIHRoaXMudGFnLnByb3AoXCJjbGllbnRIZWlnaHRcIilcbiAgICAgICAgfSwgNTAwKTtcbiAgICB9O1xuXG59IiwiaW1wb3J0IHtzbHVnfSBmcm9tIFwiLi91dGlsaXRpZXNcIjtcblxuLy8gVE9ETzogZWRpdG9yLmJtLmJsb2NrRWRpdG9yLmV4dHJhVG9vbHNbXVxuXG5leHBvcnQgbGV0IF9JTVBPUlRFRF9EQVRBU0VUUyA9IHt9O1xuZXhwb3J0IGxldCBfSU1QT1JURURfQ09NUExFVEVfREFUQVNFVFMgPSB7fTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgdmVyeSBzaW1wbGlzdGljIGhlbHBlciBmdW5jdGlvbiB0aGF0IHdpbGwgdHJhbnNmb3JtXG4gKiBhIGdpdmVuIGJ1dHRvbiBpbnRvIGEgXCJMb2FkZWRcIiBzdGF0ZSAoZGlzYWJsZWQsIHByZXNzZWQgc3RhdGUsIGV0Yy4pLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJ0biAtIEFuIEhUTUwgZWxlbWVudCB0byBjaGFuZ2UgdGhlIHRleHQgb2YuXG4gKi9cbmxldCBzZXRCdXR0b25Mb2FkZWQgPSBmdW5jdGlvbiAoYnRuKSB7XG4gICAgYnRuLmFkZENsYXNzKFwiYWN0aXZlXCIpXG4gICAgICAgIC5hZGRDbGFzcyhcImJ0bi1zdWNjZXNzXCIpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhcImJ0bi1wcmltYXJ5XCIpXG4gICAgICAgIC5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSlcbiAgICAgICAgLnRleHQoXCJMb2FkZWRcIilcbiAgICAgICAgLmF0dHIoXCJhcmlhLXByZXNzZWRcIiwgXCJ0cnVlXCIpO1xufTtcblxuXG4vKipcbiAqIE1vZHVsZSB0aGF0IGNvbm5lY3RzIHRvIHRoZSBDT1JHSVMgZGF0YXNldHMgYW5kIG1hbmFnZXMgaW50ZXJhY3Rpb25zXG4gKiB3aXRoIHRoZW0uIFRoaXMgaW5jbHVkZXMgbG9hZGluZyBpbiBkYXRhc2V0cyBhdCBsYXVuY2ggYW5kIG9uLXRoZS1mbHkuXG4gKiBOb3RlIHRoYXQgdGhpcyBoYXMgbm8gcHJlc2VuY2Ugb24gc2NyZWVuLCBzbyBpdCBkb2VzIG5vdCBoYXZlIGEgdGFnLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0Jsb2NrUHlDb3JnaXN9XG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJsb2NrUHlDb3JnaXMobWFpbikge1xuICAgIHRoaXMubWFpbiA9IG1haW47XG5cbiAgICB0aGlzLmxvYWRlZERhdGFzZXRzID0gW107XG4gICAgdGhpcy5sb2FkRGF0YXNldHMoKTtcbn1cblxuQmxvY2tQeUNvcmdpcy5wcm90b3R5cGUubG9hZERhdGFzZXRzID0gZnVuY3Rpb24gKHNpbGVudGx5KSB7XG4gICAgLy8gTG9hZCBpbiBlYWNoIHRoZSBkYXRhc2V0c1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbCxcbiAgICAgICAgZWRpdG9yID0gdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLFxuICAgICAgICBzZXJ2ZXIgPSB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXI7XG4gICAgbGV0IGltcG9ydHMgPSBbXTtcbiAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRhdGFzZXRzKCkuc3BsaXQoXCIsXCIpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgaWYgKG5hbWUgJiYgIShuYW1lIGluIEJsb2NrTWlycm9yQmxvY2tFZGl0b3IuRVhUUkFfVE9PTFMpKSB7XG4gICAgICAgICAgICBpbXBvcnRzLnB1c2guYXBwbHkoaW1wb3J0cywgdGhpcy5pbXBvcnREYXRhc2V0KHNsdWcobmFtZSksIG5hbWUsIHNpbGVudGx5KSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFdoZW4gZGF0YXNldHMgYXJlIGxvYWRlZCwgdXBkYXRlIHRoZSB0b29sYm94LlxuICAgICQud2hlbi5hcHBseSgkLCBpbXBvcnRzKS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlRSSUdHRVJFRFwiKTtcbiAgICAgICAgZWRpdG9yLmJtLmZvcmNlQmxvY2tSZWZyZXNoKCk7XG4gICAgICAgIGVkaXRvci5ibS5ibG9ja0VkaXRvci5yZW1ha2VUb29sYm94KCk7XG4gICAgfSkuZmFpbChmdW5jdGlvbiAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH0pLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlcnZlci5maW5hbGl6ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogTG9hZHMgdGhlIGRlZmluaXRpb25zIGZvciBhIGRhdGFzZXQgaW50byB0aGUgZW52aXJvbm1lbnQsIGluY2x1ZGluZ1xuICogdGhlIGRhdGFzZXQgKGFzIGEgSlMgZmlsZSksIHRoZSBza3VscHQgYmluZGluZ3MsIGFuZCB0aGUgYmxvY2tseVxuICogYmluZGluZ3MuIFRoaXMgcmVxdWlyZXMgYWNjZXNzIHRvIGEgQ09SR0lTIHNlcnZlciwgYW5kIG9jY3Vyc1xuICogYXN5bmNocm9ub3VzbHkuIFRoZSByZXF1ZXN0cyBhcmUgZmlyZWQgYW5kIHRoZWlyIGRlZmVycmVkIG9iamVjdHNcbiAqIGFyZSByZXR1cm5lZCAtIGNhbGxlcnMgY2FuIHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIHBlcmZvcm0gYW4gYWN0aW9uXG4gKiBvbiBjb21wbGV0aW9uIG9mIHRoZSBpbXBvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNsdWcgLSBUaGUgVVJMIHNhZmUgdmVyc2lvbiBvZiB0aGUgZGF0YXNldCBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSB1c2VyLWZyaWVuZGx5IHZlcnNpb24gb2YgdGhlIGRhdGFzZXQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheS48RGVmZXJyZWQ+fSAtIFJldHVybnMgdGhlIGFzeW5jIHJlcXVlc3RzIGFzIGRlZmVycmVkIG9iamVjdHMuXG4gKi9cbkJsb2NrUHlDb3JnaXMucHJvdG90eXBlLmltcG9ydERhdGFzZXQgPSBmdW5jdGlvbiAoc2x1ZywgbmFtZSkge1xuICAgIGxldCB1cmxfcmV0cmlldmFscyA9IFtdO1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJpbXBvcnREYXRhc2V0c1wiKSkge1xuICAgICAgICBsZXQgcm9vdCA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnVybHMuaW1wb3J0RGF0YXNldHMgKyBcImJsb2NrcHkvXCIgKyBzbHVnICsgXCIvXCIgKyBzbHVnO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5sb2FkaW5nRGF0YXNldHMucHVzaChuYW1lKTtcbiAgICAgICAgLy8gQWN0dWFsbHkgZ2V0IGRhdGFcbiAgICAgICAgbGV0IGdldERhdGFzZXQgPSAkLmdldFNjcmlwdChyb290ICsgXCJfZGF0YXNldC5qc1wiKTtcbiAgICAgICAgLy8gTG9hZCBnZXRDb21wbGV0ZSBzaWxlbnRseSBpbiB0aGUgYmFja2dyb3VuZCBiZWNhdXNlIGl0cyBiaWcgOihcbiAgICAgICAgbGV0IGdldENvbXBsZXRlID0gJC5nZXRTY3JpcHQocm9vdCArIFwiX2NvbXBsZXRlLmpzXCIpO1xuICAgICAgICBsZXQgZ2V0U2t1bHB0ID0gJC5nZXQocm9vdCArIFwiX3NrdWxwdC5qc1wiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bXCJzcmMvbGliL1wiICsgc2x1ZyArIFwiL19faW5pdF9fLmpzXCJdID0gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBnZXRCbG9ja2x5ID0gJC5nZXRTY3JpcHQocm9vdCArIFwiX2Jsb2NrbHkuanNcIik7XG4gICAgICAgIC8vIE9uIGNvbXBsZXRpb24sIHVwZGF0ZSBtZW51cy5cbiAgICAgICAgJC53aGVuKGdldERhdGFzZXQsIGdldFNrdWxwdCwgZ2V0QmxvY2tseSkuZG9uZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZERhdGFzZXRzLnB1c2goc2x1Zyk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0udGV4dFRvQmxvY2tzLmhpZGRlbkltcG9ydHMucHVzaChzbHVnKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5mb3JjZUJsb2NrUmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLmJsb2NrRWRpdG9yLnJlbWFrZVRvb2xib3goKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmxvYWRpbmdEYXRhc2V0cy5yZW1vdmUobmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB1cmxfcmV0cmlldmFscy5wdXNoKGdldERhdGFzZXQsIGdldFNrdWxwdCwgZ2V0QmxvY2tseSk7XG4gICAgfVxuICAgIHJldHVybiB1cmxfcmV0cmlldmFscztcbn07XG5cbi8qKlxuICogT3BlbnMgYSBkaWFsb2cgYm94IHRvIHByZXNlbnQgdGhlIHVzZXIgd2l0aCB0aGUgZGF0YXNldHMgYXZhaWxhYmxlXG4gKiB0aHJvdWdoIHRoZSBDT1JHSVMgc2VydmVyLiBUaGlzIHJlcXVpcmVzIGEgY2FsbCwgc28gdGhpcyBtZXRob2RcbiAqIGNvbXBsZXRlcyBhc3luY2hyb25vdXNseS4gVGhlIGRpYWxvZyBpcyBjb21wb3NlZCBvZiBhIHRhYmxlIHdpdGhcbiAqIGJ1dHRvbnMgdG8gbG9hZCB0aGUgZGF0YXNldHMgKE1vcmUgdGhhbiBvbmUgZGF0YXNldCBjYW4gYmUgbG9hZGVkXG4gKiBmcm9tIHdpdGhpbiB0aGUgZGlhbG9nIGF0IGEgdGltZSkuXG4gKi9cbkJsb2NrUHlDb3JnaXMucHJvdG90eXBlLm9wZW5EaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImltcG9ydERhdGFzZXRzXCIpKSB7XG4gICAgICAgIGxldCByb290ID0gdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24udXJscy5pbXBvcnREYXRhc2V0cztcbiAgICAgICAgJC5nZXRKU09OKHJvb3QgKyBcImluZGV4Lmpzb25cIiwgIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBNYWtlIHVwIHRoZSBCb2R5XG4gICAgICAgICAgICBsZXQgZGF0YXNldHMgPSBkYXRhLmJsb2NrcHk7XG4gICAgICAgICAgICBsZXQgZG9jdW1lbnRhdGlvbiA9IHJvb3QrXCJibG9ja3B5L2luZGV4Lmh0bWxcIjtcbiAgICAgICAgICAgIGxldCBzdGFydCA9ICQoYDxwPkRvY3VtZW50YXRpb24gaXMgYXZhaWxhYmxlIGF0IDxhIGhyZWY9JyR7ZG9jdW1lbnRhdGlvbn0nIHRhcmdldD1fYmxhbms+dXJsPC9hPjwvcD5gKTtcbiAgICAgICAgICAgIGxldCBib2R5ID0gJChcIjx0YWJsZT48L3RhYmxlPlwiLCB7XCJjbGFzc1wiOiBcInRhYmxlIHRhYmxlLWJvcmRlcmVkIHRhYmxlLXNtIHRhYmxlLXN0cmlwZWRcIn0pO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YXNldHMpLnNvcnQoKS5tYXAoKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2x1Z2dlZE5hbWUgPSBzbHVnKGRhdGFzZXRzW25hbWVdLm5hbWUpO1xuICAgICAgICAgICAgICAgIGxldCB0aXRsZU5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIGxldCBidG4gPSAkKCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIGRhdGEtdG9nZ2xlPVwiYnV0dG9uXCIgYXJpYS1wcmVzc2VkPVwiZmFsc2VcIiBhdXRvY29tcGxldGU9XCJvZmZcIj5Mb2FkPC9idXR0b24+Jyk7XG4gICAgICAgICAgICAgICAgbGV0IGltZ1NyYyA9IHJvb3QrXCIuLi9pbWFnZXMvZGF0YXNldHMvXCIrbmFtZStcIi1pY29uLnBuZ1wiO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlZERhdGFzZXRzLmluZGV4T2Yoc2x1Z2dlZE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QnV0dG9uTG9hZGVkKGJ0bik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnRuLmNsaWNrKCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydERhdGFzZXQoc2x1Z2dlZE5hbWUsIFwiRGF0YSAtIFwiICsgZGF0YXNldHNbbmFtZV0udGl0bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnV0dG9uTG9hZGVkKGJ0bik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2xldCBpbWcgPSBgPGltZyBzcmM9JyR7aW1nU3JjfScgY2xhc3M9XCJjb3JnaXMtaWNvblwiPmA7XG4gICAgICAgICAgICAgICAgJChcIjx0cj48L3RyPlwiKVxuICAgICAgICAgICAgICAgICAgICAvLy5hcHBlbmQoJChcIjx0ZD5cIiArIGltZyArIFwiPC90ZD5cIikpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChcIjx0ZD5cIiArIGRhdGFzZXRzW25hbWVdLnRpdGxlICsgXCI8L3RkPlwiKSlcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKFwiPHRkPlwiICsgZGF0YXNldHNbbmFtZV0ub3ZlcnZpZXcgKyBcIjwvdGQ+XCIpKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoXCI8dGQ+PC90ZD5cIikuYXBwZW5kKGJ0bikpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhib2R5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRUbyhzdGFydCk7XG4gICAgICAgICAgICAvLyBTaG93IHRoZSBhY3R1YWwgZGlhbG9nXG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuc2hvdyhcIkltcG9ydCBEYXRhc2V0c1wiLCBzdGFydCwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE2MTEwMzExMTY0NjNcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvYWNiYXJ0L1Byb2plY3RzL2Jsb2NrcHktZWR1L2Jsb2NrcHkvbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiLi4vXCIsXCJobXJcIjp0cnVlLFwibG9jYWxzXCI6ZmFsc2V9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgbW9kdWxlLmhvdC5hY2NlcHQodW5kZWZpbmVkLCBjc3NSZWxvYWQpO1xuICAgIH1cbiAgIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTYxMTAzMTExNjQ1OFxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9Vc2Vycy9hY2JhcnQvUHJvamVjdHMvYmxvY2tweS1lZHUvYmxvY2tweS9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIuLi9cIixcImhtclwiOnRydWUsXCJsb2NhbHNcIjpmYWxzZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBtb2R1bGUuaG90LmFjY2VwdCh1bmRlZmluZWQsIGNzc1JlbG9hZCk7XG4gICAgfVxuICAiLCIvLyBUT0RPOiBEeWFubWljYWxseSBwb3B1bGF0ZSBhcmlhLWxhYmVsbGVkYnkgaW4gdGhpcyBhbmQgb3RoZXIgcGxhY2VzXG5cbmV4cG9ydCBsZXQgRElBTE9HX0hUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz0nYmxvY2tweS1kaWFsb2cgbW9kYWwgaGlkZGVuJ1xuICAgICAgICAgcm9sZT1cImRpYWxvZ1wiXG4gICAgICAgICBhcmlhLWxhYmVsPSdEaWFsb2cnXG4gICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICAgYXJpYS1tb2RhbD1cInRydWVcIj5cbiAgICAgICAgPGRpdiBjbGFzcz0nbW9kYWwtZGlhbG9nIG1vZGFsLWxnJyByb2xlPVwiZG9jdW1lbnRcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9J21vZGFsLWNvbnRlbnQnIHJvbGU9J3JlZ2lvbicgYXJpYS1sYWJlbD0nRGlhbG9nIGNvbnRlbnQnPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J21vZGFsLWhlYWRlcic+XG4gICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz0nbW9kYWwtdGl0bGUnPkR5bmFtaWMgQ29udGVudDwvaDQ+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nY2xvc2UnIGRhdGEtZGlzbWlzcz0nbW9kYWwnIGFyaWEtaGlkZGVuPSd0cnVlJz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J21vZGFsLWJvZHknIHN0eWxlPSdtYXgtd2lkdGg6MTAwJTsgbWF4LWhlaWdodDo0MDBweCc+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nbW9kYWwtZm9vdGVyJz5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLXdoaXRlIG1vZGFsLWNsb3NlJyBkYXRhLWRpc21pc3M9J21vZGFsJz5DbG9zZTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4tc3VjY2VzcyBtb2RhbC1va2F5JyBkYXRhLWRpc21pc3M9J21vZGFsJz5Pa2F5PC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+ICAgIFxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuYDtcblxuLyoqXG4gKiBBIHV0aWxpdHkgb2JqZWN0IGZvciBxdWlja2x5IGFuZCBjb252ZW5pZW50bHkgZ2VuZXJhdGluZyBkaWFsb2cgYm94ZXMuXG4gKiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGRvZXNuJ3QgZHluYW1pY2FsbHkgY3JlYXRlIG5ldyBib3hlczsgaXQgcmV1c2VzIHRoZSBzYW1lIG9uZVxuICogb3ZlciBhbmQgb3ZlciBhZ2Fpbi4gSXQgdHVybnMgb3V0IGR5bmFtaWNhbGx5IGdlbmVyYXRpbmcgbmV3IGRpYWxvZyBib3hlc1xuICogaXMgYSBwYWluISBTbyB3ZSBjYW4ndCBzdGFjayB0aGVtLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0Jsb2NrUHlEaWFsb2d9XG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZyAtIFRoZSBIVE1MIG9iamVjdCB0aGlzIGlzIGF0dGFjaGVkIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gQmxvY2tQeURpYWxvZyhtYWluLCB0YWcpIHtcbiAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgIHRoaXMudGFnID0gdGFnO1xuXG4gICAgdGhpcy50aXRsZVRhZyA9IHRhZy5maW5kKFwiLm1vZGFsLXRpdGxlXCIpO1xuICAgIHRoaXMuYm9keVRhZyA9IHRhZy5maW5kKFwiLm1vZGFsLWJvZHlcIik7XG4gICAgdGhpcy5mb290ZXJUYWcgPSB0YWcuZmluZChcIi5tb2RhbC1mb290ZXJcIik7XG4gICAgdGhpcy5va2F5QnV0dG9uID0gdGFnLmZpbmQoXCIubW9kYWwtb2theVwiKTtcbiAgICB0aGlzLmNsb3NlQnV0dG9uID0gdGFnLmZpbmQoXCIubW9kYWwtY2xvc2VcIik7XG5cbiAgICB0aGlzLnllcyA9ICgpID0+IHt9O1xuICAgIHRoaXMubm8gPSAoKSA9PiB7fTtcbiAgICB0aGlzLm9rYXlCdXR0b24uY2xpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLnllcygpO1xuICAgICAgICB0aGlzLnRhZy5tb2RhbChcImhpZGVcIik7XG4gICAgfSk7XG4gICAgdGhpcy5jbG9zZUJ1dHRvbi5jbGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMubm8oKTtcbiAgICAgICAgLy90aGlzLnRhZy5tb2RhbChcImhpZGVcIik7XG4gICAgfSk7XG59XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudGFnLm1vZGFsKFwiaGlkZVwiKTtcbn07XG5cbi8qKlxuICogQSBzaW1wbGUgZXh0ZXJuYWxseSBhdmFpbGFibGUgZnVuY3Rpb24gZm9yIHBvcHBpbmcgdXAgYSBkaWFsb2dcbiAqIG1lc3NhZ2UuIFRoaXMgbWVudSB3aWxsIGJlIGRyYWdnYWJsZSBieSBpdHMgdGl0bGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlIC0gVGhlIHRpdGxlIG9mIHRoZSBtZXNzYWdlIGRpYWxvZy4gQ2FuIGhhdmUgSFRNTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG1lc3NhZ2UgZGlhbG9nLiBDYW4gaGF2ZSBIVE1MLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25jbG9zZSAtIEEgZnVuY3Rpb24gdG8gYmUgcnVuIHdoZW4gdGhlIHVzZXIgY2xvc2VzIHRoZSBkaWFsb2cuXG4gKi9cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAodGl0bGUsIGJvZHksIG9uY2xvc2UpIHtcbiAgICB0aGlzLnRpdGxlVGFnLmh0bWwodGl0bGUpO1xuICAgIHRoaXMuYm9keVRhZy5odG1sKGJvZHkpO1xuICAgIHRoaXMudGFnLm1vZGFsKFwic2hvd1wiKTtcbiAgICB0aGlzLm9rYXlCdXR0b24uaGlkZSgpO1xuICAgIHRoaXMudGFnLmRyYWdnYWJsZSh7XG4gICAgICAgIFwiaGFuZGxlXCI6IFwiLm1vZGFsLXRpdGxlXCJcbiAgICB9KTtcblxuICAgIHRoaXMudGFnLm9uKFwiaGlkZGVuLmJzLm1vZGFsXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChvbmNsb3NlICE9PSB1bmRlZmluZWQgJiYgb25jbG9zZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb25jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5jb25maXJtID0gZnVuY3Rpb24gKHRpdGxlLCBib2R5LCB5ZXMsIG5vLCB5ZXNUZXh0KSB7XG4gICAgaWYgKHllc1RleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB5ZXNUZXh0ID0gXCJPa2F5XCI7XG4gICAgfVxuICAgIHRoaXMuc2hvdyh0aXRsZSwgYm9keSwgbm8pO1xuICAgIHRoaXMueWVzID0geWVzO1xuICAgIHRoaXMubm8gPSBubztcbiAgICB0aGlzLm9rYXlCdXR0b24uc2hvdygpLmh0bWwoeWVzVGV4dCk7XG4gICAgLy8gVE9ETzogYWRkIG9rYXkgYnV0dG9uIGFuZCBjYW5jZWwgYnV0dG9uXG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5BU1NJR05NRU5UX1ZFUlNJT05fQ0hBTkdFRCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbmZpcm0oXCJBc3NpZ25tZW50IENoYW5nZWRcIiwgXCJZb3VyIGluc3RydWN0b3IgaGFzIG1hZGUgY2hhbmdlcyB0byB0aGlzIGFzc2lnbm1lbnQuIFdvdWxkIHlvdSBsaWtlIHRvIHJlbG9hZD8gQWxsIHlvdXIgd29yayBoYXMgYmVlbiBzYXZlZC5cIiwpO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfTE9BRElOR19BU1NJR05NTkVOVCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLnNob3coXCJFcnJvciBMb2FkaW5nIEFzc2lnbm1lbnRcIiwgYEJsb2NrUHkgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgYXNzaWdubWVudC48YnI+XG5QbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uPGJyPlJlc3BvbnNlIGZyb20gc2VydmVyIHdhczo8YnI+PHByZT4ke3JlYXNvbn08L3ByZT5gLCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9TSE9XX1NUVURFTlRfRVJST1IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB0aGlzLnNob3coXCJPcmlnaW5hbCBFcnJvclwiLCBgV2hlbiBJIHJhbiB5b3VyIGNvZGUsIEkgZW5jb3VudGVyZWQgYW4gZXJyb3I6XFxuXFxuPGRpdiBjbGFzcz1cImJsb2NrcHktZGlhbG9nLXN0dWRlbnQtZXJyb3ItbWVzc2FnZVwiPiR7ZXJyb3J9PC9kaXY+YCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5QT1NJVElWRV9GRUVEQkFDS19GVUxMID0gZnVuY3Rpb24gKHRpdGxlLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5zaG93KHRpdGxlLCBtZXNzYWdlKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLlNDUkVFTlNIT1RfQkxPQ0tTID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE9cbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkVSUk9SX1VQREFUSU5HX1NVQk1JU1NJT05fU1RBVFVTID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIFVwZGF0aW5nIFN1Ym1pc3Npb24gU3RhdHVzXCIsIGBCbG9ja1B5IGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIHVwZGF0aW5nIHlvdXIgc3VibWlzc2lvbiBzdGF0dXMuPGJyPlxuUGxlYXNlIHJlbG9hZCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLmApO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfTE9BRElOR19ISVNUT1JZID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIExvYWRpbmcgSGlzdG9yeVwiLCBgQmxvY2tQeSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBsb2FkaW5nIHlvdXIgaGlzdG9yeS48YnI+XG5QbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uYCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FRElUX0lOUFVUUyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgaW5wdXRUZXh0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCgpLmpvaW4oXCJcXG5cIik7XG4gICAgbGV0IGNsZWFySW5wdXRzID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuY2xlYXJJbnB1dHMoKSA/IFwiXCIgOiBcImNoZWNrZWRcIjtcbiAgICBsZXQgeWVzID0gKCkgPT4ge1xuICAgICAgICBsZXQgY2hlY2tlZCA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1yZW1lbWJlci1pbnB1dHNcIikucHJvcChcImNoZWNrZWRcIik7XG4gICAgICAgIGxldCBpbnB1dHMgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktaW5wdXQtbGlzdFwiKS52YWwoKS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuY2xlYXJJbnB1dHMoIWNoZWNrZWQpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KGlucHV0cyk7XG4gICAgfTtcbiAgICB0aGlzLmNvbmZpcm0oXCJFZGl0IFJlbWVtYmVyZWQgSW5wdXRzXCIsIGBcblxuPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cImJsb2NrcHktcmVtZW1iZXItaW5wdXRzIGZvcm0tY2hlY2staW5wdXRcIlxuICAgICAgICBuYW1lPVwiYmxvY2tweS1yZW1lbWJlci1pbnB1dHNcIiAke2NsZWFySW5wdXRzfT5cbjxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXJlbWVtYmVyLWlucHV0c1wiPlJldXNlIGlucHV0cyBmb3IgbmV4dCBleGVjdXRpb248L2xhYmVsPlxuPC9kaXY+XG5cbjx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktaW5wdXQtbGlzdCBmb3JtLWNvbnRyb2xcIiByb3dzPVwiNFwiPiR7aW5wdXRUZXh0fTwvdGV4dGFyZWE+PGJyPlxuRWRpdCB0aGUgaW5wdXRzIGFib3ZlIHRvIHN0b3JlIGFuZCByZXVzZSB0aGVtIGFjcm9zcyBtdWx0aXBsZSBleGVjdXRpb25zLlxuRWFjaCBpbnB1dCBzaG91bGQgYmUgcHV0IG9uIGl0cyBvd24gbGluZS5cbllvdSBkbyBub3QgbmVlZCBxdW90ZXM7IHRoZSB0ZXh0IHdpbGwgYmUgZW50ZXJlZCBsaXRlcmFsbHkuXG4gXG5gLCB5ZXMsIHRoaXMubm8sIFwiU2F2ZVwiKTtcbiAgICAvLyBUT0RPOiBBbGxvdyB1c2VyIHRvIHNwZWNpZnkgdGhlIGluZmluaXRlIHN0cmluZyB0byBrZWVwIGdpdmluZyB3aGVuIHRoZSBvdGhlcnMgcnVuIG91dFxufTsiLCJpbXBvcnQge0VkaXRvcnN9IGZyb20gXCIuLi9lZGl0b3JzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRGaWxlKG1vZGVsLCBldmVudCkge1xuICAgIGxldCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBsZXQgZmlsZXMgPSBldmVudC50YXJnZXQuZmlsZXM7XG4gICAgZmlsZVJlYWRlci5vbmxvYWQgPSAoZSA9PlxuICAgICAgICBtb2RlbC51aS5lZGl0b3JzLmN1cnJlbnQoKS51cGxvYWRGaWxlKGUpXG4gICAgKTtcbiAgICBmaWxlUmVhZGVyLmZpbGVOYW1lID0gZmlsZXNbMF0ubmFtZTtcbiAgICBmaWxlUmVhZGVyLnJlYWRBc1RleHQoZmlsZXNbMF0pO1xuICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IFwiXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzbHVnZ2lmeSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvW15hLXowLTldL2dpLCBcIl9cIikudG9Mb3dlckNhc2UoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkRmlsZShtb2RlbCwgZXZlbnQpIHtcbiAgICBsZXQge25hbWUsIGV4dGVuc2lvbiwgY29udGVudHMsIG1pbWV0eXBlfSA9IG1vZGVsLnVpLmVkaXRvcnMuY3VycmVudCgpLmRvd25sb2FkRmlsZSgpO1xuICAgIC8vIE1ha2Ugc2FmZVxuICAgIG5hbWUgPSBzbHVnZ2lmeShuYW1lKTtcbiAgICBuYW1lID0gbmFtZSArIGV4dGVuc2lvbjtcbiAgICAvLyBNYWtlIHRoZSBkYXRhIGRvd25sb2FkIGFzIGEgZmlsZVxuICAgIGxldCBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRzXSwge3R5cGU6IG1pbWV0eXBlfSk7XG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZUJsb2IoYmxvYiwgbmFtZSk7XG4gICAgfSBlbHNle1xuICAgICAgICBsZXQgdGVtcG9yYXJ5RG93bmxvYWRMaW5rID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICB0ZW1wb3JhcnlEb3dubG9hZExpbmsuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICB0ZW1wb3JhcnlEb3dubG9hZExpbmsuZG93bmxvYWQgPSBuYW1lO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBvcmFyeURvd25sb2FkTGluayk7XG4gICAgICAgIHRlbXBvcmFyeURvd25sb2FkTGluay5jbGljaygpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRlbXBvcmFyeURvd25sb2FkTGluayk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcblxuICAgICAgICB0aGlzLmZpbGVTeXN0ZW0gPSBtYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVsZXRlRmlsZSgpIHtcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtLmRlbGV0ZUZpbGUodGhpcy5maWxlbmFtZSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lKFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5lZGl0b3JzLmNoYW5nZUVkaXRvcihcImFuc3dlci5weVwiKTtcbiAgICB9XG5cbiAgICBvbkZpbGVEZWxldGVkKCkge1xuICAgICAgICAvLyBUT0RPOiBTd2l0Y2ggdG8gdGhlIHByZXZpb3VzIGZpbGUgaW5zdGVhZCBvZiBhIGRlZmF1bHQgZmlsZVxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5maWxlbmFtZShcImFuc3dlci5weVwiKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZWRpdG9ycy5jaGFuZ2VFZGl0b3IoXCJhbnN3ZXIucHlcIik7XG4gICAgfVxuXG4gICAgb25GaWxlVXBkYXRlZChmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLmZpbGVuYW1lID09PSB0aGlzLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAvL3RoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5lZGl0b3JzLmNoYW5nZUVkaXRvcih0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIC8vdGhpcy5maWxlU3lzdGVtLnN0b3BXYXRjaGluZ0ZpbGUodGhpcy5maWxlbmFtZSk7XG4gICAgICAgICAgICAvL3RoaXMudHJhY2tDdXJyZW50RmlsZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdHJhY2tDdXJyZW50RmlsZSgpIHtcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtLndhdGNoRmlsZSh0aGlzLmZpbGVuYW1lLCB7XG4gICAgICAgICAgICB1cGRhdGVkOiB0aGlzLm9uRmlsZVVwZGF0ZWQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGRlbGV0ZWQ6IHRoaXMub25GaWxlRGVsZXRlZC5iaW5kKHRoaXMpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpIHtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IG5ld0ZpbGVuYW1lO1xuICAgICAgICB0aGlzLmZpbGUgPSB0aGlzLmZpbGVTeXN0ZW0uZ2V0RmlsZShuZXdGaWxlbmFtZSk7XG4gICAgICAgIHRoaXMudHJhY2tDdXJyZW50RmlsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0ZpbGVuYW1lIC0gdGhlIGZpbGVuYW1lIHRoYXQgdGhlIG90aGVyIGVkaXRvciB3aWxsIGJlIHN3aXRjaGluZyB0b1xuICAgICAqIEBwYXJhbSBvbGRFZGl0b3JcbiAgICAgKiBAcGFyYW0gbmV3RWRpdG9yXG4gICAgICovXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtLnN0b3BXYXRjaGluZ0ZpbGUodGhpcy5maWxlbmFtZSk7XG4gICAgICAgIHRoaXMuZmlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBudWxsO1xuICAgIH1cblxuICAgIHVwbG9hZEZpbGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gZXZlbnQudGFyZ2V0LmZpbGVOYW1lO1xuICAgICAgICBsZXQgY29udGVudHMgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKGNvbnRlbnRzKTtcbiAgICB9XG5cbiAgICBkb3dubG9hZEZpbGUoKSB7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IEVkaXRvcnMucGFyc2VGaWxlbmFtZSh0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGZpbGVuYW1lLm5hbWUsXG4gICAgICAgICAgICBleHRlbnNpb246IGZpbGVuYW1lLnR5cGUsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5maWxlLmhhbmRsZSgpLFxuICAgICAgICAgICAgbWltZXR5cGU6IFwidGV4dC9wbGFpblwiXG4gICAgICAgIH07XG4gICAgfVxufSIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xuaW1wb3J0IHtEaXNwbGF5TW9kZXN9IGZyb20gXCIuL3B5dGhvblwiO1xuXG5jb25zdCBBU1NJR05NRU5UX1NFVFRJTkdTID0gW1xuICAgIFtcInRvb2xib3hcIiwgXCJ0b29sYm94XCIsIFwibm9ybWFsXCIsIFwidG9vbGJveFwiLCBcIldoaWNoIHZlcnNpb24gb2YgdGhlIHRvb2xib3ggdG8gcHJlc2VudCB0byB0aGUgdXNlci5cIl0sXG4gICAgW1wicGFzc2NvZGVcIiwgXCJwYXNzY29kZVwiLCBcIlwiLCBcInN0cmluZ1wiLCBcIkEgc3RyaW5nIHRoYXQgdGhlIHVzZXIgbXVzdCBlbnRlciB0byBhY2Nlc3MgdGhlIHByb2JsZW0uIElmIGJsYW5rLCB0aGVuIG5vIHBhc3Njb2RlIGlzIHByb21wdGVkLlwiXSxcbiAgICAvL1tcInRvb2xib3hMZXZlbFwiLCBcInRvb2xib3hfbGV2ZWxcIiwgXCJub3JtYWxcIiwgXCJ0b29sYm94XCIsIFwiSU5DT01QTEVURTogV2hhdCBsZXZlbCBvZiB0b29sYm94IHRvIHByZXNlbnQgdG8gdGhlIHVzZXIgKGhpZGluZyBhbmQgc2hvd2luZyBjYXRlZ29yaWVzKS5cIl0sXG4gICAgW1wic3RhcnRWaWV3XCIsIFwic3RhcnRfdmlld1wiLCBEaXNwbGF5TW9kZXMuU1BMSVQsIERpc3BsYXlNb2RlcywgXCJUaGUgUHl0aG9uIGVkaXRvciBtb2RlIHRvIHN0YXJ0IGluIHdoZW4gdGhlIHN0dWRlbnQgc3RhcnRzIHRoZSBwcm9ibGVtLlwiXSxcbiAgICBbXCJkYXRhc2V0c1wiLCBcImRhdGFzZXRzXCIsIFwiXCIsIFwic3RyaW5nXCIsIFwiVGhlIGN1cnJlbnQgbGlzdCBvZiBkYXRhc2V0cyBhdmFpbGFibGUgb24gbG9hZCBhcyBhIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmcuXCJdLFxuICAgIFtcImRpc2FibGVUaW1lb3V0XCIsIFwiZGlzYWJsZV90aW1lb3V0XCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHN0dWRlbnRzIGNvZGUgaXMgYWxsb3dlZCB0byBydW4gd2l0aG91dCB0aW1lb3V0cyAocG90ZW50aWFsbHkgYWxsb3dpbmcgaW5maW5pdGUgbG9vcHMpLlwiXSxcbiAgICBbXCJpc1BhcnNvbnNcIiwgXCJpc19wYXJzb25zXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoaXMgaXMgYSBwYXJzb24ncyBzdHlsZSBxdWVzdGlvbiAoanVtYmxlZCkuXCJdLFxuICAgIFtcImRpc2FibGVGZWVkYmFja1wiLCBcImRpc2FibGVfZmVlZGJhY2tcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gbm8gaW5zdHJ1Y3RvciBzY3JpcHRzIGFyZSBydW4gKGUuZy4sIG9uX3J1biBhbmQgb25fZXZhbCkuXCJdLFxuICAgIFtcImRpc2FibGVJbnN0cnVjdG9yUnVuXCIsIFwiZGlzYWJsZV9pbnN0cnVjdG9yX3J1blwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgaW5zdHJ1Y3RvciBvbl9ydW4gd2lsbCBub3QgYXV0b21hdGljYWxseSBydW4gdGhlIHN0dWRlbnRzJyBjb2RlLiBUaGlzIHN0aWxsIHJ1bnMgdGhlIHN0dWRlbnRzJyBjb2RlLlwiXSxcbiAgICBbXCJkaXNhYmxlU3R1ZGVudFJ1blwiLCBcImRpc2FibGVfc3R1ZGVudF9ydW5cIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHJ1biBidXR0b24gbm8gbG9uZ2VyIHJ1biB0aGUgc3R1ZGVudHMnIGNvZGUuIFRoaXMgc3RpbGwgcnVucyB0aGUgaW5zdHJ1Y3RvcidzIGZlZWRiYWNrIG9uX3J1biBzY3JpcHQuXCJdLFxuICAgIFtcImRpc2FibGVUaWZhXCIsIFwiZGlzYWJsZV90aWZhXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIGRvIG5vdCBhdXRvbWF0aWNhbGx5IHJ1biBUaWZhICh3aGljaCBjYW4gYmUgc2xvdykuXCJdLFxuICAgIFtcImRpc2FibGVUcmFjZVwiLCBcImRpc2FibGVfdHJhY2VcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnRzIGNvZGUgd2lsbCBub3QgaGF2ZSBpdHMgZXhlY3V0aW9uIHRyYWNlZCAobm8gdmFyaWFibGVzIHJlY29yZGVkLCBubyBjb3ZlcmFnZSB0cmFja2VkKS5cIl0sXG4gICAgW1wiZGlzYWJsZUVkaXRcIiwgXCJkaXNhYmxlX2VkaXRcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnRzJyBmaWxlIHdpbGwgbm90IGJlIGVkaXRhYmxlLlwiXSxcbiAgICBbXCJlbmFibGVJbWFnZXNcIiwgXCJjYW5faW1hZ2VcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdXNlcnMgY2FuIGNvcHkvcGFzdGUgaW1hZ2VzIGRpcmVjdGx5IGludG8gdGhlIHRleHQgZWRpdG9yLlwiXSxcbiAgICBbXCJlbmFibGVCbG9ja3NcIiwgXCJjYW5fYmxvY2tzXCIsIHRydWUsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnQgY2FuIGVkaXQgdGhlIGJsb2NrIGludGVyZmFjZSAoaWYgbm90LCB0aGVuIGl0IGlzIHZpc2libGUgYnV0IG5vdCBlZGl0YWJsZSkuXCJdLFxuICAgIFtcImNhbkNsb3NlXCIsIFwiY2FuX2Nsb3NlXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBzdHVkZW50IHNob3VsZCBtYXJrIHRoZWlyIHN1Ym1pc3Npb24gY2xvc2VkIHdoZW4gdGhleSBhcmUgZG9uZS4gVGhlcmUgaXMgbm8gd2F5IHRvIGZvcmNlIGEgc3R1ZGVudCB0byBkbyBzby4gVW5saWtlIFJldmlld2VkLCB0aGlzIHN0aWxsIHN1Ym1pdHMgdGhlIGNvcnJlY3RuZXNzLlwiXSxcbiAgICBbXCJvbmx5SW50ZXJhY3RpdmVcIiwgXCJvbmx5X2ludGVyYWN0aXZlXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGUgZWRpdG9ycyBhcmUgaGlkZGVuLCB0aGUgcHJvZ3JhbSBpcyBhdXRvbWF0aWNhbGx5IHJ1biwgYW5kIHRoZW4gdGhlIGNvbnNvbGUgZW50ZXJzIEV2YWwgbW9kZSAoaW50ZXJhY3RpdmUpLlwiXSxcbiAgICBbXCJvbmx5VXBsb2Fkc1wiLCBcIm9ubHlfdXBsb2Fkc1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgc3R1ZGVudHMnIGZpbGUgd2lsbCBub3QgYmUgZGlyZWN0bHkgZWRpdGFibGUgKHRoZXkgd2lsbCBoYXZlIHRvIHVwbG9hZCBzdWJtaXNzaW9ucykuXCJdLFxuICAgIC8vIFdoYXQgbWVudXMvZmVlZGJhY2sgdG8gc2hvdyBhbmQgaGlkZVxuICAgIFtcImhpZGVTdWJtaXNzaW9uXCIsIFwiaGlkZV9zdWJtaXNzaW9uXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHN0dWRlbnRzIHdpbGwgbm90IGJlIGFibGUgdG8gc2VlIHRoZWlyIHN1Ym1pc3Npb24ncyBjb2RlIG9yIGhpc3Rvcnkgb24gQ2FudmFzLlwiXSxcbiAgICBbXCJoaWRlRmlsZXNcIiwgXCJoaWRlX2ZpbGVzXCIsIHRydWUsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gc3R1ZGVudHMgd2lsbCBub3Qgc2VlIHRoZSBWaWV3IEZpbGVzIHRvb2xiYXIuXCJdLFxuICAgIFtcImhpZGVRdWV1ZWRJbnB1dHNcIiwgXCJoaWRlX3F1ZXVlZF9pbnB1dHNcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnRzIGNhbm5vdCBhY2Nlc3MgdGhlIHF1ZXVlZCBpbnB1dHMgYm94IChtYWtlcyByZXBlYXRlZCBkZWJ1Z2dpbmcgZWFzaWVyIGZvciB0aGUgaW5wdXQgZnVuY3Rpb24pLlwiXSxcbiAgICBbXCJoaWRlRWRpdG9yc1wiLCBcImhpZGVfZWRpdG9yc1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBhbGwgb2YgdGhlIGVkaXRvcnMgYXJlIGhpZGRlbi5cIl0sXG4gICAgW1wiaGlkZU1pZGRsZVBhbmVsXCIsIFwiaGlkZV9taWRkbGVfcGFuZWxcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIGNvbnNvbGUgYW5kIGZlZWRiYWNrIGFyZWFzIGlzIGhpZGRlbi5cIl0sXG4gICAgW1wiaGlkZUFsbFwiLCBcImhpZGVfYWxsXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJTkNPTVBMRVRFOiBJZiBjaGVja2VkLCB0aGVuIHRoZSBlbnRpcmUgaW50ZXJmYWNlIGlzIGhpZGRlbi5cIl0sXG4gICAgW1wiaGlkZUV2YWx1YXRlXCIsIFwiaGlkZV9ldmFsdWF0ZVwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgRXZhbHVhdGUgYnV0dG9uIGlzIG5vdCBzaG93biBvbiB0aGUgY29uc29sZS5cIl0sXG4gICAgW1wiaGlkZUltcG9ydERhdGFzZXRzQnV0dG9uXCIsIFwiaGlkZV9pbXBvcnRfZGF0YXNldHNfYnV0dG9uXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHN0dWRlbnRzIGNhbm5vdCBzZWUgdGhlIGltcG9ydCBkYXRhc2V0cyBidXR0b24uXCJdLFxuICAgIC8vIFRPRE86IEZpeCB0aGlzIG9uZSB0byBiZSBzZXR0YWJsZVxuICAgIFtcImhpZGVJbXBvcnRTdGF0ZW1lbnRzXCIsIFwiaGlkZV9pbXBvcnRfc3RhdGVtZW50c1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSU5DT01QTEVURTogSWYgY2hlY2tlZCwgY2VydGFpbiBraW5kcyBvZiBpbXBvcnQgc3RhdGVtZW50cyAobWF0cGxvdGxpYiwgdHVydGxlLCBkYXRhc2V0cykgYXJlIG5vdCBzaG93biBpbiB0aGUgYmxvY2sgaW50ZXJmYWNlLlwiXSxcbiAgICBbXCJoaWRlQ292ZXJhZ2VCdXR0b25cIiwgXCJoaWRlX2NvdmVyYWdlX2J1dHRvblwiLCBmYWxzZSwgXCJib29sXCIsIFwiSU5DT01QTEVURTogSWYgY2hlY2tlZCwgdGhlIGNvdmVyYWdlIGJ1dHRvbiBpcyBub3Qgc2hvd24uXCJdLFxuICAgIFtcInNhdmVUdXJ0bGVPdXRwdXRcIiwgXCJzYXZlX3R1cnRsZV9vdXRwdXRcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdHVydGxlIG91dHB1dCBpcyBzYXZlZCB3aGVuZXZlciB0aGUgcHJvZ3JhbSB1c2VzIGl0LlwiXSxcbl07XG5cbmZ1bmN0aW9uIGdldERvY3VtZW50YXRpb24obmFtZSkge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IEFTU0lHTk1FTlRfU0VUVElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEFTU0lHTk1FTlRfU0VUVElOR1NbaV1bMF0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBBU1NJR05NRU5UX1NFVFRJTkdTW2ldWzRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIkRvY3VtZW50YXRpb24gbm90IGZvdW5kIGZvciBmaWVsZFwiO1xufVxuXG5mdW5jdGlvbiBtYWtlU3RhcnRWaWV3VGFiKG5hbWUsIGljb24sIG1vZGUpIHtcbiAgICByZXR1cm4gYDxsYWJlbCBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYmxvY2tweS1tb2RlLXNldC1ibG9ja3NcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogYXNzaWdubWVudC5zZXR0aW5ncy5zdGFydFZpZXcoKSA9PT0gJyR7bW9kZX0nfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBhc3NpZ25tZW50LnNldHRpbmdzLnN0YXJ0Vmlldy5iaW5kKCRkYXRhLCAnJHttb2RlfScpXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS0ke2ljb259Jz48L3NwYW4+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJibG9ja3B5LXN0YXJ0LXZpZXctc2V0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgY2hlY2tlZD4gJHtuYW1lfVxuICAgICAgICAgICAgPC9sYWJlbD5gO1xufVxuXG5jb25zdCBBU1NJR05NRU5UX1NFVFRJTkdTX0JPT0xFQU5fQ09NUE9ORU5UU19IVE1MID0gQVNTSUdOTUVOVF9TRVRUSU5HU1xuICAgIC8vIE9ubHkgaGFuZGxlIHRoZSBzaW1wbGUgYm9vbGVhbnMgdGhpcyB3YXlcbiAgICAuZmlsdGVyKChzZXR0aW5nKSA9PiBzZXR0aW5nWzNdID09PSBcImJvb2xcIilcbiAgICAubWFwKChzZXR0aW5nKSA9PiB7XG4gICAgICAgIGxldCBwcmV0dHlOYW1lID0gc2V0dGluZ1sxXS5zcGxpdChcIl9cIikubWFwKHdvcmQ9Pih3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3dvcmQuc2xpY2UoMSkpKS5qb2luKFwiIFwiKTtcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXNldHRpbmdzLSR7c2V0dGluZ1swXX1cIj4ke3ByZXR0eU5hbWV9PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy0ke3NldHRpbmdbMF19XCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2hlY2tlZDogYXNzaWdubWVudC5zZXR0aW5ncy4ke3NldHRpbmdbMF19XCI+XG4gICAgICAgICAgICAgICAgPC9kaXY+ICBcbiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS05XCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtzZXR0aW5nWzRdfVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIGA7XG4gICAgfSkuam9pbihcIlxcblxcblwiKTtcblxuZXhwb3J0IGNvbnN0IEFTU0lHTk1FTlRfU0VUVElOR1NfRURJVE9SX0hUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz1cImJsb2NrcHktdmlldy1zZXR0aW5nc1wiPlxuICAgIFxuICAgIDxmb3JtPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMiBteC1hdXRvXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXN1Y2Nlc3NcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5zZXR0aW5ncy5zYXZlXCI+U2F2ZSBjaGFuZ2VzPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtbmFtZVwiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPk5hbWU6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1uYW1lXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5uYW1lXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgVGhlIHN0dWRlbnQtZmFjaW5nIG5hbWUgb2YgdGhlIGFzc2lnbm1lbnQuIEFzc2lnbm1lbnRzIHdpdGhpbiBhIGdyb3VwIGFyZSBvcmRlcmVkIGFscGhhYmV0aWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIGJ5IHRoZWlyIG5hbWUsIHNvIHlvdSBtYXkgd2FudCB0byB1c2UgYSBuYW1pbmcgc2NoZW1lIGxpa2UgXCIjNDMuNSkgV2hhdGV2ZXJcIi5cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy11cmxcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5VUkw6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy11cmxcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LnVybFwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIFRoZSBjb3Vyc2UtdW5pcXVlIFVSTCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbnNpc3RlbnRseSByZWZlciB0byB0aGlzIGFzc2lnbm1lbnQuIFxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcHVibGljXCI+UHVibGljOjwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtcHVibGljXCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2hlY2tlZDogYXNzaWdubWVudC5wdWJsaWNcIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gIFxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBJZiBub3QgcHVibGljLCB1c2VycyBvdXRzaWRlIG9mIHRoZSBjb3Vyc2Ugd2lsbCBub3QgYmUgYWJsZSB0byBzZWUgdGhlIGFzc2lnbm1lbnQgaW4gY291cnNlIGxpc3RpbmdzLlxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtaGlkZGVuXCI+SGlkZGVuOjwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtaGlkZGVuXCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2hlY2tlZDogYXNzaWdubWVudC5oaWRkZW5cIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gIFxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBJZiBoaWRkZW4sIHN0dWRlbnRzIHdpbGwgbm90IGJlIGFibGUgdG8gc2VlIHRoZWlyIGdyYWRlIHdoaWxlIHdvcmtpbmcgb24gdGhlIGFzc2lnbm1lbnQuXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1yZXZpZXdlZFwiPlJldmlld2VkOjwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtcmV2aWV3ZWRcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBhc3NpZ25tZW50LnJldmlld2VkXCI+XG4gICAgICAgICAgICAgICAgPC9kaXY+ICBcbiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS05XCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgSWYgcmV2aWV3ZWQsIHRoZSBhc3NpZ25tZW50IG5lZWQgdG8gYmUgY29tbWVudGVkIHVwb24gYW5kIHJlZ3JhZGVkIGJ5IHRoZSBzdGFmZiBhZnRlciBzdWJtaXNzaW9uLlxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcmV2aWV3ZWRcIj5TdGFydGluZyBWaWV3OjwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tM1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgYnRuLWdyb3VwLXRvZ2dsZSBtci0yXCIgZGF0YS10b2dnbGU9XCJidXR0b25zXCI+XG4gICAgICAgICAgICAgICAgICAgICR7bWFrZVN0YXJ0Vmlld1RhYihcIkJsb2Nrc1wiLCBcInRoLWxhcmdlXCIsIERpc3BsYXlNb2Rlcy5CTE9DSyl9XG4gICAgICAgICAgICAgICAgICAgICR7bWFrZVN0YXJ0Vmlld1RhYihcIlNwbGl0XCIsIFwiY29sdW1uc1wiLCBEaXNwbGF5TW9kZXMuU1BMSVQpfVxuICAgICAgICAgICAgICAgICAgICAke21ha2VTdGFydFZpZXdUYWIoXCJUZXh0XCIsIFwiYWxpZ24tbGVmdFwiLCBEaXNwbGF5TW9kZXMuVEVYVCl9XG4gICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTdcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke2dldERvY3VtZW50YXRpb24oXCJzdGFydFZpZXdcIil9XG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtaXAtcmFuZ2VzXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+SVAgUmFuZ2VzOjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtaXAtcmFuZ2VzXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5pcFJhbmdlc1wiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIFByb3ZpZGUgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBJUCBBZGRyZXNzZXMgdGhhdCB3aWxsIGJlIGV4cGxpY2l0bHkgYWxsb3dlZC4gSWYgYmxhbmssXG4gICAgICAgICAgICAgICAgICAgIHRoZW4gYWxsIGFkZHJlc3NlcyBhcmUgYWxsb3dlZC4gSWYgYW4gYWRkcmVzcyBzdGFydHMgd2l0aCA8Y29kZT5ePC9jb2RlPiB0aGVuIGl0IGl0IGlzIGV4cGxpY2l0bHlcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tsaXN0ZWQsIGJ1dCB0aGF0IGNhbiBiZSBvdmVycmlkZGVuIGluIHR1cm4gd2l0aCBhIDxjb2RlPiE8L2NvZGU+LiBBZGRyZXNzZXMgY2FuIGFsc29cbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZSBhIGJpdCBtYXNrIHRvIGFsbG93IGEgcmFuZ2Ugb2YgYWRkcmVzc2VzLlxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXBhc3Njb2RlXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+UGFzc2NvZGU6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1wYXNzY29kZVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmFsdWU6IGFzc2lnbm1lbnQuc2V0dGluZ3MucGFzc2NvZGVcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke2dldERvY3VtZW50YXRpb24oXCJwYXNzY29kZVwiKX1cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1kYXRhc2V0c1wiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPlByZWxvYWRlZCBEYXRhc2V0czo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLWRhdGFzZXRzXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5zZXR0aW5ncy5kYXRhc2V0c1wiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcImRhdGFzZXRzXCIpfVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXRvb2xib3hcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5CbG9jayBUb29sYm94OjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy10b29sYm94XCJcbiAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmFsdWU6IGFzc2lnbm1lbnQuc2V0dGluZ3MudG9vbGJveFwiPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJub3JtYWxcIj5Ob3JtYWwgVG9vbGJveDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJjdFwiPkNUQFZUIFRvb2xib3g8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiY3QyXCI+Q1RAVlQgVG9vbGJveCBWMjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJtaW5pbWFsXCI+TWluaW1hbCBTZXQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiZnVsbFwiPkFsbCBCbG9ja3M8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiY3VzdG9tXCI+Q3VzdG9tPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtnZXREb2N1bWVudGF0aW9uKFwidG9vbGJveFwiKX1cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgJHtBU1NJR05NRU5UX1NFVFRJTkdTX0JPT0xFQU5fQ09NUE9ORU5UU19IVE1MfVxuICAgIDwvZm9ybT5cbiAgICBcbiAgICA8L2Rpdj5cbmA7XG5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlQXNzaWdubWVudFNldHRpbmdzKG1vZGVsKSB7XG4gICAgbGV0IHNldHRpbmdzID0ge307XG4gICAgQVNTSUdOTUVOVF9TRVRUSU5HUy5mb3JFYWNoKHNldHRpbmcgPT4ge1xuICAgICAgICBsZXQgY2xpZW50TmFtZSA9IHNldHRpbmdbMF0sIHNlcnZlck5hbWUgPSBzZXR0aW5nWzFdLCBkZWZhdWx0VmFsdWUgPSBzZXR0aW5nWzJdO1xuICAgICAgICBsZXQgdmFsdWUgPSBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzW2NsaWVudE5hbWVdKCk7XG4gICAgICAgIC8vIE9ubHkgc3RvcmUgdGhpcyBzZXR0aW5nIGlmIGl0cyBkaWZmZXJlbnQgZnJvbSB0aGUgZGVmYXVsdFxuICAgICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgc2V0dGluZ3Nbc2VydmVyTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzZXR0aW5ncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkQXNzaWdubWVudFNldHRpbmdzKG1vZGVsLCBzZXR0aW5ncykge1xuICAgIGlmIChzZXR0aW5ncykge1xuICAgICAgICBzZXR0aW5ncyA9IEpTT04ucGFyc2Uoc2V0dGluZ3MpO1xuICAgICAgICBBU1NJR05NRU5UX1NFVFRJTkdTLmZvckVhY2goc2V0dGluZyA9PiB7XG4gICAgICAgICAgICBsZXQgY2xpZW50TmFtZSA9IHNldHRpbmdbMF0sIHNlcnZlck5hbWUgPSBzZXR0aW5nWzFdO1xuICAgICAgICAgICAgaWYgKHNlcnZlck5hbWUgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzW2NsaWVudE5hbWVdKHNldHRpbmdzW3NlcnZlck5hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5nc1tjbGllbnROYW1lXShzZXR0aW5nWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLnN0YXJ0X3ZpZXcpIHtcbiAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZShzZXR0aW5ncy5zdGFydF92aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VBc3NpZ25tZW50U2V0dGluZ3NNb2RlbChjb25maWd1cmF0aW9uKSB7XG4gICAgbGV0IHNldHRpbmdzID0ge307XG4gICAgQVNTSUdOTUVOVF9TRVRUSU5HUy5mb3JFYWNoKHNldHRpbmcgPT4ge1xuICAgICAgICBsZXQgY2xpZW50TmFtZSA9IHNldHRpbmdbMF0sIHNlcnZlck5hbWUgPSBzZXR0aW5nWzFdLCBkZWZhdWx0VmFsdWUgPSBzZXR0aW5nWzJdLFxuICAgICAgICAgICAgZmllbGRUeXBlID0gc2V0dGluZ1szXTtcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LnNldHRpbmdzLlwiK3NlcnZlck5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNldHRpbmdzW2NsaWVudE5hbWVdID0ga28ub2JzZXJ2YWJsZShkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbmZpZ1ZhbHVlID0gY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQuc2V0dGluZ3MuXCIrc2VydmVyTmFtZV07XG4gICAgICAgICAgICBpZiAoZmllbGRUeXBlID09PSBcImJvb2xcIikge1xuICAgICAgICAgICAgICAgIGNvbmZpZ1ZhbHVlID0gY29uZmlnVmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXR0aW5nc1tjbGllbnROYW1lXSA9IGtvLm9ic2VydmFibGUoY29uZmlnVmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2V0dGluZ3M7XG59XG5cbmNsYXNzIEFzc2lnbm1lbnRTZXR0aW5nc1ZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIC8vVE9ETzogdGhpcy51cGRhdGVFZGl0b3IodGhpcy5maWxlLmhhbmRsZSgpKTtcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXG4gICAgICAgIC8vIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcblxuICAgICAgICAvL1RPRE86IHRoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgLy8gVE9ETzogRG8gdXBkYXRlXG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUhhbmRsZShldmVudCkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IudmFsdWUoKSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBVcGRhdGVcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXG4gICAgICAgIC8vdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgLy8gVE9ETzogdXBkYXRlXG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9yLm9mZihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgQXNzaWdubWVudFNldHRpbmdzID0ge1xuICAgIG5hbWU6IFwiQXNzaWdubWVudCBTZXR0aW5nc1wiLFxuICAgIGV4dGVuc2lvbnM6IFtcIiFhc3NpZ25tZW50X3NldHRpbmdzLmJsb2NrcHlcIl0sXG4gICAgY29uc3RydWN0b3I6IEFzc2lnbm1lbnRTZXR0aW5nc1ZpZXcsXG4gICAgdGVtcGxhdGU6IEFTU0lHTk1FTlRfU0VUVElOR1NfRURJVE9SX0hUTUxcbn07IiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XHJcblxyXG5leHBvcnQgY29uc3QgSlNPTl9FRElUT1JfSFRNTCA9IGBcclxuICAgIDxkaXY+XHJcbiAgICAgICAgPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1lZGl0b3ItanNvblwiPjwvdGV4dGFyZWE+XHJcbiAgICA8L2Rpdj5cclxuYDtcclxuXHJcbmNsYXNzIEpzb25FZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xyXG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XHJcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3IgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYSh0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci1qc29uXCIpWzBdLCB7XHJcbiAgICAgICAgICAgIHNob3dDdXJzb3JXaGVuU2VsZWN0aW5nOiB0cnVlLFxyXG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcclxuICAgICAgICAgICAgZmlyc3RMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICBpbmRlbnRVbml0OiA0LFxyXG4gICAgICAgICAgICB0YWJTaXplOiA0LFxyXG4gICAgICAgICAgICBpbmRlbnRXaXRoVGFiczogZmFsc2UsXHJcbiAgICAgICAgICAgIG1vZGU6IFwianNvblwiLFxyXG4gICAgICAgICAgICBleHRyYUtleXM6IHtcclxuICAgICAgICAgICAgICAgIFwiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXHJcbiAgICAgICAgICAgICAgICBcIkVzY1wiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJGMTFcIjogZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xyXG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xyXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cclxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY29kZU1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5jb2RlTWlycm9yKSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBkeW5hbWljYWxseSB3aGVuIGNoYW5naW5nIGluc3RydWN0b3Igc3RhdHVzXHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIG5ld0ZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpICYmICF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRWYWx1ZShuZXdDb250ZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMuY29kZU1pcnJvci5nZXRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xyXG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UpO1xyXG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBKc29uRWRpdG9yID0ge1xyXG4gICAgbmFtZTogXCJKU09OXCIsXHJcbiAgICBleHRlbnNpb25zOiBbXCIuanNvblwiXSxcclxuICAgIGNvbnN0cnVjdG9yOiBKc29uRWRpdG9yVmlldyxcclxuICAgIHRlbXBsYXRlOiBKU09OX0VESVRPUl9IVE1MXHJcbn07IiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5cbmV4cG9ydCBjb25zdCBNQVJLRE9XTl9FRElUT1JfSFRNTCA9IGBcbiAgICA8dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWVkaXRvci1tYXJrZG93blwiPjwvdGV4dGFyZWE+ICAgIFxuYDtcblxuXG5jbGFzcyBNYXJrZG93bkVkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XG4gICAgICAgIHRoaXMubWRlID0gbmV3IEVhc3lNREUoe1xuICAgICAgICAgICAgZWxlbWVudDogdGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItbWFya2Rvd25cIilbMF0sXG4gICAgICAgICAgICBhdXRvRG93bmxvYWRGb250QXdlc29tZTogZmFsc2UsXG4gICAgICAgICAgICBmb3JjZVN5bmM6IHRydWUsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6IFwiNTAwcHhcIixcbiAgICAgICAgICAgIC8vIFRPRE86IGltYWdlVXBsb2FkRnVuY3Rpb25cbiAgICAgICAgICAgIHJlbmRlcmluZ0NvbmZpZzoge1xuICAgICAgICAgICAgICAgIGNvZGVTeW50YXhIaWdobGlnaHRpbmc6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5kZW50V2l0aFRhYnM6IGZhbHNlLFxuICAgICAgICAgICAgdGFiU2l6ZTogNCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubWRlLmNvZGVtaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBzbyB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVuZGVyZWRcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5tZGUuY29kZW1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5tZGUuY29kZW1pcnJvciksIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tZGUudmFsdWUobmV3Q29udGVudHMpO1xuICAgICAgICAgICAgdGhpcy5tZGUuY29kZW1pcnJvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMubWRlLnZhbHVlKCkpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5tZGUuY29kZW1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IE1hcmtkb3duRWRpdG9yID0ge1xuICAgIG5hbWU6IFwiTWFya2Rvd25cIixcbiAgICBleHRlbnNpb25zOiBbXCIubWRcIl0sXG4gICAgY29uc3RydWN0b3I6IE1hcmtkb3duRWRpdG9yVmlldyxcbiAgICB0ZW1wbGF0ZTogTUFSS0RPV05fRURJVE9SX0hUTUxcbn07IiwiLyoqXG4gKiBUT0RPOiByZW5hbWUgZmlsZXMsIG1hbnVhbCBzYXZlLCB0YWdzLCBzYW1wbGVfc3VibWlzc2lvbnMsIG9uX2V2YWwsIG5vbi1idWlsdGluIGZpbGVzXG4gKiBUT0RPOiBpbXBvcnQgZGF0YSwgaGlzdG9yeSwgcnVuLCB1cmxfZGF0YSwgYXNzaWdubWVudF9zZXR0aW5ncywgcGFyc29uc19tb2RlXG4gKiBUT0RPOiBkZWxldGUgYmVjb21lcyBcImNsZWFyXCIgZm9yIGluc3RydWN0b3IgZmlsZXNcbiAqL1xuXG4vKipcbiAqXG4gKiBAZW51bSB7c3RyfVxuICovXG5pbXBvcnQge0Fic3RyYWN0RWRpdG9yLCBzbHVnZ2lmeX0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5pbXBvcnQge0hJU1RPUllfVE9PTEJBUl9IVE1MfSBmcm9tIFwiLi4vaGlzdG9yeVwiO1xuXG5leHBvcnQgbGV0IERpc3BsYXlNb2RlcyA9IHtcbiAgICBCTE9DSzogXCJibG9ja1wiLFxuICAgIFNQTElUOiBcInNwbGl0XCIsXG4gICAgVEVYVDogXCJ0ZXh0XCJcbn07XG5cbmZ1bmN0aW9uIG1ha2VUYWIobmFtZSwgaWNvbiwgbW9kZSkge1xuICAgIHJldHVybiBgPGxhYmVsIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBibG9ja3B5LW1vZGUtc2V0LWJsb2Nrc1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB7YWN0aXZlOiBkaXNwbGF5LnB5dGhvbk1vZGUoKSA9PT0gJyR7bW9kZX0nfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi51cGRhdGVNb2RlLmJpbmQoJGRhdGEsICcke21vZGV9JylcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLSR7aWNvbn0nPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cImJsb2NrcHktbW9kZS1zZXRcIiBhdXRvY29tcGxldGU9XCJvZmZcIiBjaGVja2VkPiAke25hbWV9XG4gICAgICAgICAgICA8L2xhYmVsPmA7XG59XG5cbmV4cG9ydCBjb25zdCBQWVRIT05fRURJVE9SX0hUTUwgPSBgXG5cbiAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS1weXRob24tdG9vbGJhciBjb2wtbWQtMTIgYnRuLXRvb2xiYXJcIlxuICAgICAgICAgcm9sZT1cInRvb2xiYXJcIiBhcmlhLWxhYmVsPVwiUHl0aG9uIFRvb2xiYXJcIj5cblxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIlJ1biBHcm91cFwiPiAgICAgICAgIFxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYmxvY2tweS1ydW4gbm90cmFuc2l0aW9uXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZXhlY3V0ZS5ydW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzOiB7J2Jsb2NrcHktcnVuLXJ1bm5pbmcnOiB1aS5leGVjdXRlLmlzUnVubmluZ31cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1wbGF5XCI+PC9zcGFuPiBSdW5cbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIGJ0bi1ncm91cC10b2dnbGUgbXItMlwiIGRhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiPlxuICAgICAgICAgICAgPCEtLSBrbyBpZjogJHJvb3QuYXNzaWdubWVudC5zZXR0aW5ncy5lbmFibGVCbG9ja3MoKSAtLT5cbiAgICAgICAgICAgICR7bWFrZVRhYihcIkJsb2Nrc1wiLCBcInRoLWxhcmdlXCIsIERpc3BsYXlNb2Rlcy5CTE9DSyl9XG4gICAgICAgICAgICAke21ha2VUYWIoXCJTcGxpdFwiLCBcImNvbHVtbnNcIiwgRGlzcGxheU1vZGVzLlNQTElUKX1cbiAgICAgICAgICAgICR7bWFrZVRhYihcIlRleHRcIiwgXCJhbGlnbi1sZWZ0XCIsIERpc3BsYXlNb2Rlcy5URVhUKX1cbiAgICAgICAgICAgIDwhLS0gL2tvIC0tPlxuICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJSZXNldCBHcm91cFwiPlxuICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnJlc2V0XCI+XG4gICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXN5bmNcIj48L3NwYW4+IFJlc2V0XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICBcbiAgICAgICAgIDwhLS0ga28gaWY6ICFhc3NpZ25tZW50LnNldHRpbmdzLmhpZGVJbXBvcnREYXRhc2V0c0J1dHRvbigpIC0tPlxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIkltcG9ydCBHcm91cFwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5pbXBvcnREYXRhc2V0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtY2xvdWQtZG93bmxvYWQtYWx0XCI+PC9zcGFuPiBJbXBvcnQgZGF0YXNldHNcbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgICBcbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtZmlsZS11cGxvYWRcIj48L3NwYW4+IFVwbG9hZFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJibG9ja3B5LXRvb2xiYXItdXBsb2FkXCIgdHlwZT1cImZpbGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJldmVudDoge2NoYW5nZTogdWkuZWRpdG9ycy51cGxvYWR9XCI+XG4gICAgICAgICAgICAgICAgIDwvbGFiZWw+XG5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgZHJvcGRvd24tdG9nZ2xlIGRyb3Bkb3duLXRvZ2dsZS1zcGxpdFwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIiBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNhcmV0XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIj5Ub2dnbGUgRHJvcGRvd248L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnUgZHJvcGRvd24tbWVudS1yaWdodFwiPlxuICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz0nZHJvcGRvd24taXRlbSBibG9ja3B5LXRvb2xiYXItZG93bmxvYWQnXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5kb3dubG9hZFwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWRvd25sb2FkJz48L3NwYW4+IERvd25sb2FkXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiSGlzdG9yeSBHcm91cFwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgICBhcmlhLXByZXNzZWQ9XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLnRvZ2dsZUhpc3RvcnlNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlOiB1aS5lZGl0b3JzLnB5dGhvbi5pc0hpc3RvcnlBdmFpbGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjc3M6IHsgYWN0aXZlOiBkaXNwbGF5Lmhpc3RvcnlNb2RlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyOiB7ICdhcmlhLXByZXNzZWQnOiBkaXNwbGF5Lmhpc3RvcnlNb2RlIH1cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1oaXN0b3J5XCI+PC9zcGFuPiBIaXN0b3J5XG4gICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgICAgICAgPCEtLSBGdWxseSBmdW5jdGlvbmFsLCBidXQgYSBsaXR0bGUgdG9vLi4gSW52YXNpdmUgXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiRnVsbHNjcmVlbiBHcm91cFwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiBkaXNwbGF5LnB5dGhvbk1vZGUoKSA9PT0gJ3RleHQnXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi5mdWxsc2NyZWVuXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtZXhwYW5kLWFycm93cy1hbHRcIj48L3NwYW4+IEZ1bGxzY3JlZW5cbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgLS0+XG4gICAgICAgICBcbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJTYXZlIEdyb3VwXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmVkaXRvcnMuY2FuU2F2ZVwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtc2F2ZVwiPjwvc3Bhbj4gU2F2ZVxuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICBcbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJEZWxldGUgR3JvdXBcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkuZWRpdG9ycy5jYW5EZWxldGVcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiLFxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5maWxlcy5kZWxldGVcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS10cmFzaFwiPjwvc3Bhbj4gRGVsZXRlXG4gICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIlJlbmFtZSBHcm91cFwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5lZGl0b3JzLmNhblJlbmFtZVwiPlxuICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWZpbGUtc2lnbmF0dXJlXCI+PC9zcGFuPiBSZW5hbWVcbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgPC9kaXY+XG4gICAgXG4gICAgJHtISVNUT1JZX1RPT0xCQVJfSFRNTH1cblxuXG4gICAgPGRpdiBjbGFzcz1cImJsb2NrcHktcHl0aG9uLWJsb2NrbWlycm9yXCJcbiAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5tZW51LmlzU3VibWl0dGVkXCI+XG4gICAgPC9kaXY+XG5gO1xuXG5cblxuZnVuY3Rpb24gY29udmVydElweW5iVG9QeXRob24oY29kZSkge1xuICAgIGxldCBpcHluYiA9IEpTT04ucGFyc2UoY29kZSk7XG4gICAgbGV0IGlzVXNhYmxlID0gZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICBpZiAoY2VsbC5jZWxsX3R5cGUgPT09IFwiY29kZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbC5zb3VyY2UubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICFjZWxsLnNvdXJjZVswXS5zdGFydHNXaXRoKFwiJVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsLmNlbGxfdHlwZSA9PT0gXCJtYXJrZG93blwiIHx8XG4gICAgICAgICAgICAgICAgY2VsbC5jZWxsX3R5cGUgPT09IFwicmF3XCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBtYWtlUHl0aG9uID0gZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICBpZiAoY2VsbC5jZWxsX3R5cGUgPT09IFwiY29kZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbC5zb3VyY2Uuam9pbihcIlxcblwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChjZWxsLmNlbGxfdHlwZSA9PT0gXCJtYXJrZG93blwiIHx8XG4gICAgICAgICAgICBjZWxsLmNlbGxfdHlwZSA9PT0gXCJyYXdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiJycnXCIrY2VsbC5zb3VyY2Uuam9pbihcIlxcblwiKStcIicnJ1wiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gaXB5bmIuY2VsbHMuZmlsdGVyKGlzVXNhYmxlKS5tYXAobWFrZVB5dGhvbikuam9pbihcIlxcblwiKTtcbn1cblxuY2xhc3MgUHl0aG9uRWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnLmZpbmQoXCIuYmxvY2tweS1weXRob24tYmxvY2ttaXJyb3JcIikpO1xuICAgICAgICBCbG9ja2x5LnNldFBhcmVudENvbnRhaW5lcihtYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyWzBdKTtcbiAgICAgICAgdGhpcy5ibSA9IG5ldyBCbG9ja01pcnJvcih7XG4gICAgICAgICAgICBcImNvbnRhaW5lclwiOiB0aGlzLnRhZ1swXSxcbiAgICAgICAgICAgIFwicnVuXCI6IG1haW4uY29tcG9uZW50cy5lbmdpbmUucnVuLmJpbmQobWFpbi5jb21wb25lbnRzLmVuZ2luZSksXG4gICAgICAgICAgICBcInNraXBTa3VscHRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiYmxvY2tseU1lZGlhUGF0aFwiOiBtYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uYmxvY2tseVBhdGgsXG4gICAgICAgICAgICBcInRvb2xib3hcIjogbWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnRvb2xib3goKSxcbiAgICAgICAgICAgIFwiaW1hZ2VNb2RlXCI6IHRydWUsXG4gICAgICAgICAgICBpbWFnZURvd25sb2FkSE9vazogKG9sZFVybCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRVcmw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1hZ2VVcGxvYWRIb29rOiAoYmxvYikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXCJJbWFnZShcIitKU09OLnN0cmluZ2lmeShVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpKStcIilcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1hZ2VMaXRlcmFsSG9vazogKG9sZFVybCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBgSW1hZ2UoXCIke29sZFVybH1cIilgO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vJ2hlaWdodCc6ICcyMDAwcHgnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1ha2VTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgIHRoaXMubGluZUVycm9yU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5saW5lVW5jb3ZlcmVkU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbGRQeXRob25Nb2RlID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZSgpO1xuXG4gICAgICAgIHRoaXMubWFrZVBlckFzc2lnbm1lbnRTdWJzY3JpcHRpb25zKCk7XG4gICAgfVxuXG4gICAgY29uZmlndXJlRXh0cmFCbG9ja2x5KCkge1xuICAgICAgICB0aGlzLmJtLmJsb2NrRWRpdG9yLndvcmtzcGFjZS5jb25maWd1cmVDb250ZXh0TWVudSA9IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdGV4dDogXCJTY3JlZW5zaG90XCIsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5TQ1JFRU5TSE9UX0JMT0NLU1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xuICAgICAgICBsZXQgb2xkRmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lO1xuICAgICAgICBzdXBlci5lbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChuZXdGaWxlbmFtZSAhPT0gXCJhbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgaWYgKG9sZEZpbGVuYW1lID09PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbGRQeXRob25Nb2RlID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZShEaXNwbGF5TW9kZXMuVEVYVCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKHRoaXMub2xkUHl0aG9uTW9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXG4gICAgICAgIHRoaXMuY3VycmVudEJNTGlzdGVuZXIgPSB0aGlzLnVwZGF0ZUhhbmRsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJtLmFkZENoYW5nZUxpc3RlbmVyKHRoaXMuY3VycmVudEJNTGlzdGVuZXIpO1xuXG4gICAgICAgIGlmIChuZXdGaWxlbmFtZSAhPT0gXCJhbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgdGhpcy5ibS5pc1BhcnNvbnMgPSAoKSA9PiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYm0uaXNQYXJzb25zID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaXNQYXJzb25zO1xuXG4gICAgICAgICAgICB0aGlzLmxpbmVFcnJvclN1YnNjcmlwdGlvbiA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subGluZXNFcnJvci5zdWJzY3JpYmUoKGxpbmVzKSA9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ibS5zZXRIaWdobGlnaHRlZExpbmVzKGxpbmVzLCBcImVkaXRvci1lcnJvci1saW5lXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24gPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmxpbmVzVW5jb3ZlcmVkLnN1YnNjcmliZSgobGluZXMpID0+XG4gICAgICAgICAgICAgICAgdGhpcy5ibS5zZXRIaWdobGlnaHRlZExpbmVzKGxpbmVzLCBcImVkaXRvci11bmNvdmVyZWQtbGluZVwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy90aGlzLmJtLmJsb2NrRWRpdG9yLndvcmtzcGFjZS5yZW5kZXIoKTtcbiAgICAgICAgLy90aGlzLmJtLnJlZnJlc2goKTtcbiAgICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgdGhpcyBkb2Vzbid0IGVuZCB1cCBsb29raW5nIHJpZ2h0IChnbyB0byBhIGRpZmZlcmVudCBlZGl0b3IsIGNvbWUgYmFjaywgYW5kIGl0J2xsIGJlIHNxdWlzaGVkKVxuICAgICAgICAvL3RoaXMuYm0ucmVmcmVzaCgpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYm0ucmVmcmVzaCgpLCAwKTtcbiAgICB9XG5cbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcbiAgICAgICAgaWYgKG5ld0NvbnRlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXdDb250ZW50cyA9IHRoaXMuZmlsZS5oYW5kbGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRG9lc24ndCBtYXR0ZXIsIGZpbGUgd2FzIGFscmVhZHkgc2h1dCBkb3duLlxuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnRzID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuZXdDb250ZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gV2UncmUgY2xvc2luZyB0aGlzIGZpbGVcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZGVsZXRlRmlsZUxvY2FsbHlfKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ibS5zZXRDb2RlKG5ld0NvbnRlbnRzKTtcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYm0uY2xlYXJIaWdobGlnaHRlZExpbmVzKCk7XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmhpc3RvcnlNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMuYm0uZ2V0Q29kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5ibS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcih0aGlzLmN1cnJlbnRCTUxpc3RlbmVyKTtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmhpc3RvcnlNb2RlKCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC51aS5lZGl0b3JzLnB5dGhvbi50dXJuT2ZmSGlzdG9yeU1vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyTGluZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICB9XG5cbiAgICBjbGVhckxpbmVTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICB0aGlzLmJtLmNsZWFySGlnaGxpZ2h0ZWRMaW5lcygpO1xuICAgICAgICBpZiAodGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubGluZUVycm9yU3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMubGluZUVycm9yU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW5lVW5jb3ZlcmVkU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5saW5lVW5jb3ZlcmVkU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1ha2VTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICB0aGlzLmJtLnNldE1vZGUodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZSgpKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZS5zdWJzY3JpYmUobW9kZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJtLnNldE1vZGUobW9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5lbmFibGVCbG9ja3Muc3Vic2NyaWJlKGVuYWJsZWQgPT4ge1xuICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibS5zZXRNb2RlKERpc3BsYXlNb2Rlcy5URVhUKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibS5zZXRNb2RlKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy50b29sYm94LnN1YnNjcmliZSh0aGlzLnJlbG9hZFRvb2xib3guYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmVuYWJsZUltYWdlcy5zdWJzY3JpYmUoaW1hZ2VNb2RlID0+IHtcbiAgICAgICAgICAgIHRoaXMuYm0uc2V0SW1hZ2VNb2RlKGltYWdlTW9kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbG9hZFRvb2xib3godG9vbGJveCkge1xuICAgICAgICBpZiAodG9vbGJveCA9PT0gXCJjdXN0b21cIikge1xuICAgICAgICAgICAgbGV0IGN1c3RvbVRvb2xib3ggPSB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLmdldEZpbGUoXCI/dG9vbGJveC5ibG9ja3B5XCIpO1xuICAgICAgICAgICAgaWYgKGN1c3RvbVRvb2xib3ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvb2xib3ggPSBcImVtcHR5XCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xib3ggPSBKU09OLnBhcnNlKGN1c3RvbVRvb2xib3guaGFuZGxlKCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTsgLy8gVE9ETzogSW1wcm92ZSBlcnJvciBtZXNzYWdlIGZvciBpbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIHRvb2xib3ggPSBcIm1pbmltYWxcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ibS5jb25maWd1cmF0aW9uLnRvb2xib3ggPSB0b29sYm94O1xuICAgICAgICAvLyBUT0RPOiBIYW5kbGUgaW52YWxpZCB0b29sYm94IGJldHRlclxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5ibS5ibG9ja0VkaXRvci5yZW1ha2VUb29sYm94KCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB0aGlzLmJtLmNvbmZpZ3VyYXRpb24udG9vbGJveCA9IFwiZW1wdHlcIjtcbiAgICAgICAgICAgIHRoaXMuYm0uYmxvY2tFZGl0b3IucmVtYWtlVG9vbGJveCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWFrZVBlckFzc2lnbm1lbnRTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yLnN1YnNjcmliZSgoY2hhbmdlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRSZWFkT25seSh0aGlzLmRlY2lkZUlmTm90RWRpdGFibGUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5vbmx5VXBsb2Fkcy5zdWJzY3JpYmUoKGNoYW5nZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0UmVhZE9ubHkodGhpcy5kZWNpZGVJZk5vdEVkaXRhYmxlKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkZWNpZGVJZk5vdEVkaXRhYmxlKCkge1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgICAgIHJldHVybiBtb2RlbC5kaXNwbGF5Lmhpc3RvcnlNb2RlKCkgfHwgKFxuICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5vbmx5VXBsb2FkcygpICYmICFtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHNldFJlYWRPbmx5KGlzUmVhZE9ubHkpIHtcbiAgICAgICAgdGhpcy5yZWFkT25seSA9IGlzUmVhZE9ubHk7XG4gICAgICAgIHRoaXMuYm0uc2V0UmVhZE9ubHkoaXNSZWFkT25seSk7XG4gICAgfVxuXG4gICAgdXBsb2FkRmlsZShldmVudCkge1xuICAgICAgICBsZXQgZmlsZW5hbWUgPSBldmVudC50YXJnZXQuZmlsZU5hbWU7XG4gICAgICAgIGxldCBjb2RlID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgaWYgKGZpbGVuYW1lLmVuZHNXaXRoKFwiLmlweW5iXCIpKSB7XG4gICAgICAgICAgICBjb2RlID0gY29udmVydElweW5iVG9QeXRob24oY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1GaWxlLlVwbG9hZFwiLCBcIlwiLCBcIlwiLCBjb2RlLCB0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5maWxlLmhhbmRsZShjb2RlKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZW5naW5lLnJ1bigpO1xuICAgICAgICAvLyBUT0RPOiBSdW4gY29kZVxuICAgIH1cblxuICAgIGRvd25sb2FkRmlsZSgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN1cGVyLmRvd25sb2FkRmlsZSgpO1xuICAgICAgICBpZiAocmVzdWx0Lm5hbWUgPT09IFwiYW5zd2VyXCIgJiYgcmVzdWx0LmV4dGVuc2lvbiA9PT0gXCIucHlcIikge1xuICAgICAgICAgICAgcmVzdWx0Lm5hbWUgPSBzbHVnZ2lmeSh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5uYW1lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5taW1ldHlwZSA9IFwidGV4dC94LXB5dGhvblwiO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLUZpbGUuRG93bmxvYWRcIiwgXCJcIiwgXCJcIiwgXCJcIiwgcmVzdWx0Lm5hbWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxufVxuXG5leHBvcnQgY29uc3QgUHl0aG9uRWRpdG9yID0ge1xuICAgIG5hbWU6IFwiUHl0aG9uXCIsXG4gICAgZXh0ZW5zaW9uczogW1wiLnB5XCJdLFxuICAgIGNvbnN0cnVjdG9yOiBQeXRob25FZGl0b3JWaWV3LFxuICAgIHRlbXBsYXRlOiBQWVRIT05fRURJVE9SX0hUTUxcbn07IiwiLyoqXG4gKiBQYW5lbCBmb3IgZWRpdGluZyB0aGUgc2V0IG9mIFNhbXBsZSBTdWJtaXNzaW9ucy5cbiAqIFRoZXNlIGFyZSBub3QgcHJvdmlkZWQgYXQgYWxsIHRvIHN0dWRlbnRzIHdpdGhvdXQgdGhlIEdyYWRlciByb2xlLlxuICovXG5cbmltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xuXG5leHBvcnQgY29uc3QgU3VibWlzc2lvblN0YXR1c2VzID0ge1xuICAgIFVOS05PV046IFwidW5rbm93blwiLFxuICAgIFBBU1NFRDogXCJwYXNzZWRcIixcbiAgICBGQUlMRUQ6IFwiZmFpbGVkXCIsXG4gICAgRVJST1I6IFwiZXJyb3JcIixcbiAgICBTS0lQUEVEOiBcInNraXBwZWRcIlxufTtcblxuZXhwb3J0IGNsYXNzIFNhbXBsZVN1Ym1pc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHN0YXR1cywgY29kZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgQmxhbmsoY291bnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTYW1wbGVTdWJtaXNzaW9uKFwiVW50aXRsZWRcIisoY291bnQgfHwgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdWJtaXNzaW9uU3RhdHVzZXMuVU5LTk9XTiwgXCJhPTBcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTYW1wbGVTdWJtaXNzaW9uKGRhdGEubmFtZSwgZGF0YS5zdGF0dXMsIGRhdGEuY29kZSk7XG4gICAgfVxuXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGNvZGU6IHRoaXMuY29kZVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IFNBTVBMRV9TVUJNSVNTSU9OU19IVE1MID0gYFxuPGRpdj5cbiAgICA8ZGl2IGRhdGEtYmluZD1cImZvcmVhY2g6IHtkYXRhOiBhc3NpZ25tZW50LnNhbXBsZVN1Ym1pc3Npb25zfVwiXG4gICAgICAgIGNsYXNzPVwicm93XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiPlxuICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogbmFtZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktZWRpdG9yLXNhbXBsZS1zdWJtaXNzaW9ucy1jb2RlXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjb2RlTWlycm9ySW5zdGFuY2U6IGNvZGVcIj48L3RleHRhcmVhPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCI+XG4gICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdGF0dXNcIj48L3NwYW4+ICAgICAgICBcbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5cbmA7XG5cbmtvLmJpbmRpbmdIYW5kbGVycy5jb2RlTWlycm9ySW5zdGFuY2UgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBiaW5kaW5nIGlzIGZpcnN0IGFwcGxpZWQgdG8gYW4gZWxlbWVudFxuICAgICAgICAvLyBTZXQgdXAgYW55IGluaXRpYWwgc3RhdGUsIGV2ZW50IGhhbmRsZXJzLCBldGMuIGhlcmVcbiAgICAgICAgY29uc29sZS5sb2coXCJJTklUXCIpO1xuICAgICAgICBsZXQgY20gPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYShlbGVtZW50LCB7XG4gICAgICAgICAgICBzaG93Q3Vyc29yV2hlblNlbGVjdGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxuICAgICAgICAgICAgZmlyc3RMaW5lTnVtYmVyOiAxLFxuICAgICAgICAgICAgaW5kZW50VW5pdDogNCxcbiAgICAgICAgICAgIHRhYlNpemU6IDQsXG4gICAgICAgICAgICBpbmRlbnRXaXRoVGFiczogZmFsc2UsXG4gICAgICAgICAgICBleHRyYUtleXM6IHtcbiAgICAgICAgICAgICAgICBcIlRhYlwiOiBcImluZGVudE1vcmVcIixcbiAgICAgICAgICAgICAgICBcIlNoaWZ0LVRhYlwiOiBcImluZGVudExlc3NcIixcbiAgICAgICAgICAgICAgICBcIkVzY1wiOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY20uZGlzcGxheS5pbnB1dC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiRjExXCI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsICFjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjbS5zZXRTaXplKFwiMTAwJVwiLCBcIjEwMHB4XCIpO1xuICAgICAgICByZXR1cm4gY207XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgb25jZSB3aGVuIHRoZSBiaW5kaW5nIGlzIGZpcnN0IGFwcGxpZWQgdG8gYW4gZWxlbWVudCxcbiAgICAgICAgLy8gYW5kIGFnYWluIHdoZW5ldmVyIGFueSBvYnNlcnZhYmxlcy9jb21wdXRlZHMgdGhhdCBhcmUgYWNjZXNzZWQgY2hhbmdlXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgRE9NIGVsZW1lbnQgYmFzZWQgb24gdGhlIHN1cHBsaWVkIHZhbHVlcyBoZXJlLlxuICAgICAgICBjb25zb2xlLmxvZyhcIlVQREFURVwiKTtcbiAgICB9XG59O1xuXG5jbGFzcyBTYW1wbGVTdWJtaXNzaW9uc1ZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBidWlsZEVkaXRvcihuZXdET00sIGluZGV4LCBuZXdFbGVtZW50KSB7XG5cbiAgICB9XG5cbiAgICByZWJ1aWxkRWRpdG9ycygpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJSZWJ1aWxkaW5nIGVkaXRvcnNcIik7XG4gICAgfVxuXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xuICAgICAgICBzdXBlci5lbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHJlbGV2YW50IEZpbGVcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cbiAgICAgICAgdGhpcy5jdXJyZW50TGlzdGVuZXIgPSB0aGlzLnVwZGF0ZUhhbmRsZS5iaW5kKHRoaXMpO1xuICAgICAgICAvL3RoaXMucmVidWlsZEVkaXRvcnMoKTtcbiAgICAgICAgLy90aGlzLmNvZGVNaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnRhZyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnRhZy5maW5kKFwiLkNvZGVNaXJyb3JcIikpO1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy50YWcuZmluZChcIi5Db2RlTWlycm9yXCIpLm1hcCgoaSxjbSkgPT4gY29uc29sZS5sb2coXCIrKytcIiwgY20uQ29kZU1pcnJvcikpKTtcbiAgICAgICAgICAgIHRoaXMudGFnLmZpbmQoXCIuQ29kZU1pcnJvclwiKS5tYXAoKGksIGNtKSA9PiBjbS5Db2RlTWlycm9yLnJlZnJlc2goKSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJFRlJFU0hcIik7XG4gICAgICAgICAgICAvLyBEZWxheSBzbyB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVuZGVyZWRcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy50YWcuZmluZChcIi5Db2RlTWlycm9yXCIpLm1hcCgoaSwgY20pID0+IGNtLkNvZGVNaXJyb3IucmVmcmVzaCgpKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogdXBkYXRlIGR5bmFtaWNhbGx5IHdoZW4gY2hhbmdpbmcgaW5zdHJ1Y3RvciBzdGF0dXNcbiAgICAgICAgLy90aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgbmV3RmlsZW5hbWUuc3RhcnRzV2l0aChcIiZcIikgJiYgIXRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSk7XG4gICAgfVxuXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5jb2RlTWlycm9ycyk7XG4gICAgICAgICAgICAvL3RoaXMuY29kZU1pcnJvcnMuZWFjaCggKGksIGNtKSA9PiBjbS5zZXRWYWx1ZShuZXdDb250ZW50cy5qb2luKFwiXFxuXCIpKSk7XG4gICAgICAgICAgICAvL3RoaXMuY29kZU1pcnJvcnMuZWFjaCggKGksIGNtKSA9PiBjbS5yZWZyZXNoKCkpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3JzLm1hcChjbSA9PiBjbS5nZXRWYWx1ZSgpKSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xuICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3JzID0gW107XG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9ycy5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSk7XG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgU2FtcGxlU3VibWlzc2lvbnMgPSB7XG4gICAgbmFtZTogXCJTYW1wbGUgU3VibWlzc2lvbnNcIixcbiAgICBleHRlbnNpb25zOiBbXCIhc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHlcIl0sXG4gICAgY29uc3RydWN0b3I6IFNhbXBsZVN1Ym1pc3Npb25zVmlldyxcbiAgICB0ZW1wbGF0ZTogU0FNUExFX1NVQk1JU1NJT05TX0hUTUxcbn07XG4iLCJpbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcblxuZXhwb3J0IGNvbnN0IFRBR1NfRURJVE9SX0hUTUwgPSBgXG5DcmVhdGUgbmV3XG5JbXBvcnQgYnkgbmFtZVxuRmluZCBieSBvd25lci9jb3Vyc2Uva2luZFxuXG5UYWdzOlxuICAgIERhdGE6XG4gICAgICAgIE5hbWVcbiAgICAgICAgS2luZFxuICAgICAgICBMZXZlbFxuICAgICAgICBWZXJzaW9uXG4gICAgICAgIERlc2NyaXB0aW9uXG4gICAgQ29udHJvbHM6XG4gICAgICAgIEVkaXRcbiAgICAgICAgUmVtb3ZlXG4gICAgICAgIERlbGV0ZSBcbmA7XG5cbmNsYXNzIFRhZ3NFZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICBzdXBlcihtYWluLCB0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci10YWdzXCIpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBUYWdzRWRpdG9yID0ge1xuICAgIG5hbWU6IFwiVGFnc1wiLFxuICAgIGV4dGVuc2lvbnM6IFtcIiF0YWdzLmJsb2NrcHlcIl0sXG4gICAgY29uc3RydWN0b3I6IFRhZ3NFZGl0b3JWaWV3LFxuICAgIHRlbXBsYXRlOiBUQUdTX0VESVRPUl9IVE1MXG59OyIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xuXG5leHBvcnQgY29uc3QgVEVYVF9FRElUT1JfSFRNTCA9IGBcbiAgICA8ZGl2PlxuICAgIDx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktZWRpdG9yLXRleHRcIj48L3RleHRhcmVhPlxuICAgIDwvZGl2PlxuYDtcblxuY2xhc3MgVGV4dEVkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvciA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKHRhZy5maW5kKFwiLmJsb2NrcHktZWRpdG9yLXRleHRcIilbMF0sIHtcbiAgICAgICAgICAgIHNob3dDdXJzb3JXaGVuU2VsZWN0aW5nOiB0cnVlLFxuICAgICAgICAgICAgbGluZU51bWJlcnM6IHRydWUsXG4gICAgICAgICAgICBmaXJzdExpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICBpbmRlbnRVbml0OiA0LFxuICAgICAgICAgICAgdGFiU2l6ZTogNCxcbiAgICAgICAgICAgIGluZGVudFdpdGhUYWJzOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dHJhS2V5czoge1xuICAgICAgICAgICAgICAgIFwiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFxuICAgICAgICAgICAgICAgIFwiU2hpZnQtVGFiXCI6IFwiaW5kZW50TGVzc1wiLFxuICAgICAgICAgICAgICAgIFwiRXNjXCI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJGMTFcIjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgIWNtLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgIGlmIChvbGRFZGl0b3IgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxuICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLmNvZGVNaXJyb3IucmVmcmVzaC5iaW5kKHRoaXMuY29kZU1pcnJvciksIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBkeW5hbWljYWxseSB3aGVuIGNoYW5naW5nIGluc3RydWN0b3Igc3RhdHVzXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBuZXdGaWxlbmFtZS5zdGFydHNXaXRoKFwiJlwiKSAmJiAhdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpKTtcbiAgICB9XG5cbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0VmFsdWUobmV3Q29udGVudHMpO1xuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnJlZnJlc2goKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUhhbmRsZShldmVudCkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5jb2RlTWlycm9yLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9mZihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSk7XG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgVGV4dEVkaXRvciA9IHtcbiAgICBuYW1lOiBcIlRleHRcIixcbiAgICBleHRlbnNpb25zOiBbXCIudHh0XCJdLFxuICAgIGNvbnN0cnVjdG9yOiBUZXh0RWRpdG9yVmlldyxcbiAgICB0ZW1wbGF0ZTogVEVYVF9FRElUT1JfSFRNTFxufTsiLCJpbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBUT09MQk9YX0VESVRPUl9IVE1MID0gYFxyXG4gICAgPGRpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTEyXCJcclxuICAgICAgICAgcm9sZT1cInRvb2xiYXJcIiBhcmlhLWxhYmVsPVwiVG9vbGJveCBUb29sYmFyXCI+XHJcbiAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiU2F2ZSBHcm91cFwiPiAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGJ0bi1lZGl0b3ItanNvbi1zYXZlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtc2F2ZVwiPjwvc3Bhbj4gU2F2ZVxyXG4gICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktZWRpdG9yLXRvb2xib3hcIj48L3RleHRhcmVhPlxyXG4gICAgPC9kaXY+XHJcbmA7XHJcblxyXG5jbGFzcyBUb29sYm94RWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xyXG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yID0gQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEodGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItdG9vbGJveFwiKVswXSwge1xyXG4gICAgICAgICAgICBzaG93Q3Vyc29yV2hlblNlbGVjdGluZzogdHJ1ZSxcclxuICAgICAgICAgICAgbGluZU51bWJlcnM6IHRydWUsXHJcbiAgICAgICAgICAgIGZpcnN0TGluZU51bWJlcjogMSxcclxuICAgICAgICAgICAgaW5kZW50VW5pdDogNCxcclxuICAgICAgICAgICAgdGFiU2l6ZTogNCxcclxuICAgICAgICAgICAgaW5kZW50V2l0aFRhYnM6IGZhbHNlLFxyXG4gICAgICAgICAgICBtb2RlOiBcImpzb25cIixcclxuICAgICAgICAgICAgZXh0cmFLZXlzOiB7XHJcbiAgICAgICAgICAgICAgICBcIlRhYlwiOiBcImluZGVudE1vcmVcIixcclxuICAgICAgICAgICAgICAgIFwiU2hpZnQtVGFiXCI6IFwiaW5kZW50TGVzc1wiLFxyXG4gICAgICAgICAgICAgICAgXCJFc2NcIjogZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY20uZGlzcGxheS5pbnB1dC5ibHVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwiRjExXCI6IGZ1bmN0aW9uIChjbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgIWNtLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpIHtcclxuICAgICAgICBzdXBlci5lbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IodGhpcy5maWxlLmhhbmRsZSgpKTtcclxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHJlbGV2YW50IEZpbGVcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcclxuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXHJcbiAgICAgICAgdGhpcy5jdXJyZW50TGlzdGVuZXIgPSB0aGlzLnVwZGF0ZUhhbmRsZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudGFnLmZpbmQoXCIuYnRuLWVkaXRvci1qc29uLXNhdmVcIikub24oXCJjbGlja1wiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XHJcbiAgICAgICAgLy90aGlzLmNvZGVNaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIGlmIChvbGRFZGl0b3IgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5jb2RlTWlycm9yLnJlZnJlc2guYmluZCh0aGlzLmNvZGVNaXJyb3IpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogdXBkYXRlIGR5bmFtaWNhbGx5IHdoZW4gY2hhbmdpbmcgaW5zdHJ1Y3RvciBzdGF0dXNcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgbmV3RmlsZW5hbWUuc3RhcnRzV2l0aChcIiZcIikgJiYgIXRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldFZhbHVlKG5ld0NvbnRlbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5jb2RlTWlycm9yLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MudG9vbGJveCgpID09PSBcImN1c3RvbVwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IucmVsb2FkVG9vbGJveChcImN1c3RvbVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMudGFnLmZpbmQoXCIuYnRuLWVkaXRvci10b29sYm94LXNhdmVcIikub2ZmKFwiY2xpY2tcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9yLm9mZihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIGZhbHNlKTtcclxuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgVG9vbGJveEVkaXRvciA9IHtcclxuICAgIG5hbWU6IFwiVG9vbGJveFwiLFxyXG4gICAgZXh0ZW5zaW9uczogW1wiP3Rvb2xib3guYmxvY2tweVwiXSxcclxuICAgIGNvbnN0cnVjdG9yOiBUb29sYm94RWRpdG9yVmlldyxcclxuICAgIHRlbXBsYXRlOiBUT09MQk9YX0VESVRPUl9IVE1MXHJcbn07IiwiLyoqXG4gKiBFZGl0b3JzIGFyZSBpbmZlcnJlZCBmcm9tIEZpbGVuYW1lcy5cbiAqXG4gKiBUaGUgZWRpdG9yIGlzIGJhc2VkIG9uIHRoZSBleHRlbnNpb246XG4gKiAgLmJsb2NrcHk6IFNwZWNpYWwgZWRpdG9yICh3aWxsIGJlIGNob3NlbiBieSBmaWxlbmFtZSlcbiAqICAucHk6IFB5dGhvbiBFZGl0b3JcbiAqICAubWQ6IE1hcmtkb3duIEVkaXRvclxuICogIC50eHQ6IFRleHQgRWRpdG9yIChhbHNvIHVzZWQgZm9yIG90aGVyIHR5cGVzKVxuICogIC5wZW1sOiBQRU1MIEVkaXRvclxuICogIC5wbmcsIC5naWYsIC5qcGVnLCAuanBnLCAuYm1wOiBJbWFnZSBFZGl0b3JcbiAqICAuanNvbjogSlNPTiBFZGl0b3JcbiAqICAueWFtbDogWUFNTCBFZGl0b3JcbiAqL1xuXG5pbXBvcnQge1B5dGhvbkVkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL3B5dGhvblwiO1xuaW1wb3J0IHtUZXh0RWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvdGV4dFwiO1xuaW1wb3J0IHtBc3NpZ25tZW50U2V0dGluZ3N9IGZyb20gXCIuL2VkaXRvci9hc3NpZ25tZW50X3NldHRpbmdzXCI7XG5pbXBvcnQge1RhZ3NFZGl0b3J9IGZyb20gXCIuL2VkaXRvci90YWdzXCI7XG5pbXBvcnQge01hcmtkb3duRWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvbWFya2Rvd25cIjtcbmltcG9ydCB7U2FtcGxlU3VibWlzc2lvbnN9IGZyb20gXCIuL2VkaXRvci9zYW1wbGVfc3VibWlzc2lvbnNcIjtcbmltcG9ydCB7SnNvbkVkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL2pzb25cIjtcbmltcG9ydCB7VG9vbGJveEVkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL3Rvb2xib3hcIjtcblxuLyoqXG4gKiBUaGUgZGlmZmVyZW50IHBvc3NpYmxlIGVkaXRvcnMgYXZhaWxhYmxlXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgbGV0IEVkaXRvcnNFbnVtID0ge1xuICAgIFNVQk1JU1NJT046IFwic3VibWlzc2lvblwiLFxuICAgIEFTU0lHTk1FTlQ6IFwiYXNzaWdubWVudFwiLFxuICAgIElOU1RSVUNUSU9OUzogXCJpbnN0cnVjdGlvbnNcIixcbiAgICBPTl9SVU46IFwib25fcnVuXCIsXG4gICAgT05fQ0hBTkdFOiBcIm9uX2NoYW5nZVwiLFxuICAgIE9OX0VWQUw6IFwib25fZXZhbFwiLFxuICAgIFNUQVJUSU5HX0NPREU6IFwic3RhcnRpbmdfY29kZVwiLFxuICAgIFNBTVBMRV9TVUJNSVNTSU9OUzogXCJzYW1wbGVfc3VibWlzc2lvbnNcIixcbiAgICBJTlNUUlVDVE9SX0ZJTEU6IFwiaW5zdHJ1Y3Rvcl9maWxlXCJcbn07XG5cbmNvbnN0IFNQRUNJQUxfTkFNRVNQQUNFUyA9IFtcIiFcIiwgXCJeXCIsIFwiP1wiLCBcIiRcIl07XG5cbmNvbnN0IEFWQUlMQUJMRV9FRElUT1JTID0gW1xuICAgIFRleHRFZGl0b3IsIFB5dGhvbkVkaXRvciwgQXNzaWdubWVudFNldHRpbmdzLCBUYWdzRWRpdG9yLCBNYXJrZG93bkVkaXRvcixcbiAgICBTYW1wbGVTdWJtaXNzaW9ucywgSnNvbkVkaXRvciwgVG9vbGJveEVkaXRvclxuXTtcblxuZXhwb3J0IGNvbnN0IEVESVRPUlNfSFRNTCA9IEFWQUlMQUJMRV9FRElUT1JTLm1hcChlZGl0b3IgPT4gYFxuPGRpdiBjbGFzcz1cImNvbC1tZC0xMiBibG9ja3B5LXBhbmVsIGJsb2NrcHktZWRpdG9yXCIgXG4gICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmVkaXRvcnMudmlldygpLm5hbWUgPT09ICcke2VkaXRvci5uYW1lfSdcIj5cbiAgICA8ZGl2PlxuICAgICR7ZWRpdG9yLnRlbXBsYXRlfVxuICAgIDwvZGl2PlxuPC9kaXY+XG5gXG4gICAgLypcbiAgICBgXG48IS0tIGtvIGlmOiB1aS5lZGl0b3JzLnZpZXcoKS5uYW1lID09PSAnJHtlZGl0b3IubmFtZX0nIC0tPlxuJHtlZGl0b3IudGVtcGxhdGV9XG48IS0tIC9rbyAtLT5gKi9cbikuam9pbihcIlxcblwiKTtcblxuZXhwb3J0IGNsYXNzIEVkaXRvcnMge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkXyA9IFtdO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnNfID0ge307XG4gICAgICAgIHRoaXMuYnlOYW1lXyA9IHt9O1xuICAgICAgICBBVkFJTEFCTEVfRURJVE9SUy5mb3JFYWNoKGVkaXRvciA9PiB0aGlzLnJlZ2lzdGVyRWRpdG9yKGVkaXRvcikpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5maWxlbmFtZS5zdWJzY3JpYmUodGhpcy5jaGFuZ2VFZGl0b3IsIHRoaXMpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyRWRpdG9yKGRhdGEpIHtcbiAgICAgICAgbGV0IGV4dGVuc2lvbnMgPSBkYXRhLmV4dGVuc2lvbnM7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IG5ldyBkYXRhLmNvbnN0cnVjdG9yKHRoaXMubWFpbiwgdGhpcy50YWcpO1xuICAgICAgICBpbnN0YW5jZS5uYW1lID0gZGF0YS5uYW1lO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRfLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICB0aGlzLmJ5TmFtZV9bZGF0YS5uYW1lLnRvTG93ZXJDYXNlKCldID0gaW5zdGFuY2U7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9uc19bZXh0ZW5zaW9uc1tpXV0gPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJ5TmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5TmFtZV9bbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG5cbiAgICBjaGFuZ2VFZGl0b3IobmV3RmlsZW5hbWUpIHtcbiAgICAgICAgbGV0IG9sZEVkaXRvciA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgbGV0IG5ld0VkaXRvciA9IHRoaXMuZ2V0RWRpdG9yKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvbGRFZGl0b3IuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG5ld0VkaXRvcjtcbiAgICAgICAgdGhpcy5jdXJyZW50LmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZUZpbGVuYW1lKHBhdGgpIHtcbiAgICAgICAgbGV0IHNwYWNlID0gcGF0aC5jaGFyQXQoMCk7XG4gICAgICAgIGlmIChTUEVDSUFMX05BTUVTUEFDRVMuaW5kZXhPZihzcGFjZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcGFjZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWUgPSBwYXRoLnN1YnN0cigwLCBwYXRoLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgICAgIGxldCB0eXBlID0gcGF0aC5zdWJzdHIocGF0aC5sYXN0SW5kZXhPZihcIi5cIikpO1xuICAgICAgICByZXR1cm4ge1wic3BhY2VcIjogc3BhY2UsIFwibmFtZVwiOiBuYW1lLCBcInR5cGVcIjogdHlwZX07XG4gICAgfVxuXG4gICAgZ2V0RWRpdG9yKHBhdGgpIHtcbiAgICAgICAgbGV0IHtzcGFjZSwgbmFtZSwgdHlwZX0gPSBFZGl0b3JzLnBhcnNlRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIGlmICh0eXBlID09PSBcIi5ibG9ja3B5XCIgJiYgcGF0aCBpbiB0aGlzLmV4dGVuc2lvbnNfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zX1twYXRoXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlIGluIHRoaXMuZXh0ZW5zaW9uc18pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnNfW3R5cGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJlZF9bMF07XG4gICAgICAgIH1cbiAgICB9XG5cbn0iLCJpbXBvcnQge1N0YXR1c1N0YXRlfSBmcm9tIFwiLi9zZXJ2ZXJcIjtcbmltcG9ydCB7T25SdW5Db25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvb25fcnVuXCI7XG5pbXBvcnQge1J1bkNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2VuZ2luZS9ydW5cIjtcbmltcG9ydCB7RXZhbENvbmZpZ3VyYXRpb259IGZyb20gXCIuL2VuZ2luZS9ldmFsXCI7XG5pbXBvcnQge1NhbXBsZUNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2VuZ2luZS9zYW1wbGVcIjtcbmltcG9ydCB7T25DaGFuZ2VDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvb25fY2hhbmdlXCI7XG5pbXBvcnQge09uRXZhbENvbmZpZ3VyYXRpb259IGZyb20gXCIuL2VuZ2luZS9vbl9ldmFsXCI7XG5pbXBvcnQge09uU2FtcGxlQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL29uX3NhbXBsZVwiO1xuXG4vKipcbiAqIEFuIG9iamVjdCBmb3IgZXhlY3V0aW5nIFB5dGhvbiBjb2RlIGFuZCBwYXNzaW5nIHRoZSByZXN1bHRzIGFsb25nIHRvIGludGVyZXN0ZWQgY29tcG9uZW50cy5cbiAqXG4gKiBJbnRlcmVzdGluZyBjb21wb25lbnRzOlxuICogIEV4ZWN1dGlvbiBCdWZmZXI6IFJlc3BvbnNpYmxlIGZvciBjb2xsZWN0aW5nIHRoZSB0cmFjZSBkdXJpbmcgcHJvZ3JhbSBleGVjdXRpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgVGhpcyBwcmV2ZW50cyBLbm9ja291dGpzIGZyb20gdXBkYXRpbmcgdGhlIGVkaXRvciBkdXJpbmcgZXhlY3V0aW9uLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0Jsb2NrUHlFZGl0b3J9XG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZyAtIFRoZSBIVE1MIG9iamVjdCB0aGlzIGlzIGF0dGFjaGVkIHRvLlxuICovXG5leHBvcnQgY2xhc3MgQmxvY2tQeUVuZ2luZSB7XG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLmV4ZWN1dGlvbk1vZGVsID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbjtcblxuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25zID0ge1xuICAgICAgICAgICAgcnVuOiBuZXcgUnVuQ29uZmlndXJhdGlvbihtYWluKSxcbiAgICAgICAgICAgIGV2YWw6IG5ldyBFdmFsQ29uZmlndXJhdGlvbihtYWluKSxcbiAgICAgICAgICAgIG9uUnVuOiBuZXcgT25SdW5Db25maWd1cmF0aW9uKG1haW4pLFxuICAgICAgICAgICAgb25DaGFuZ2U6IG5ldyBPbkNoYW5nZUNvbmZpZ3VyYXRpb24obWFpbiksXG4gICAgICAgICAgICBvbkV2YWw6IG5ldyBPbkV2YWxDb25maWd1cmF0aW9uKG1haW4pXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHJlY29uZmlndXJlIHNrdWxwdCBzbyB3ZSBjYW4gcGFyc2VcbiAgICAgICAgU2suY29uZmlndXJlKHRoaXMuY29uZmlndXJhdGlvbnMucnVuLmdldFNrdWxwdE9wdGlvbnMoKSk7XG5cbiAgICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHRyYWNpbmcgd2hpbGUgdGhlIHByb2dyYW0gaXMgZXhlY3V0aW5nXG4gICAgICAgIHRoaXMuZXhlY3V0aW9uQnVmZmVyID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluYWJsZSBmdW5jdGlvbiB0byBiZSBydW4gd2hlbiBleGVjdXRpb24gaGFzIGZ1bGx5IGVuZGVkLFxuICAgICAgICAgKiB3aGV0aGVyIGl0IHN1Y2NlZWRzIG9yIGZhaWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkV4ZWN1dGlvbkJlZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkV4ZWN1dGlvbkVuZCA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgcmVwb3J0c1xuICAgICAqL1xuICAgIHJlc2V0UmVwb3J0cygpIHtcbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMuZXhlY3V0aW9uTW9kZWwucmVwb3J0cztcbiAgICAgICAgcmVwb3J0W1widmVyaWZpZXJcIl0gPSB7fTtcbiAgICAgICAgcmVwb3J0W1wicGFyc2VyXCJdID0ge307XG4gICAgICAgIHJlcG9ydFtcInN0dWRlbnRcIl0gPSB7fTtcbiAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXSA9IHt9O1xuICAgICAgICByZXBvcnRbXCJtb2RlbFwiXSA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICB9O1xuXG4gICAgcmVzZXRTdHVkZW50TW9kZWwoKSB7XG4gICAgICAgIGxldCBzdHVkZW50ID0gdGhpcy5leGVjdXRpb25Nb2RlbC5zdHVkZW50O1xuICAgICAgICBzdHVkZW50LmNhbGxzID0ge307XG4gICAgICAgIHN0dWRlbnQuY3VycmVudFN0ZXAobnVsbCk7XG4gICAgICAgIHN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCgwKTtcbiAgICAgICAgc3R1ZGVudC5sYXN0U3RlcCgwKTtcbiAgICAgICAgc3R1ZGVudC5jdXJyZW50TGluZShudWxsKTtcbiAgICAgICAgc3R1ZGVudC5jdXJyZW50VHJhY2VEYXRhLnJlbW92ZUFsbCgpO1xuICAgICAgICBzdHVkZW50LnJlc3VsdHMgPSBudWxsO1xuICAgIH1cblxuICAgIHJlc2V0RXhlY3V0aW9uQnVmZmVyKCkge1xuICAgICAgICB0aGlzLmV4ZWN1dGlvbkJ1ZmZlciA9IHtcbiAgICAgICAgICAgIFwidHJhY2VcIjogW10sXG4gICAgICAgICAgICBcInN0ZXBcIjogMCxcbiAgICAgICAgICAgIFwibGluZVwiOiAwLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGludGVyZmFjZSBhc3BlY3RzIG9mIHRoZSBwcmV2aW91cyBSdW4uXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIC8vIFRPRE86IENsZWFyIG91dCBhbnkgY292ZXJhZ2UvdHJhY2UvZXJyb3IgaGlnaGxpZ2h0cyBpbiBlZGl0b3JzXG4gICAgICAgIC8vIFJlc2V0IGV4ZWN1dGlvbiBpbiBtb2RlbFxuICAgICAgICB0aGlzLnJlc2V0U3R1ZGVudE1vZGVsKCk7XG4gICAgICAgIC8vIEdldCByZXBvcnRzIHJlYWR5XG4gICAgICAgIHRoaXMucmVzZXRSZXBvcnRzKCk7XG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgZXhlY3V0aW9uIGJ1ZmZlclxuICAgICAgICB0aGlzLnJlc2V0RXhlY3V0aW9uQnVmZmVyKCk7XG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgY29uc29sZSBvZiBwcmludGVkIHN0dWZmXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuY2xlYXIoKTtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IGFueSBvbGQgZmVlZGJhY2tcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2suY2xlYXIoKTtcbiAgICB9XG5cbiAgICBkZWxheWVkUnVuKCkge1xuICAgICAgICAvL3RoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuQUNUSVZFKTtcbiAgICAgICAgLy8kKFwiLmJsb2NrcHktcnVuXCIpLmFkZENsYXNzKFwiYmxvY2tweS1ydW4tcnVubmluZ1wiKTtcbiAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgLy9zZXRUaW1lb3V0KHRoaXMucnVuLmJpbmQodGhpcyksIDEpO1xuICAgIH1cblxuICAgIHJ1bigpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5ydW4udXNlKHRoaXMpO1xuICAgICAgICBsZXQgZXhlY3V0aW9uID0gdGhpcy5leGVjdXRlKCkudGhlbihcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5zdWNjZXNzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSxcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5mYWlsdXJlLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVGZWVkYmFjaygpKSB7XG4gICAgICAgICAgICBleGVjdXRpb24udGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnByb3ZpZGVTZWNyZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uUnVuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4ZWN1dGlvbi50aGVuKHRoaXMuY29uZmlndXJhdGlvbi5zaG93RXJyb3JzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhlY3V0aW9uLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLmZpbmFsbHkuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKTtcbiAgICB9XG5cbiAgICBvblJ1bigpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5vblJ1bi51c2UodGhpcyk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZSgpLnRoZW4oXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uc3VjY2Vzcy5iaW5kKHRoaXMuY29uZmlndXJhdGlvbiksXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZmFpbHVyZS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgICAgKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLmZpbmFsbHkuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5leGVjdXRpb25FbmRfLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIGV2YWx1YXRlKCkge1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkFDVElWRSk7XG4gICAgICAgIGxldCBldmFsdWF0aW9uSW5wdXQgPSB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLmV2YWx1YXRlKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2YWx1YXRpb25JbnB1dCk7XG4gICAgICAgIGV2YWx1YXRpb25JbnB1dC50aGVuKCh1c2VySW5wdXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMuZXZhbC51c2UodGhpcywgdXNlcklucHV0KTtcbiAgICAgICAgICAgIGxldCBleGVjdXRpb24gPSB0aGlzLmV4ZWN1dGUoKS50aGVuKFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5zdWNjZXNzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZmFpbHVyZS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVGZWVkYmFjaygpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25FdmFsKCkpIHtcbiAgICAgICAgICAgICAgICBleGVjdXRpb24udGhlbih0aGlzLm9uRXZhbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLnNob3dFcnJvcnMuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKVxuICAgICAgICAgICAgICAgICAgICAudGhlbih0aGlzLmV2YWx1YXRlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhlY3V0aW9uLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLmZpbmFsbHkuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25FdmFsKCkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLm9uRXZhbC51c2UodGhpcyk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZSgpLnRoZW4oXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uc3VjY2Vzcy5iaW5kKHRoaXMuY29uZmlndXJhdGlvbiksXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZmFpbHVyZS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgICAgKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5ldmFsdWF0ZS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLmZpbmFsbHkuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKTtcbiAgICB9XG5cbiAgICBvbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5vbkNoYW5nZS51c2UodGhpcyk7XG4gICAgfVxuXG4gICAgZXhlY3V0ZSgpIHtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICByZXR1cm4gU2subWlzY2V2YWwuYXN5bmNUb1Byb21pc2UoKCkgPT5cbiAgICAgICAgICAgIFNrLmltcG9ydE1haW5XaXRoQm9keSh0aGlzLmNvbmZpZ3VyYXRpb24uZmlsZW5hbWUsIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5jb2RlLCB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5zeXNtb2R1bGVzKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlZCB3aGVuZXZlciB0aGUgUHl0aG9uIGNvZGUgY2hhbmdlc1xuICAgICAqL1xuICAgIG9uX2NoYW5nZSgpIHtcbiAgICAgICAgbGV0IEZJTEVOQU1FID0gXCJvbl9jaGFuZ2VcIjtcbiAgICAgICAgLy8gU2tpcCBpZiB0aGUgaW5zdHJ1Y3RvciBoYXMgbm90IGRlZmluZWQgYW55dGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLm1haW4ubW9kZWwucHJvZ3JhbXNbRklMRU5BTUVdKCkudHJpbSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdGF0dXMoXCJjaGFuZ2luZ1wiKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnNhdmVDb2RlKCk7XG4gICAgICAgIC8vIE9uIHN0ZXAgZG9lcyBub3QgcGVyZm9ybSBwYXJzZSBhbmFseXNpcyBieSBkZWZhdWx0IG9yIHJ1biBzdHVkZW50IGNvZGVcbiAgICAgICAgbGV0IGVuZ2luZSA9IHRoaXM7XG4gICAgICAgIGxldCBmZWVkYmFjayA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrO1xuICAgICAgICBlbmdpbmUucmVzZXRSZXBvcnRzKCk7XG4gICAgICAgIGVuZ2luZS52ZXJpZnlDb2RlKCk7XG4gICAgICAgIGVuZ2luZS51cGRhdGVQYXJzZSgpO1xuICAgICAgICBlbmdpbmUucnVuSW5zdHJ1Y3RvckNvZGUoRklMRU5BTUUsIHRydWUsIGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0pIHtcbiAgICAgICAgICAgICAgICAvLyBTVUNDRVNTLCBTQ09SRSwgQ0FURUdPUlksIExBQkVMLCBNRVNTQUdFLCBEQVRBLCBISURFXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogb25seSBzaG93IHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlc1xuICAgICAgICAgICAgICAgIGlmICghc3VjY2VzcyAmJlxuICAgICAgICAgICAgICAgICAgICAhKGNhdGVnb3J5ID09PSBcIkluc3RydWN0b3JcIiAmJiBsYWJlbCA9PT0gXCJObyBlcnJvcnNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVlZGJhY2sucHJlc2VudEZlZWRiYWNrKGNhdGVnb3J5LCBsYWJlbCwgbWVzc2FnZSwgbGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuZ2luZS5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2sucHJlc2VudEZlZWRiYWNrKG1vZHVsZS4kZCk7XG4gICAgICAgICAgICAgICAgZW5naW5lLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0YXR1cyhcImNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZW5naW5lLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJlbmdpbmVcIiwgXCJvbl9jaGFuZ2VcIik7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBhdHRlbXB0IHRvIGNhbGwgdGhlIGRlZmluZWQgb25FeGVjdXRpb25FbmQsXG4gICAgICogYnV0IHdpbGwgZG8gbm90aGluZyBpZiB0aGVyZSBpcyBubyBmdW5jdGlvbiBkZWZpbmVkLlxuICAgICAqL1xuICAgIGV4ZWN1dGlvbkVuZF8oKSB7XG4gICAgICAgIGlmICh0aGlzLm9uRXhlY3V0aW9uRW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXhlY3V0aW9uRW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGV4ZWN1dGlvbkJlZ2luXygpIHtcbiAgICAgICAgaWYgKHRoaXMub25FeGVjdXRpb25CZWdpbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vbkV4ZWN1dGlvbkJlZ2luKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuIiwiZXhwb3J0IGNvbnN0IEVNUFRZX01PRFVMRSA9IFwibGV0ICRidWlsdGlubW9kdWxlID0gZnVuY3Rpb24obW9kKXsgcmV0dXJuIG1vZDsgfVwiO1xuXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBob2xkaW5nIHNldHRpbmdzIG9mIGEgcGFydGljdWxhciBydW4gY29uZmlndXJhdGlvbi5cbiAqIFRoaXMgaXMgdGhlIHJvb3QgY2xhc3MgZm9yIGFsbCBvdGhlciBjb25maWd1cmF0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbmZpZ3VyYXRpb24ge1xuXG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zeXNtb2R1bGVzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgLy8gQWNjZXNzIHBvaW50IGZvciBpbnN0cnVjdG9yIGRhdGFcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHMgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIFNrLmNvbnNvbGUgPSB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlO1xuICAgICAgICBTay5xdWV1ZWRJbnB1dCA9IFtdO1xuICAgICAgICBTay5jb25maWd1cmUodGhpcy5nZXRTa3VscHRPcHRpb25zKCkpO1xuICAgICAgICAvLyBTZXQgb3BlbkZpbGUgYXMgbWVjaGFuaXNtIHRvIHJlYWQgZmlsZXNcbiAgICAgICAgU2suaW5Ccm93c2VyID0gdGhpcy5vcGVuRmlsZS5iaW5kKHRoaXMpO1xuICAgICAgICAvLyBQcm94eSByZXF1ZXN0c1xuICAgICAgICBTay5yZXF1ZXN0c0dldCA9ICh1cmwsIGRhdGEsIHRpbWVvdXQpID0+IHRoaXMub3BlblVSTCh1cmwsIGRhdGEsIHRpbWVvdXQpO1xuICAgICAgICAvLyBDb25maWd1cmUgYSBcImRvIHlvdSB3YW50IHRvIHdhaXQ/IHByb21wdFwiXG4gICAgICAgIFNrLnRpbWVvdXRIYW5kbGVyID0gKHRpbWVQYXNzZWQsIGV4ZWNMaW1pdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVUaW1lb3V0KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwcm9tcHRNZXNzYWdlID0gdGhpcy5nZXRUaW1lb3V0UHJvbXB0KHRpbWVQYXNzZWQvMTAwMCA+IDMwKTtcbiAgICAgICAgICAgIGxldCBkZWxheSA9IHByb21wdChwcm9tcHRNZXNzYWdlLCBTay5leGVjTGltaXQvMTAwMCk7XG4gICAgICAgICAgICBpZiAoZGVsYXkgIT09IG51bGwgfHwgZGVsYXk9PTApIHtcbiAgICAgICAgICAgICAgICBkZWxheSA9IFNrLmV4ZWNMaW1pdCArIHBhcnNlSW50KGRlbGF5LCAxMCkgKiAxMDAwO1xuICAgICAgICAgICAgICAgIFNrLmV4ZWNMaW1pdCA9IGRlbGF5O1xuICAgICAgICAgICAgICAgIFNrLmV4ZWNMaW1pdEZ1bmN0aW9uID0gKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZVRpbWVvdXQoKSA/IEluZmluaXR5IDogZGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVsYXk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldFRpbWVvdXRQcm9tcHQobG9uZ1RpbWVvdXQpIHtcbiAgICAgICAgaWYgKGxvbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgcHJvZ3JhbSBoYXMgdGFrZW4gYSBSRUFMTFkgbG9uZyB0aW1lIHRvIHJ1biAoMzAgb3IgbW9yZSBzZWNvbmRzKS4gWW91IG1pZ2h0IHdhbnQgdG8gY2FuY2VsIGFuZCBjaGVjayB5b3VyIGNvZGUuIE9yLCB5b3UgY2FuIGFkZCBtb3JlIHNlY29uZHMgdG8gd2FpdCBiZWxvdy5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlRoZSBwcm9ncmFtIGlzIHRha2luZyBhIHdoaWxlIHRvIHJ1bi4gSG93IG1hbnkgbW9yZSBzZWNvbmRzIHdvdWxkIHlvdSBsaWtlIHRvIHdhaXQ/XCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRTa3VscHRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19mdXR1cmVfXzogU2sucHl0aG9uMyxcbiAgICAgICAgICAgIC8vIGltcG9ydFxuICAgICAgICAgICAgcmVhZDogdGhpcy5pbXBvcnRGaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICAvLyBvcGVuXG4gICAgICAgICAgICAvL2ZpbGVvcGVuOiB0aGlzLm9wZW5GaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICAvLyBmaWxlLndyaXRlXG4gICAgICAgICAgICBmaWxld3JpdGU6IHRoaXMud3JpdGVGaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICAvLyBwcmludFxuICAgICAgICAgICAgb3V0cHV0OiB0aGlzLnByaW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICAvLyBpbnB1dFxuICAgICAgICAgICAgaW5wdXRmdW46IHRoaXMuaW5wdXQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGlucHV0ZnVuVGFrZXNQcm9tcHQ6IHRydWUsXG4gICAgICAgICAgICAvLyBNZWRpYSBJbWFnZSBQcm94eSBVUkxcbiAgICAgICAgICAgIGltYWdlUHJveHk6IHRoaXMuZ2V0SW1hZ2VQcm94eS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgLy8gV2hldGhlciBvciBub3QgdG8ga2VlcCB0aGUgZ2xvYmFsc1xuICAgICAgICAgICAgcmV0YWluR2xvYmFsczogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gYWNjZXNzIFNrdWxwdCBidWlsdC1pbnMuIFRoaXMgaXMgcHJldHR5IGdlbmVyaWMsIHRha2VuXG4gICAgICogYWxtb3N0IGRpcmVjdGx5IGZyb20gdGhlIFNrdWxwdCBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIC0gVGhlIHB5dGhvbiBmaWxlbmFtZSAoZS5nLiwgXCJvc1wiIG9yIFwicHByaW50XCIpIHRoYXQgd2lsbCBiZSBsb2FkZWQuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIEphdmFTY3JpcHQgc291cmNlIGNvZGUgb2YgdGhlIGZpbGUgKHdlaXJkLCByaWdodD8pXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBmaWxlIGlzbid0IGZvdW5kLlxuICAgICAqL1xuICAgIGltcG9ydEZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5pbXBsZW1lbnRlZCBtZXRob2QhXCIpO1xuICAgICAgICAvLyBUT0RPXG4gICAgfTtcblxuICAgIG9wZW5VUkwodXJsLCBkYXRhLCB0aW1lb3V0KSB7XG4gICAgICAgIC8vcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IG1vY2tVcmxEYXRhID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5nZXRGaWxlKFwiP21vY2tfdXJscy5ibG9ja3B5XCIpO1xuICAgICAgICBpZiAobW9ja1VybERhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgKG5ldyBTay5idWlsdGluLklPRXJyb3IoXCJDYW5ub3QgYWNjZXNzIHVybDogVVJMIERhdGEgd2FzIG5vdCBtYWRlIGF2YWlsYWJsZSBmb3IgdGhpcyBhc3NpZ25tZW50XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBtb2NrVXJsRGF0YSA9IEpTT04ucGFyc2UobW9ja1VybERhdGEuaGFuZGxlKCkpO1xuICAgICAgICBmb3IgKGxldCBmaWxlbmFtZSBpbiBtb2NrVXJsRGF0YSkge1xuICAgICAgICAgICAgaWYgKG1vY2tVcmxEYXRhLmhhc093blByb3BlcnR5KGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaSA8IG1vY2tVcmxEYXRhW2ZpbGVuYW1lXS5sZW5ndGg7IGkrPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2NrVXJsRGF0YVtmaWxlbmFtZV1baV0gPT09IHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVEYXRhID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5yZWFkRmlsZShmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGZpbGVEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL3JlamVjdChuZXcgU2suYnVpbHRpbi5JT0Vycm9yKFwiQ2Fubm90IGFjY2VzcyB1cmw6IFwiK3VybCtcIiB3YXMgbm90IG1hZGUgYXZhaWxhYmxlIGZvciB0aGlzIGFzc2lnbm1lbnRcIikpO1xuICAgICAgICB0aHJvdyAobmV3IFNrLmJ1aWx0aW4uSU9FcnJvcihcIkNhbm5vdCBhY2Nlc3MgdXJsOiBcIit1cmwrXCIgd2FzIG5vdCBtYWRlIGF2YWlsYWJsZSBmb3IgdGhpcyBhc3NpZ25tZW50XCIpKTtcbiAgICAgICAgLy99KTtcbiAgICB9XG5cbiAgICBvcGVuRmlsZSgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5pbXBsZW1lbnRlZCBtZXRob2QhXCIpO1xuICAgICAgICAvLyBUT0RPXG4gICAgfVxuXG4gICAgd3JpdGVGaWxlKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJVbmltcGxlbWVudGVkIG1ldGhvZCFcIik7XG4gICAgICAgIC8vIFRPRE9cbiAgICB9XG5cbiAgICBwcmludCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgICBpbnB1dCgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5pbXBsZW1lbnRlZCBtZXRob2QhXCIpO1xuICAgICAgICAvLyBUT0RPXG4gICAgfVxuXG4gICAgY2xlYXJJbnB1dCgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmNsZWFySW5wdXRzKCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoW10pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleCgwKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW5wdXRNb2NrRnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChTay5xdWV1ZWRJbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBTay5xdWV1ZWRJbnB1dC5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGdldEltYWdlUHJveHkodXJsKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICBzdGVwKCkge1xuXG4gICAgfVxuXG4gICAgbGFzdFN0ZXAoKSB7XG5cbiAgICB9XG5cbiAgICBpc0ZvcmJpZGRlbihmaWxlbmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3VjY2Vzcyhtb2R1bGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWJzdHJhY3Qgc3VjY2VzcyBleGVjdXRpb25cIik7XG4gICAgfVxuXG4gICAgZmFpbHVyZShlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdCBmYWlsdXJlIGV4ZWN1dGlvblwiKTtcbiAgICB9XG5cbiAgICBmaW5hbGx5KHJlc3VsdCkge1xuICAgICAgICAvLyBGb3JjZSBQeWdhbWUgdG8gc3RvcCB0cmFwcGluZyBrZXlib2FyZCBldmVudHNcbiAgICAgICAgaWYgKHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUucHlnYW1lTGluZSkge1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5weWdhbWVMaW5lLmNsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUucHlnYW1lTGluZS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkdW1teU91dFNhbmRib3goKSB7XG4gICAgICAgIC8vU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi9wZWRhbC9zYW5kYm94L3NhbmRib3gucHlcIl0gPSBcImNsYXNzIFNhbmRib3g6IHBhc3NcXG5kZWYgcnVuKCk6IHBhc3NcXG5kZWYgcmVzZXQoKTogcGFzc1xcblwiO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IHtTdHVkZW50Q29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc3R1ZGVudFwiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4uL3NlcnZlclwiO1xuaW1wb3J0IHtCbG9ja1B5VHJhY2V9IGZyb20gXCIuLi90cmFjZVwiO1xuXG5leHBvcnQgY2xhc3MgRXZhbENvbmZpZ3VyYXRpb24gZXh0ZW5kcyBTdHVkZW50Q29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSwgY29kZSkge1xuICAgICAgICAvLyBUT0RPOiBmaXggdG8gYmUgY3VycmVudGx5IGFkZGVkIGxpbmVcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5tZXNzYWdlKFwiUnVubmluZy4uLlwiKTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwiYW5zd2VyXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiXyA9IFwiICsgY29kZTtcbiAgICAgICAgU2suYWZ0ZXJTaW5nbGVFeGVjdXRpb24gPSBudWxsO1xuICAgICAgICBTay5iZWZvcmVDYWxsID0gbnVsbDtcblxuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcblxuICAgICAgICBTay5yZXRhaW5HbG9iYWxzID0gdHJ1ZTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5nbG9iYWxzKCk7XG5cbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1GaWxlLkFkZFwiLCBcIlwiLCBcIlwiLCBjb2RlLCBcImV2YWx1YXRpb25zXCIpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJDb21waWxlXCIsIFwiXCIsIFwiXCIsIHRoaXMuY29kZSwgXCJldmFsdWF0aW9uc1wiKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdWNjZXNzKG1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkV2YWwgc3VjY2Vzc1wiKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1FdmFsdWF0ZS5Qcm9ncmFtXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiZXZhbHVhdGlvbnNcIik7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuZ2xvYmFscyhTay5nbG9iYWxzKTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHt9O1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBsZXQgZmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQucmVzdWx0cyA9IG1vZHVsZTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5wcmludFZhbHVlKFNrLmZmaS5yZW1hcFRvSnMobW9kdWxlLiRkLl8uJHIoKSkpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy90aGlzLnN0ZXAobW9kdWxlLiRkLCBtb2R1bGUuJGQsLTEsIDAsIGZpbGVuYW1lICsgXCIucHlcIik7XG4gICAgICAgICAgICB0aGlzLmxhc3RTdGVwKCk7XG4gICAgICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge1xuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwidHJhY2VcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLFxuICAgICAgICAgICAgICAgIFwibGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJyZWFsTGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLmZpbHRlcih4ID0+ICF4LmlzRG9jc3RyaW5nKS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwicmVzdWx0c1wiOiBtb2R1bGUsXG4gICAgICAgICAgICAgICAgXCJvdXRwdXRcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5vdXRwdXQsXG4gICAgICAgICAgICAgICAgXCJldmFsdWF0aW9uXCI6IHRoaXMuY29kZSxcbiAgICAgICAgICAgICAgICBcImNhbGxzXCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jYWxsc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmFpbHVyZShlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkV2YWwgZmFpbHVyZVwiKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5GQUlMRUQpO1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJDb21waWxlLkVycm9yXCIsIFwiXCIsIFwiXCIsIGVycm9yLnRvU3RyaW5nKCksIFwiZXZhbHVhdGlvbnNcIik7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge1xuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImVycm9yXCI6IGVycm9yLFxuICAgICAgICAgICAgICAgIFwiZXZhbHVhdGlvblwiOiB0aGlzLmNvZGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSIsImltcG9ydCB7Q29uZmlndXJhdGlvbiwgRU1QVFlfTU9EVUxFfSBmcm9tIFwiLi9jb25maWd1cmF0aW9ucy5qc1wiO1xuaW1wb3J0IHskc2tfbW9kX2luc3RydWN0b3J9IGZyb20gXCIuLi9za3VscHRfbW9kdWxlcy9za19tb2RfaW5zdHJ1Y3RvclwiO1xuaW1wb3J0IHskc2tfbW9kX2NvdmVyYWdlfSBmcm9tIFwiLi4vc2t1bHB0X21vZHVsZXMvY292ZXJhZ2VcIjtcbmltcG9ydCB7JHBlZGFsX3RyYWNlcn0gZnJvbSBcIi4uL3NrdWxwdF9tb2R1bGVzL3BlZGFsX3RyYWNlclwiO1xuXG5jb25zdCBVVElMSVRZX01PRFVMRV9DT0RFID0gXCJ2YXIgJGJ1aWx0aW5tb2R1bGUgPSBcIiArICRza19tb2RfaW5zdHJ1Y3Rvci50b1N0cmluZygpO1xuY29uc3QgQ09WRVJBR0VfTU9EVUxFX0NPREUgPSAkc2tfbW9kX2NvdmVyYWdlO1xuXG5leHBvcnQgY2xhc3MgSW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb24gZXh0ZW5kcyBDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICAvLyBJbnN0cnVjdG9ycyBnZXQgNCBzZWNvbmRzXG4gICAgICAgIFNrLmV4ZWNMaW1pdEZ1bmN0aW9uID0gKCkgPT5cbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVUaW1lb3V0KCkgPyBJbmZpbml0eSA6IDcwMDA7XG4gICAgICAgIFNrLmV4ZWNMaW1pdCA9IFNrLmV4ZWNMaW1pdEZ1bmN0aW9uKCk7XG4gICAgICAgIC8vIFN0ZXBwZXIhIEV4ZWN1dGVkIGFmdGVyIGV2ZXJ5IHN0YXRlbWVudC5cbiAgICAgICAgU2suYWZ0ZXJTaW5nbGVFeGVjdXRpb24gPSBudWxsOyAvLyAxMCAqMTAwMFxuICAgICAgICBTay5iZWZvcmVDYWxsID0gbnVsbDtcbiAgICAgICAgLy8gTXV0ZSBldmVyeXRoaW5nXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lm11dGVQcmludGVyKHRydWUpO1xuICAgICAgICAvLyBEaXNhYmxlIGlucHV0IGJveFxuICAgICAgICBTay5xdWV1ZWRJbnB1dCA9IFtdO1xuICAgICAgICAvLyBUT0RPIFNrLmlucHV0ZnVuID0gQmxvY2tQeUVuZ2luZS5pbnB1dE1vY2tGdW5jdGlvbjtcbiAgICAgICAgLy8gVE9ETzogQWxsb3cgaW5wdXQgZnVuY3Rpb24gdG8gZGlzYWJsZSB0aGUgdGltZXIsIHNvbWVob3dcbiAgICAgICAgLy8gRW5hYmxlIHV0aWxpdHkgbW9kZVxuICAgICAgICBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL3V0aWxpdHkvX19pbml0X18uanNcIl0gPSBVVElMSVRZX01PRFVMRV9DT0RFO1xuICAgICAgICBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL2NvdmVyYWdlLnB5XCJdID0gQ09WRVJBR0VfTU9EVUxFX0NPREU7XG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgbmVlZHMgdG8gYmUgb3B0aW1pemVkXG4gICAgICAgIC8vY29uc3QgUEVEQUxfVFJBQ0VSX01PRFVMRV9DT0RFID0gU2suY29tcGlsZSgkcGVkYWxfdHJhY2VyLCBcInRyYWNlci5weVwiLCBcImV4ZWNcIiwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL3BlZGFsL3NhbmRib3gvdHJhY2VyLnB5XCJdID0gJHBlZGFsX3RyYWNlcjtcbiAgICAgICAgZGVsZXRlIFNrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvcGVkYWwvc2FuZGJveC90cmFjZXIuanNcIl07XG4gICAgICAgIC8vIFRPRE86IE1vY2sgUGVkYWwncyB0cmFjZXIgbW9kdWxlIHdpdGggdGhlIGFwcHJvcHJpYXRlIHZlcnNpb25cbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wiLi9faW5zdHJ1Y3Rvci9fX2luaXRfXy5qc1wiXSA9IEVNUFRZX01PRFVMRTtcbiAgICAgICAgLy8gUmV1c2UgYW55IGV4aXN0aW5nIHN5c21vZHVsZXMgdGhhdCB3ZSBwcmV2aW91c2x5IGZvdW5kO1xuICAgICAgICB0aGlzLnN5c21vZHVsZXMgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3Iuc3lzbW9kdWxlcztcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBfX21haW5fXyBtb2R1bGVzXG4gICAgICAgIGxldCAkbWFpbiA9IG5ldyBTay5idWlsdGluLnN0cihcIl9fbWFpbl9fXCIpO1xuICAgICAgICBpZiAodGhpcy5zeXNtb2R1bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN5c21vZHVsZXMucXVpY2skbG9va3VwKCRtYWluKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3lzbW9kdWxlcy5kZWwkaXRlbSgkbWFpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0VGltZW91dFByb21wdChsb25nVGltZW91dCkge1xuICAgICAgICBpZiAobG9uZ1RpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlRoZSBpbnN0cnVjdG9yIGNvZGUgaGFzIHRha2VuIGEgUkVBTExZIGxvbmcgdGltZSB0byBjaGVjayB5b3VyIGNvZGUgKDMwIG9yIG1vcmUgc2Vjb25kcykuIFlvdSBtaWdodCB3YW50IHRvIGNhbmNlbCBhbmQgY2hlY2sgeW91ciBjb2RlIChvciBnZXQgaGVscCBmcm9tIGFuIGluc3RydWN0b3IpLiBPciwgeW91IGNhbiBhZGQgbW9yZSBzZWNvbmRzIHRvIHdhaXQgYmVsb3cuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgaW5zdHJ1Y3RvciBjb2RlIGlzIHRha2luZyBhIGxpdHRsZSB3aGlsZSB0byBjaGVjayB5b3VyIGNvZGU7IGl0IG1pZ2h0IGp1c3QgbmVlZCBhIGxpdHRsZSBtb3JlIHRpbWUuIEhvdyBtYW55IG1vcmUgc2Vjb25kcyB3b3VsZCB5b3UgbGlrZSB0byB3YWl0P1wiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlbkZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5zZWFyY2hGb3JGaWxlKGZpbGVuYW1lLCBmYWxzZSk7XG4gICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiRmlsZSBub3QgZm91bmQ6IFwiK2ZpbGVuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZC5jb250ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW1wb3J0RmlsZShmaWxlbmFtZSkge1xuICAgICAgICBpZiAoZmlsZW5hbWUgPT09IFwiLi9hbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlbmFtZSA9PT0gXCIuL19pbnN0cnVjdG9yL29uX3J1bi5weVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlbmFtZSA9PT0gXCIuL19pbnN0cnVjdG9yL29uX2V2YWwucHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCgpIHx8IFwiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZW5hbWUgPT09IFwiLi9faW5zdHJ1Y3Rvci9fX2luaXRfXy5qc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfTU9EVUxFO1xuICAgICAgICB9IGVsc2UgaWYgKFNrLmJ1aWx0aW5GaWxlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiQnVpbHQtaW4gbW9kdWxlcyBub3QgYWNjZXNzaWJsZS5cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bZmlsZW5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtmaWxlbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLnNlYXJjaEZvckZpbGUoZmlsZW5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT1NFcnJvcihcIkZpbGUgbm90IGZvdW5kOiAnXCIrZmlsZW5hbWUgKyBcIidcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZC5jb250ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlucHV0KHByb21wdE1lc3NhZ2UpIHtcbiAgICAgICAgLy9yZXR1cm4gXCJBcHBsZVBpZVwiO1xuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dEluZGV4KCkgPCB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRJbmRleCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleCgpO1xuICAgICAgICAgICAgbGV0IG5leHRJbnB1dCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKVtpbnB1dEluZGV4XTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleChpbnB1dEluZGV4KzEpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHRJbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIkFwcGxlUGllXCI7XG4gICAgICAgIH1cbiAgICAgICAgLypyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoU2sucXVldWVkSW5wdXQucG9wKCkpO1xuICAgICAgICB9KTsqL1xuICAgIH1cblxufSIsImltcG9ydCB7SW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2luc3RydWN0b3JcIjtcblxuZXhwb3J0IGNsYXNzIE9uQ2hhbmdlQ29uZmlndXJhdGlvbiBleHRlbmRzIEluc3RydWN0b3JDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJvbl9jaGFuZ2UucHlcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2UoKTtcblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkudHJpZ2dlck9uQ2hhbmdlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59IiwiaW1wb3J0IHtJbnN0cnVjdG9yQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vaW5zdHJ1Y3RvclwiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4uL3NlcnZlclwiO1xuaW1wb3J0IHtORVdfTElORV9SRUdFWH0gZnJvbSBcIi4vb25fcnVuXCI7XG5pbXBvcnQge2luZGVudH0gZnJvbSBcIi4uL3V0aWxpdGllc1wiO1xuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IFdSQVBfSU5TVFJVQ1RPUl9DT0RFID0gZnVuY3Rpb24gKHN0dWRlbnRDb2RlLCBpbnN0cnVjdG9yQ29kZSwgcXVpY2ssIGlzU2FmZSkge1xuICAgIGxldCBzYWZlQ29kZSA9IEpTT04uc3RyaW5naWZ5KHN0dWRlbnRDb2RlKTtcbiAgICBsZXQgaW5kZW50ZWRDb2RlID0gaW5kZW50KGluZGVudChpc1NhZmUgPyBzdHVkZW50Q29kZSA6IFwiTm9uZVwiKSk7XG5cbiAgICByZXR1cm4gYFxuZnJvbSB1dGlsaXR5IGltcG9ydCAqXG5cbiMgTG9hZCBpbiBzb21lIGNvbW1vbmx5IHVzZWQgdG9vbHNcbmZyb20gcGVkYWwuY2FpdC5jYWl0X2FwaSBpbXBvcnQgcGFyc2VfcHJvZ3JhbVxuZnJvbSBwZWRhbC5zYW5kYm94LmNvbW1hbmRzIGltcG9ydCAqXG5mcm9tIHBlZGFsLmNvcmUuY29tbWFuZHMgaW1wb3J0ICpcblxuIyBCYWNrdXAgdGhlIGZlZWRiYWNrXG5vbl9ydW5fZmVlZGJhY2sgPSBbXVxuZm9yIGZlZWRiYWNrIGluIE1BSU5fUkVQT1JULmZlZWRiYWNrOlxuICAgIG9uX3J1bl9mZWVkYmFjay5hcHBlbmQoZmVlZGJhY2spXG5NQUlOX1JFUE9SVC5mZWVkYmFjay5jbGVhcigpXG5cbmZyb20gcGVkYWwuZW52aXJvbm1lbnRzLmJsb2NrcHkgaW1wb3J0IHNldHVwX2Vudmlyb25tZW50XG4jIEFkZCBpbiBldmFsdWF0ZWQgc3R1ZmYgZnJvbSBsYXN0IHRpbWVcbnN0dWRlbnQgPSBnZXRfc2FuZGJveCgpXG4jIFRPRE86IFdoYXQgYWJvdXQgbmV3IGlucHV0cyBzaW5jZSB3ZSBsYXN0IHJhbi9ldmFsZWQ/XG5NQUlOX1JFUE9SVC5zdWJtaXNzaW9uLmZpbGVzWydldmFsdWF0aW9uJ10gPSAke3NhZmVDb2RlfVxuZXZhbHVhdGUoJHtzYWZlQ29kZX0pXG5cbiMgVE9ETzogUmVmYWN0b3IgcmVzb2x2ZXIgdG8gcmV0dXJuIGluc3RydWN0aW9uc1xuIyBNb25rZXktcGF0Y2ggcXVlc3Rpb25zXG4jZnJvbSBwZWRhbCBpbXBvcnQgcXVlc3Rpb25zXG4jcXVlc3Rpb25zLnNob3dfcXVlc3Rpb24gPSBzZXRfaW5zdHJ1Y3Rpb25zXG5cbiMgUnVuIHRoZSBhY3R1YWwgaW5zdHJ1Y3RvciBjb2RlXG4ke2luc3RydWN0b3JDb2RlfVxuXG4jIFJlc29sdmUgZXZlcnl0aGluZ1xuZnJvbSBwZWRhbC5yZXNvbHZlcnMuc2ltcGxlIGltcG9ydCByZXNvbHZlXG5maW5hbCA9IHJlc29sdmUoKVxuU1VDQ0VTUyA9IGZpbmFsLnN1Y2Nlc3NcblNDT1JFID0gZmluYWwuc2NvcmVcbkNBVEVHT1JZID0gZmluYWwuY2F0ZWdvcnlcbkxBQkVMID0gZmluYWwudGl0bGVcbk1FU1NBR0UgPSBmaW5hbC5tZXNzYWdlXG5EQVRBID0gZmluYWwuZGF0YVxuSElERSA9IGZpbmFsLmhpZGVfY29ycmVjdG5lc3NcblxuIyBIYW5kbGUgcXVlc3Rpb25zXG5pZiBmaW5hbC5pbnN0cnVjdGlvbnM6XG4gICAgc2V0X2luc3RydWN0aW9ucyhmaW5hbC5pbnN0cnVjdGlvbnNbLTFdLm1lc3NhZ2UpXG4gICAgXG4jIEhhbmRsZSBwb3NpdGl2ZSBmZWVkYmFja1xuUE9TSVRJVkUgPSBbXVxuZm9yIHBvc2l0aXZlIGluIGZpbmFsLnBvc2l0aXZlczpcbiAgICBtZXNzYWdlID0gcG9zaXRpdmUubWVzc2FnZVxuICAgIGlmIG5vdCBwb3NpdGl2ZTpcbiAgICAgICAgbWVzc2FnZSA9IHBvc2l0aXZlLmVsc2VfbWVzc2FnZVxuICAgIFBPU0lUSVZFLmFwcGVuZCh7XG4gICAgICAgIFwidGl0bGVcIjogcG9zaXRpdmUudGl0bGUsXG4gICAgICAgIFwibGFiZWxcIjogcG9zaXRpdmUubGFiZWwsXG4gICAgICAgIFwibWVzc2FnZVwiOiBtZXNzYWdlXG4gICAgfSlcbiAgICBcbiMgSGFuZGxlIHN5c3RlbSBtZXNzYWdlc1xuZm9yIHN5c3RlbSBpbiBmaW5hbC5zeXN0ZW1zOlxuICAgIGlmIHN5c3RlbS5sYWJlbCA9PSAnbG9nJzpcbiAgICAgICAgY29uc29sZV9sb2coc3lzdGVtLnRpdGxlLCBzeXN0ZW0ubWVzc2FnZSk7XG4gICAgaWYgc3lzdGVtLmxhYmVsID09ICdkZWJ1Zyc6XG4gICAgICAgIGNvbnNvbGVfZGVidWcoc3lzdGVtLnRpdGxlLCBzeXN0ZW0ubWVzc2FnZSk7XG5cbmA7XG59O1xuXG5leHBvcnQgY2xhc3MgT25FdmFsQ29uZmlndXJhdGlvbiBleHRlbmRzIEluc3RydWN0b3JDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJfaW5zdHJ1Y3Rvci5vbl9ldmFsXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCgpIHx8IFwiXCI7XG5cbiAgICAgICAgbGV0IGRpc2FibGVUaWZhID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZVRpZmEoKTtcblxuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBsZXQgc3R1ZGVudENvZGVTYWZlID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzLnN0dWRlbnQuZXZhbHVhdGlvbiB8fCBcIk5vbmVcIjtcbiAgICAgICAgdGhpcy5kdW1teU91dFNhbmRib3goKTtcbiAgICAgICAgbGV0IGluc3RydWN0b3JDb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICBsZXQgbGluZU9mZnNldCA9IGluc3RydWN0b3JDb2RlLnNwbGl0KE5FV19MSU5FX1JFR0VYKS5sZW5ndGg7XG4gICAgICAgIGxldCBpc1NhZmUgPSAhcmVwb3J0W1wicGFyc2VyXCJdLmVtcHR5ICYmIHJlcG9ydFtcInZlcmlmaWVyXCJdLnN1Y2Nlc3M7XG4gICAgICAgIGluc3RydWN0b3JDb2RlID0gV1JBUF9JTlNUUlVDVE9SX0NPREUoc3R1ZGVudENvZGVTYWZlLCBpbnN0cnVjdG9yQ29kZSwgZGlzYWJsZVRpZmEsIGlzU2FmZSk7XG4gICAgICAgIGxpbmVPZmZzZXQgPSBpbnN0cnVjdG9yQ29kZS5zcGxpdChORVdfTElORV9SRUdFWCkubGVuZ3RoIC0gbGluZU9mZnNldDtcbiAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXSA9IHtcbiAgICAgICAgICAgIFwiY29tcGxpbWVudHNcIjogW10sXG4gICAgICAgICAgICBcImZpbGVuYW1lXCI6IFwiLi9faW5zdHJ1Y3Rvci9vbl9ldmFsLnB5XCIsXG4gICAgICAgICAgICBcImNvZGVcIjogaW5zdHJ1Y3RvckNvZGUsXG4gICAgICAgICAgICBcImxpbmVPZmZzZXRcIjogbGluZU9mZnNldFxuICAgICAgICAgICAgLy8nY29tcGxldGUnOiBmYWxzZSAvLyBBY3R1YWxseSwgbGV0J3MgdXNlIHVuZGVmaW5lZCBmb3Igbm93LlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvZGUgPSBpbnN0cnVjdG9yQ29kZTtcblxuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcblxuICAgICAgICAvL1NrLnJldGFpbkdsb2JhbHMgPSBmYWxzZTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5zdHJ1Y3Rvci5nbG9iYWxzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MobW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiT25FdmFsIHN1Y2Nlc3NcIik7XG4gICAgICAgIC8vIFRPRE86IEFjdHVhbGx5IHBhcnNlIHJlc3VsdHNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnN0cnVjdG9yLmdsb2JhbHMgPSBTay5nbG9iYWxzO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3Iuc3lzbW9kdWxlcyA9IFNrLnN5c21vZHVsZXM7XG4gICAgICAgIGNvbnNvbGUubG9nKG1vZHVsZSk7XG4gICAgICAgIGxldCByZXN1bHRzID0gbW9kdWxlLiRkLm9uX2V2YWwuJGQ7XG4gICAgICAgIGNvbnNvbGUubG9nKG1vZHVsZS4kZCk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRGZWVkYmFjayhyZXN1bHRzKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzW1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSB0cnVlO1xuICAgICAgICBsZXQgc3VjY2VzcyA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5TVUNDRVNTKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdChzdWNjZXNzIHx8IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3QoKSk7XG4gICAgICAgIC8vIENhbm5vdCBleGNlZWQgMSBwb2ludCwgY2Fubm90IGdvIGJlbG93IDAgcG9pbnRzXG4gICAgICAgIGxldCBzY29yZSA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5TQ09SRSk7XG4gICAgICAgIHNjb3JlID0gTWF0aC5tYXgoMC4wLCBNYXRoLm1pbigxLjAsIHNjb3JlKSk7XG4gICAgICAgIGxldCBvbGRTY29yZSA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKCk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKE1hdGgubWF4KG9sZFNjb3JlLCBzY29yZSkpO1xuICAgICAgICAvLyBIaWRlIHN0YXR1c1xuICAgICAgICBsZXQgaGlkZSA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5ISURFKTtcbiAgICAgICAgLy8gQW5kIGZpcmUgdGhlIHJlc3VsdCFcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb24oc2NvcmUsIHN1Y2Nlc3MsIGhpZGUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIC8vYWZ0ZXIobW9kdWxlKTtcblxuICAgICAgICAvKmlmIChzdWNjZXNzICYmIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNhbGxiYWNrcy5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jYWxsYmFja3Muc3VjY2Vzcyh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5pZCgpKTtcbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKCFTay5leGVjdXRpb25SZXBvcnRzLmluc3RydWN0b3Iuc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJPbkV2YWwgZmFpbHVyZVwiKTtcbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgaWYgKGVycm9yLnRwJG5hbWUgPT09IFwiR3JhY2VmdWxFeGl0XCIpIHtcbiAgICAgICAgICAgIHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJzdWNjZXNzXCJdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5GQUlMRUQpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wiY29kZVwiXSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRJbnRlcm5hbEVycm9yKGVycm9yLCB0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImVycm9yXCJdID0gZXJyb3I7XG4gICAgICAgICAgICAvL1RPRE86IHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJsaW5lX29mZnNldFwiXSA9IGxpbmVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9UT0RPOiBhZnRlcihlcnJvcik7XG4gICAgfVxufSIsImltcG9ydCB7aW5kZW50fSBmcm9tIFwiLi4vdXRpbGl0aWVzXCI7XG5pbXBvcnQge1N0YXR1c1N0YXRlfSBmcm9tIFwiLi4vc2VydmVyXCI7XG5pbXBvcnQge0luc3RydWN0b3JDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9pbnN0cnVjdG9yXCI7XG5cbmV4cG9ydCBjb25zdCBORVdfTElORV9SRUdFWCA9IC9cXHJcXG58XFxyfFxcbi87XG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IFdSQVBfSU5TVFJVQ1RPUl9DT0RFID0gZnVuY3Rpb24gKHN0dWRlbnRDb2RlLCBpbnN0cnVjdG9yQ29kZSwgcXVpY2ssIGlzU2FmZSkge1xuICAgIGxldCBzYWZlQ29kZSA9IEpTT04uc3RyaW5naWZ5KHN0dWRlbnRDb2RlKTtcbiAgICBsZXQgaW5kZW50ZWRDb2RlID0gaW5kZW50KGluZGVudChpc1NhZmUgPyBzdHVkZW50Q29kZSA6IFwicGFzc1wiKSk7XG4gICAgbGV0IHRpZmFBbmFseXNpcyA9IFwiXCI7XG4gICAgaWYgKCFxdWljaykge1xuICAgICAgICB0aWZhQW5hbHlzaXMgPSBcImZyb20gcGVkYWwudGlmYSBpbXBvcnQgdGlmYV9hbmFseXNpc1xcbnRpZmFfYW5hbHlzaXMoRmFsc2UpXCI7XG4gICAgfVxuICAgIGxldCBza2lwX3RpZmEgPSBxdWljayA/IFwiVHJ1ZVwiOiBcIkZhbHNlXCI7XG5cbiAgICAvLyBUT0RPOiBBZGQgaW4gU2sucXVldWVkSW5wdXQgdG8gYmUgcGFzc2VkIGluXG5cbiAgICByZXR1cm4gYFxuIyBTdXBwb3J0IG91ciBzeXNtb2R1bGVzIGhhY2sgYnkgY2xlYXJpbmcgb3V0IGFueSBsaW5nZXJpbmcgb2xkIGRhdGFcbmZyb20gcGVkYWwuY29yZS5yZXBvcnQgaW1wb3J0IE1BSU5fUkVQT1JUXG5NQUlOX1JFUE9SVC5jbGVhcigpXG5cbmZyb20gY2lzYzEwOCBpbXBvcnQgc3R1ZGVudF90ZXN0c1xuc3R1ZGVudF90ZXN0cy5yZXNldCgpXG5cbmZyb20gdXRpbGl0eSBpbXBvcnQgKlxuXG4jIExvYWQgaW4gc29tZSBjb21tb25seSB1c2VkIHRvb2xzXG5mcm9tIHBlZGFsLmNhaXQuY2FpdF9hcGkgaW1wb3J0IHBhcnNlX3Byb2dyYW1cbmZyb20gcGVkYWwuc2FuZGJveC5jb21tYW5kcyBpbXBvcnQgKlxuZnJvbSBwZWRhbC5jb3JlLmNvbW1hbmRzIGltcG9ydCAqXG5cbmZyb20gcGVkYWwuZW52aXJvbm1lbnRzLmJsb2NrcHkgaW1wb3J0IHNldHVwX2Vudmlyb25tZW50XG4jIERvIHdlIGV4ZWN1dGUgc3R1ZGVudCdzIGNvZGU/XG5za2lwX3J1biA9IGdldF9tb2RlbF9pbmZvKCdhc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVJbnN0cnVjdG9yUnVuJylcbmlucHV0cyA9IE5vbmUgaWYgc2tpcF9ydW4gZWxzZSBnZXRfbW9kZWxfaW5mbygnZXhlY3V0aW9uLmlucHV0JylcblxuIyBJbml0aWFsaXplIHRoZSBCbG9ja1B5IGVudmlyb25tZW50XG5wZWRhbCA9IHNldHVwX2Vudmlyb25tZW50KHNraXBfdGlmYT0ke3NraXBfdGlmYX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBfcnVuPXNraXBfcnVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHM9aW5wdXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluX2ZpbGU9J2Fuc3dlci5weScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fY29kZT0ke3NhZmVDb2RlfSlcbnN0dWRlbnQgPSBwZWRhbC5maWVsZHNbJ3N0dWRlbnQnXVxuXG4jIFRPRE86IFJlZmFjdG9yIHJlc29sdmVyIHRvIHJldHVybiBpbnN0cnVjdGlvbnNcbiMgTW9ua2V5LXBhdGNoIHF1ZXN0aW9uc1xuI2Zyb20gcGVkYWwgaW1wb3J0IHF1ZXN0aW9uc1xuI3F1ZXN0aW9ucy5zaG93X3F1ZXN0aW9uID0gc2V0X2luc3RydWN0aW9uc1xuXG4jIFJ1biB0aGUgYWN0dWFsIGluc3RydWN0b3IgY29kZVxuJHtpbnN0cnVjdG9yQ29kZX1cblxuIyBSZXNvbHZlIGV2ZXJ5dGhpbmdcbmZyb20gcGVkYWwucmVzb2x2ZXJzLnNpbXBsZSBpbXBvcnQgcmVzb2x2ZVxuZmluYWwgPSByZXNvbHZlKClcblNVQ0NFU1MgPSBmaW5hbC5zdWNjZXNzXG5TQ09SRSA9IGZpbmFsLnNjb3JlXG5DQVRFR09SWSA9IGZpbmFsLmNhdGVnb3J5XG5MQUJFTCA9IGZpbmFsLnRpdGxlXG5NRVNTQUdFID0gZmluYWwubWVzc2FnZVxuREFUQSA9IGZpbmFsLmRhdGFcbkhJREUgPSBmaW5hbC5oaWRlX2NvcnJlY3RuZXNzXG5cbiMgSGFuZGxlIHF1ZXN0aW9uc1xuaWYgZmluYWwuaW5zdHJ1Y3Rpb25zOlxuICAgIHNldF9pbnN0cnVjdGlvbnMoZmluYWwuaW5zdHJ1Y3Rpb25zWy0xXS5tZXNzYWdlKVxuICAgIFxuIyBIYW5kbGUgcG9zaXRpdmUgZmVlZGJhY2tcblBPU0lUSVZFID0gW11cbmZvciBwb3NpdGl2ZSBpbiBmaW5hbC5wb3NpdGl2ZXM6XG4gICAgbWVzc2FnZSA9IHBvc2l0aXZlLm1lc3NhZ2VcbiAgICBpZiBub3QgcG9zaXRpdmU6XG4gICAgICAgIG1lc3NhZ2UgPSBwb3NpdGl2ZS5lbHNlX21lc3NhZ2VcbiAgICBQT1NJVElWRS5hcHBlbmQoe1xuICAgICAgICBcInRpdGxlXCI6IHBvc2l0aXZlLnRpdGxlLFxuICAgICAgICBcImxhYmVsXCI6IHBvc2l0aXZlLmxhYmVsLFxuICAgICAgICBcIm1lc3NhZ2VcIjogbWVzc2FnZVxuICAgIH0pXG4gICAgXG4jIEhhbmRsZSBzeXN0ZW0gbWVzc2FnZXNcbmZvciBzeXN0ZW0gaW4gZmluYWwuc3lzdGVtczpcbiAgICBpZiBzeXN0ZW0ubGFiZWwgPT0gJ2xvZyc6XG4gICAgICAgIGNvbnNvbGVfbG9nKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuICAgIGlmIHN5c3RlbS5sYWJlbCA9PSAnZGVidWcnOlxuICAgICAgICBjb25zb2xlX2RlYnVnKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuXG5gO1xufTtcblxuZXhwb3J0IGNsYXNzIE9uUnVuQ29uZmlndXJhdGlvbiBleHRlbmRzIEluc3RydWN0b3JDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJfaW5zdHJ1Y3Rvci5vbl9ydW5cIjtcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKTtcblxuICAgICAgICBsZXQgZGlzYWJsZVRpZmEgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGlmYSgpO1xuXG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGxldCBzdHVkZW50Q29kZVNhZmUgPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgIHRoaXMuZHVtbXlPdXRTYW5kYm94KCk7XG4gICAgICAgIGxldCBpbnN0cnVjdG9yQ29kZSA9IHRoaXMuY29kZTtcbiAgICAgICAgbGV0IGxpbmVPZmZzZXQgPSBpbnN0cnVjdG9yQ29kZS5zcGxpdChORVdfTElORV9SRUdFWCkubGVuZ3RoO1xuICAgICAgICBsZXQgaXNTYWZlID0gIXJlcG9ydFtcInBhcnNlclwiXS5lbXB0eSAmJiByZXBvcnRbXCJ2ZXJpZmllclwiXS5zdWNjZXNzO1xuICAgICAgICBpbnN0cnVjdG9yQ29kZSA9IFdSQVBfSU5TVFJVQ1RPUl9DT0RFKHN0dWRlbnRDb2RlU2FmZSwgaW5zdHJ1Y3RvckNvZGUsIGRpc2FibGVUaWZhLCBpc1NhZmUpO1xuICAgICAgICBsaW5lT2Zmc2V0ID0gMDsgLy9pbnN0cnVjdG9yQ29kZS5zcGxpdChORVdfTElORV9SRUdFWCkubGVuZ3RoIC0gbGluZU9mZnNldCAtIDQ7XG4gICAgICAgIHJlcG9ydFtcImluc3RydWN0b3JcIl0gPSB7XG4gICAgICAgICAgICBcImNvbXBsaW1lbnRzXCI6IFtdLFxuICAgICAgICAgICAgXCJmaWxlbmFtZVwiOiBcIi4vX2luc3RydWN0b3Ivb25fcnVuLnB5XCIsXG4gICAgICAgICAgICBcImNvZGVcIjogaW5zdHJ1Y3RvckNvZGUsXG4gICAgICAgICAgICBcImxpbmVPZmZzZXRcIjogbGluZU9mZnNldFxuICAgICAgICAgICAgLy8nY29tcGxldGUnOiBmYWxzZSAvLyBBY3R1YWxseSwgbGV0J3MgdXNlIHVuZGVmaW5lZCBmb3Igbm93LlxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY29kZSA9IGluc3RydWN0b3JDb2RlO1xuXG4gICAgICAgIFNrLnJldGFpbkdsb2JhbHMgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdWNjZXNzKG1vZHVsZSkge1xuICAgICAgICAvLyBUT0RPIExvZ2dpbmchISEhXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJPblJ1biBzdWNjZXNzXCIpO1xuICAgICAgICAvLyBUT0RPOiBBY3R1YWxseSBwYXJzZSByZXN1bHRzXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5zdHJ1Y3Rvci5nbG9iYWxzID0gU2suZ2xvYmFscztcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnN0cnVjdG9yLnN5c21vZHVsZXMgPSBTay5zeXNtb2R1bGVzO1xuICAgICAgICBTay5nbG9iYWxzID0ge307XG4gICAgICAgIGxldCByZXN1bHRzID0gbW9kdWxlLiRkLm9uX3J1bi4kZDtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2sucHJlc2VudEZlZWRiYWNrKHJlc3VsdHMpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHNbXCJpbnN0cnVjdG9yXCJdW1wic3VjY2Vzc1wiXSA9IHRydWU7XG4gICAgICAgIGxldCBzdWNjZXNzID0gU2suZmZpLnJlbWFwVG9KcyhyZXN1bHRzLlNVQ0NFU1MpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KHN1Y2Nlc3MgfHwgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdCgpKTtcbiAgICAgICAgLy8gQ2Fubm90IGV4Y2VlZCAxIHBvaW50LCBjYW5ub3QgZ28gYmVsb3cgMCBwb2ludHNcbiAgICAgICAgbGV0IHNjb3JlID0gU2suZmZpLnJlbWFwVG9KcyhyZXN1bHRzLlNDT1JFKTtcbiAgICAgICAgc2NvcmUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBzY29yZSkpO1xuICAgICAgICBsZXQgb2xkU2NvcmUgPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5zY29yZSgpO1xuICAgICAgICBzY29yZSA9IE1hdGgubWF4KG9sZFNjb3JlLCBzY29yZSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKHNjb3JlKTtcbiAgICAgICAgLy8gSGlkZSBzdGF0dXNcbiAgICAgICAgbGV0IGhpZGUgPSBTay5mZmkucmVtYXBUb0pzKHJlc3VsdHMuSElERSk7XG4gICAgICAgIC8vIEFuZCBmaXJlIHRoZSByZXN1bHQhXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci51cGRhdGVTdWJtaXNzaW9uKHNjb3JlLCBzdWNjZXNzLCBoaWRlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAvL2FmdGVyKG1vZHVsZSk7XG5cbiAgICAgICAgLyppZiAoc3VjY2VzcyAmJiB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jYWxsYmFja3Muc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uY2FsbGJhY2tzLnN1Y2Nlc3ModGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaWQoKSk7XG4gICAgICAgIH0qL1xuXG4gICAgICAgIGlmICghU2suZXhlY3V0aW9uUmVwb3J0cy5pbnN0cnVjdG9yLnNjcm9sbGluZykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnNjcm9sbFRvQm90dG9tKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmYWlsdXJlKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiT25SdW4gZmFpbHVyZVwiKTtcbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgaWYgKGVycm9yLnRwJG5hbWUgPT09IFwiR3JhY2VmdWxFeGl0XCIpIHtcbiAgICAgICAgICAgIHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJzdWNjZXNzXCJdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5GQUlMRUQpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wiY29kZVwiXSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRJbnRlcm5hbEVycm9yKGVycm9yLCB0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImVycm9yXCJdID0gZXJyb3I7XG4gICAgICAgICAgICAvL1RPRE86IHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJsaW5lX29mZnNldFwiXSA9IGxpbmVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9UT0RPOiBhZnRlcihlcnJvcik7XG4gICAgfVxufVxuXG5cbi8qXG4jIFRoZSBmb2xsb3dpbmcgaXMgdGhlIG9sZCBpbnN0cnVjdG9yIGNvZGUsIGxlYXZpbmcgaXQgaGVyZSBmb3Igbm93LlxuXG5mcm9tIHBlZGFsLmNvcmUucmVwb3J0IGltcG9ydCBNQUlOX1JFUE9SVFxuIyBTdXBwb3J0IG91ciBzeXNtb2R1bGVzIGhhY2sgYnkgY2xlYXJpbmcgb3V0IGFueSBsaW5nZXJpbmcgb2xkIGRhdGFcbk1BSU5fUkVQT1JULmNsZWFyKClcbmZyb20gcGVkYWwuY29yZS5jb21tYW5kcyBpbXBvcnQgY29udGV4dHVhbGl6ZV9yZXBvcnRcbmNvbnRleHR1YWxpemVfcmVwb3J0KCR7c2FmZUNvZGV9LCBcImFuc3dlci5weVwiKVxuJHt0aWZhQW5hbHlzaXN9XG5mcm9tIHBlZGFsLnNhbmRib3guc2FuZGJveCBpbXBvcnQgU2FuZGJveFxuZnJvbSBwZWRhbC5zYW5kYm94IGltcG9ydCBjb21wYXRpYmlsaXR5XG5mcm9tIHV0aWxpdHkgaW1wb3J0ICpcbnN0dWRlbnQgPSBNQUlOX1JFUE9SVFsnc2FuZGJveCddWydydW4nXSA9IFNhbmRib3goKVxuc3R1ZGVudC5yZXBvcnRfZXhjZXB0aW9uc19tb2RlID0gVHJ1ZVxubG9nKGdldF9tb2RlbF9pbmZvKCdleGVjdXRpb24uaW5wdXQnKSlcbnN0dWRlbnQuc2V0X2lucHV0KGdldF9tb2RlbF9pbmZvKCdleGVjdXRpb24uaW5wdXQnKSlcbmlmIG5vdCBnZXRfbW9kZWxfaW5mbygnYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlSW5zdHJ1Y3RvclJ1bicpOlxuICAgIGNvbXBhdGliaWxpdHkucnVuX3N0dWRlbnQocmFpc2VfZXhjZXB0aW9ucz1GYWxzZSlcbiNsb2coc3R1ZGVudC5kYXRhKVxuI3N0dWRlbnQgPSBnZXRfc3R1ZGVudF9kYXRhKClcbiNlcnJvciwgcG9zaXRpb24gPSBnZXRfc3R1ZGVudF9lcnJvcigpXG4jY29tcGF0aWJpbGl0eS5yYWlzZV9leGNlcHRpb24oZXJyb3IsIHBvc2l0aW9uKVxucnVuX3N0dWRlbnQgPSBjb21wYXRpYmlsaXR5LnJ1bl9zdHVkZW50XG5yZXNldF9vdXRwdXQgPSBjb21wYXRpYmlsaXR5LnJlc2V0X291dHB1dFxucXVldWVfaW5wdXQgPSBjb21wYXRpYmlsaXR5LnF1ZXVlX2lucHV0XG5nZXRfb3V0cHV0ID0gY29tcGF0aWJpbGl0eS5nZXRfb3V0cHV0XG5nZXRfcGxvdHMgPSBjb21wYXRpYmlsaXR5LmdldF9wbG90c1xuY29tcGF0aWJpbGl0eS50cmFjZV9saW5lcyA9IHRyYWNlX2xpbmVzXG5mcm9tIHBlZGFsIGltcG9ydCBxdWVzdGlvbnNcbnF1ZXN0aW9ucy5zaG93X3F1ZXN0aW9uID0gc2V0X2luc3RydWN0aW9uc1xuIyBUT0RPOiBSZW1vdmUgdGhlIG5lZWQgZm9yIHRoaXMgaGFjayFcbmRlZiBjYXB0dXJlX291dHB1dChmdW5jLCAqYXJncyk6XG4gICByZXNldF9vdXRwdXQoKVxuICAgc3R1ZGVudC5jYWxsKGZ1bmMuX19uYW1lX18sICphcmdzKVxuICAgcmV0dXJuIGdldF9vdXRwdXQoKVxuY29tcGF0aWJpbGl0eS5jYXB0dXJlX291dHB1dCA9IGNhcHR1cmVfb3V0cHV0XG5cbmZyb20gcGVkYWwuY2FpdC5jYWl0X2FwaSBpbXBvcnQgcGFyc2VfcHJvZ3JhbVxuJHtpbnN0cnVjdG9yQ29kZX1cbmZyb20gcGVkYWwucmVzb2x2ZXJzIGltcG9ydCBzaW1wbGVcbmZpbmFsID0gc2ltcGxlLnJlc29sdmUoKVxuU1VDQ0VTUyA9IGZpbmFsLnN1Y2Nlc3NcblNDT1JFID0gZmluYWwuc2NvcmVcbkNBVEVHT1JZID0gZmluYWwuY2F0ZWdvcnlcbkxBQkVMID0gZmluYWwudGl0bGVcbk1FU1NBR0UgPSBmaW5hbC5tZXNzYWdlXG5EQVRBID0gZmluYWwuZGF0YVxuSElERSA9IGZpbmFsLmhpZGVfY29ycmVjdG5lc3NcblxuICovIiwiaW1wb3J0IHtPblJ1bkNvbmZpZ3VyYXRpb259IGZyb20gXCIuL29uX3J1blwiO1xuXG5leHBvcnQgY2xhc3MgT25TYW1wbGVDb25maWd1cmF0aW9uIGV4dGVuZHMgT25SdW5Db25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJvbl9ydW4ucHlcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59IiwiaW1wb3J0IHtTdHVkZW50Q29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc3R1ZGVudFwiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4uL3NlcnZlclwiO1xuXG5leHBvcnQgY2xhc3MgUnVuQ29uZmlndXJhdGlvbiBleHRlbmRzIFN0dWRlbnRDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subWVzc2FnZShcIlJ1bm5pbmcuLi5cIik7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBcImFuc3dlclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5zYXZlRmlsZShcImFuc3dlci5weVwiLCB0aGlzLmNvZGUsIG51bGwpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJDb21waWxlXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiYW5zd2VyLnB5XCIpO1xuXG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuXG4gICAgICAgIGVuZ2luZS5yZXNldCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcnNlKCk7XG5cbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzW1widmVyaWZpZXJcIl0gPSB7XG4gICAgICAgICAgICBcInN1Y2Nlc3NcIjogQm9vbGVhbih0aGlzLmNvZGUudHJpbSgpKSxcbiAgICAgICAgICAgIFwiY29kZVwiOiB0aGlzLmNvZGVcbiAgICAgICAgfTtcblxuICAgICAgICBTay5yZXRhaW5HbG9iYWxzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5jbGVhcklucHV0KCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3VjY2Vzcyhtb2R1bGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJSdW4gc3VjY2Vzc1wiKTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBcImlucHV0c1wiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkuam9pbihcIlxcblwiKSxcbiAgICAgICAgICAgIFwib3V0cHV0c1wiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLm91dHB1dCgpLm1hcChsaW5lID0+IGxpbmUuY29udGVudCkuam9pbihcIlxcblwiKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiUnVuLlByb2dyYW1cIiwgXCJcIiwgXCJcIiwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksIFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5kaXJ0eVN1Ym1pc3Npb24oZmFsc2UpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLmZpbmlzaFR1cnRsZXMoKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5nbG9iYWxzKFNrLmdsb2JhbHMpO1xuICAgICAgICBTay5nbG9iYWxzID0ge307XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5yZXN1bHRzID0gbW9kdWxlO1xuICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVFdmFsdWF0ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLmJlZ2luRXZhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0ZXAobW9kdWxlLiRkLCBtb2R1bGUuJGQsLTEsIDAsIGZpbGVuYW1lICsgXCIucHlcIik7XG4gICAgICAgICAgICB0aGlzLmxhc3RTdGVwKCk7XG4gICAgICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge1xuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwidHJhY2VcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLFxuICAgICAgICAgICAgICAgIFwibGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJyZWFsTGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLmZpbHRlcih4ID0+ICF4LmlzRG9jc3RyaW5nKS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwicmVzdWx0c1wiOiBtb2R1bGUsXG4gICAgICAgICAgICAgICAgXCJvdXRwdXRcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5vdXRwdXQsXG4gICAgICAgICAgICAgICAgXCJpbnB1dFwiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgIFwiY2FsbHNcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmNhbGxzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmYWlsdXJlKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUnVuIGZhaWx1cmVcIik7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuRkFJTEVEKTtcbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgaWYgKHJlcG9ydC5wYXJzZXIuc3VjY2VzcyAmJiByZXBvcnQudmVyaWZpZXIuc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiQ29tcGlsZS5FcnJvclwiLCBcIlwiLCBcIlwiLCBlcnJvci50b1N0cmluZygpLCBcImFuc3dlci5weVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlJ1bi5Qcm9ncmFtXCIsIFwiUHJvZ3JhbUVycm9yT3V0cHV0XCIsIFwiXCIsIGVycm9yLnRvU3RyaW5nKCksIFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge1xuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImVycm9yXCI6IGVycm9yLFxuICAgICAgICAgICAgICAgIFwibGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJyZWFsTGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLmZpbHRlcih4ID0+ICF4LmlzRG9jc3RyaW5nKS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwiaW5wdXRcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCxcbiAgICAgICAgICAgICAgICBcImNhbGxzXCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jYWxsc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59IiwiaW1wb3J0IHtTdHVkZW50Q29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc3R1ZGVudFwiO1xuXG5leHBvcnQgY2xhc3MgU2FtcGxlQ29uZmlndXJhdGlvbiBleHRlbmRzIFN0dWRlbnRDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICAvLyBUT0RPOiBGaXggdG8gYmUgdGhlIGN1cnJlbnQgc2FtcGxlIHN1Ym1pc3Npb25cbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwiYW5zd2VyLnB5XCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwicHJpbnQoJ05vdCByZWFkeSB5ZXQhJylcIjtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59IiwiaW1wb3J0IHtDb25maWd1cmF0aW9uLCBFTVBUWV9NT0RVTEV9IGZyb20gXCIuL2NvbmZpZ3VyYXRpb25zXCI7XG5cbmV4cG9ydCBjbGFzcyBTdHVkZW50Q29uZmlndXJhdGlvbiBleHRlbmRzIENvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG4gICAgICAgIC8vIExpbWl0IGV4ZWN1dGlvbiB0byA0IHNlY29uZHNcbiAgICAgICAgbGV0IHNldHRpbmdzID0gdGhpcy5tYWluLm1vZGVsLnNldHRpbmdzO1xuICAgICAgICBTay5leGVjTGltaXRGdW5jdGlvbiA9ICgpID0+XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGltZW91dCgpID8gSW5maW5pdHkgOiA1MDAwO1xuICAgICAgICBTay5leGVjTGltaXQgPSBTay5leGVjTGltaXRGdW5jdGlvbigpO1xuICAgICAgICAvLyBTdGVwcGVyISBFeGVjdXRlZCBhZnRlciBldmVyeSBzdGF0ZW1lbnQuXG4gICAgICAgIFNrLmFmdGVyU2luZ2xlRXhlY3V0aW9uID0gdGhpcy5zdGVwLmJpbmQodGhpcyk7XG4gICAgICAgIFNrLmJlZm9yZUNhbGwgPSB0aGlzLmJlZm9yZUNhbGwuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gVW5tdXRlIGV2ZXJ5dGhpbmdcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkubXV0ZVByaW50ZXIoZmFsc2UpO1xuXG4gICAgICAgIC8vIEZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgZWFjaCBzdGVwXG4gICAgICAgIC8vIGFmdGVyU2luZ2xlRXhlY3V0aW9uXG5cbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi91dGlsaXR5L19faW5pdF9fLmpzXCJdID0gRU1QVFlfTU9EVUxFO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG9wZW5GaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uc2VhcmNoRm9yRmlsZShmaWxlbmFtZSwgdHJ1ZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coZmlsZW5hbWUsIGZvdW5kKTtcbiAgICAgICAgaWYgKGZvdW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk9TRXJyb3IoXCJGaWxlIG5vdCBmb3VuZDogXCIrZmlsZW5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kLmNvbnRlbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbXBvcnRGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRm9yYmlkZGVuKGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJGaWxlIG5vdCBhY2Nlc3NpYmxlOiAnXCIgKyBmaWxlbmFtZSArIFwiJ1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGVuYW1lID09PSBcIi4vYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoU2suYnVpbHRpbkZpbGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk9TRXJyb3IoXCJCdWlsdC1pbiBtb2R1bGVzIG5vdCBhY2Nlc3NpYmxlLlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtmaWxlbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW5GaWxlc1tcImZpbGVzXCJdW2ZpbGVuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uc2VhcmNoRm9yRmlsZShmaWxlbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk9TRXJyb3IoXCJGaWxlIG5vdCBmb3VuZDogJ1wiK2ZpbGVuYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQuY29udGVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlucHV0KHByb21wdE1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuaW5wdXQocHJvbXB0TWVzc2FnZSk7XG4gICAgfVxuXG4gICAgaXNGb3JiaWRkZW4oZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lLnN0YXJ0c1dpdGgoXCJzcmMvbGliL3V0aWxpdHkvXCIpIHx8XG4gICAgICAgICAgICBmaWxlbmFtZS5zdGFydHNXaXRoKFwic3JjL2xpYi9wZWRhbC9cIikgfHxcbiAgICAgICAgICAgIGZpbGVuYW1lLnN0YXJ0c1dpdGgoXCIuL19pbnN0cnVjdG9yL1wiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcIlN0ZXBzXCIgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgY29kZSwgbWVhbnQgdG8gYmUgdXNlZCBhcyBhIGNhbGxiYWNrIHRvIHRoZSBTa3VscHRcbiAgICAgKiBlbnZpcm9ubWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBnbG9iYWxzIC0gSGFzaCB0aGF0IG1hcHMgdGhlIG5hbWVzIG9mIGdsb2JhbCB2YXJpYWJsZXMgKFN0cmluZ3MpIHRvIHRoZWlyIFNrdWxwdCByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYWxzIC0gSGFzaCB0aGF0IG1hcHMgdGhlIG5hbWVzIG9mIGxvY2FsIHZhcmlhYmxlcyAoU3RyaW5ncykgdG8gdGhlaXIgU2t1bHB0IHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lTnVtYmVyIC0gVGhlIGNvcnJlc3BvbmRpbmcgbGluZSBudW1iZXIgaW4gdGhlIHNvdXJjZSBjb2RlIHRoYXQgaXMgYmVpbmcgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbHVtbk51bWJlciAtIFRoZSBjb3JyZXNwb25kaW5nIGNvbHVtbiBudW1iZXIgaW4gdGhlIHNvdXJjZSBjb2RlIHRoYXQgaXMgYmVpbmcgZXhlY3V0ZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaW5rIG9mIGl0IGFzIHRoZSBcIlhcIiBwb3NpdGlvbiB0byB0aGUgbGluZU51bWJlcidzIFwiWVwiIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBweXRob24gZmlsZSBiZWluZyBleGVjdXRlZCAoZS5nLiwgXCJfX21haW5fXy5weVwiKS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRG9jc3RyaW5nIC0gV2hldGhlciBvciBub3QgdGhpcyBpcyBhbiBhY3R1YWwgbGluZSBvciBhIGRvY3N0cmluZy5cbiAgICAgKi9cbiAgICBzdGVwKGdsb2JhbHMsIGxvY2FscywgbGluZU51bWJlciwgY29sdW1uTnVtYmVyLCBmaWxlbmFtZSwgaXNEb2NzdHJpbmcpIHtcbiAgICAgICAgaWYgKGZpbGVuYW1lID09PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFN0ZXAgPSB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcDtcbiAgICAgICAgICAgIGdsb2JhbHMgPSB0aGlzLm1haW4uY29tcG9uZW50cy50cmFjZS5wYXJzZUdsb2JhbHMoZ2xvYmFscyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBUcmFjZSBsb2NhbCB2YXJpYWJsZXMgcHJvcGVybHlcbiAgICAgICAgICAgIC8vbGV0IGxvY2FscyA9IHRoaXMubWFpbi5jb21wb25lbnRzLnRyYWNlLnBhcnNlR2xvYmFscyhsb2NhbHMpO1xuICAgICAgICAgICAgLy9PYmplY3QuYXNzaWduKGdsb2JhbHMsIGxvY2Fscyk7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UucHVzaCh7XG4gICAgICAgICAgICAgICAgXCJzdGVwXCI6IGN1cnJlbnRTdGVwLFxuICAgICAgICAgICAgICAgIFwiZmlsZW5hbWVcIjogZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgLy8nYmxvY2snOiBoaWdobGlnaHRNYXBbbGluZU51bWJlci0xXSxcbiAgICAgICAgICAgICAgICBcImxpbmVcIjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBcImNvbHVtblwiOiBjb2x1bW5OdW1iZXIsXG4gICAgICAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IGdsb2JhbHMucHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBcIm1vZHVsZXNcIjogZ2xvYmFscy5tb2R1bGVzLFxuICAgICAgICAgICAgICAgIFwiaXNEb2NzdHJpbmdcIjogaXNEb2NzdHJpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnN0ZXAgPSBjdXJyZW50U3RlcCArIDE7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIubGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYmVmb3JlQ2FsbChmdW5jdGlvbk5hbWUsIHBvc2FyZ3MsIGt3YXJncykge1xuICAgICAgICAvLyBUT0RPOiBIYW5kbGUgZmFzdGNhbGwgdG9vPyBDaGVjayBob3cgdGhhdCB3b3JrcyBpbiBTa3VscHQgc2lkZVxuICAgICAgICBsZXQgc3R1ZGVudE1vZGVsID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50O1xuICAgICAgICBpZiAoIShmdW5jdGlvbk5hbWUgaW4gc3R1ZGVudE1vZGVsLmNhbGxzKSkge1xuICAgICAgICAgICAgc3R1ZGVudE1vZGVsLmNhbGxzW2Z1bmN0aW9uTmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXJncyA9IHt9O1xuICAgICAgICAvLyBHZXQgYWN0dWFsIHBhcmFtZXRlciBuYW1lcyEhXG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IHBvc2FyZ3MubGVuZ3RoOyBpKz0gMSkge1xuICAgICAgICAgICAgYXJnc1tcIl9fQVJHXCIraV0gPSBwb3NhcmdzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrd2FyZ3MgJiYga3dhcmdzWzBdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFyZ3NbXCJfX0FSR1NcIl0gPSBrd2FyZ3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGt3YXJncyAmJiBrd2FyZ3NbMV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJnc1tcIl9fS1dBUkdTXCJdID0ga3dhcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKGFyZ3MpO1xuICAgICAgICBzdHVkZW50TW9kZWwuY2FsbHNbZnVuY3Rpb25OYW1lXS5wdXNoKGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhdCB0aGUgZW5kIG9mIHRoZSBTa3VscHQgZXhlY3V0aW9uIHRvIHRlcm1pbmF0ZSB0aGUgZXhlY3V0aW9uQnVmZmVyXG4gICAgICogYW5kIGhhbmQgaXQgb2ZmIHRvIHRoZSBleGVjdXRpb24gdHJhY2UgaW4gdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGxhc3RTdGVwKCkge1xuICAgICAgICBsZXQgZXhlY3V0aW9uID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbjtcbiAgICAgICAgZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlRGF0YSh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UpO1xuICAgICAgICBleGVjdXRpb24uc3R1ZGVudC5jdXJyZW50U3RlcCh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcCk7XG4gICAgICAgIGV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5zdGVwKTtcbiAgICAgICAgZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudExpbmUodGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLmxpbmUpO1xuICAgICAgICBleGVjdXRpb24uc3R1ZGVudC5sYXN0TGluZSh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIubGluZSk7XG4gICAgICAgIGV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAodGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnN0ZXApO1xuICAgIH07XG5cbiAgICBnZXRMaW5lcyhhc3QpIHtcbiAgICAgICAgbGV0IHZpc2l0ZWRMaW5lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IHZpc2l0Qm9keSA9IChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5saW5lbm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRMaW5lcy5hZGQobm9kZS5saW5lbm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuYm9keSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYm9keS5mb3JFYWNoKChzdGF0ZW1lbnQpID0+IHZpc2l0Qm9keShzdGF0ZW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLm9yZWxzZSkge1xuICAgICAgICAgICAgICAgIG5vZGUub3JlbHNlLmZvckVhY2goKHN0YXRlbWVudCkgPT4gdmlzaXRCb2R5KHN0YXRlbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuZmluYWxib2R5KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5maW5hbGJvZHkuZm9yRWFjaCgoc3RhdGVtZW50KSA9PiB2aXNpdEJvZHkoc3RhdGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZpc2l0Qm9keShhc3QpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2aXNpdGVkTGluZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IHRoZSBwYXJzZSBpbmZvcm1hdGlvbiBpcyB1cC10by1kYXRlXG4gICAgICovXG4gICAgdXBkYXRlUGFyc2UoKSB7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIC8vIEhvbGQgYWxsIHRoZSBhY3R1YWxseSBkaXNjb3ZlcmVkIGxpbmVzIGZyb20gdGhlIHBhcnNlXG4gICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICAvLyBBdHRlbXB0IGEgcGFyc2VcbiAgICAgICAgbGV0IGFzdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBwYXJzZSA9IFNrLnBhcnNlKHRoaXMuZmlsZW5hbWUsIHRoaXMuY29kZSk7XG4gICAgICAgICAgICBhc3QgPSBTay5hc3RGcm9tUGFyc2UocGFyc2UuY3N0LCB0aGlzLmZpbGVuYW1lLCBwYXJzZS5mbGFncyk7XG4gICAgICAgICAgICBsaW5lcyA9IHRoaXMuZ2V0TGluZXMoYXN0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFJlcG9ydCB0aGUgZXJyb3JcbiAgICAgICAgICAgIHJlcG9ydFtcInBhcnNlclwiXSA9IHtcbiAgICAgICAgICAgICAgICBcInN1Y2Nlc3NcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJlcnJvclwiOiBlcnJvcixcbiAgICAgICAgICAgICAgICBcImVtcHR5XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJsaW5lc1wiOiBsaW5lc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5maWxlbmFtZSwgdGhpcy5jb2RlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdWNjZXNzZnVsIHBhcnNlXG4gICAgICAgIHJlcG9ydFtcInBhcnNlclwiXSA9IHtcbiAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJhc3RcIjogYXN0LFxuICAgICAgICAgICAgXCJlbXB0eVwiOiBhc3QuYm9keS5sZW5ndGggPT09IDAsXG4gICAgICAgICAgICBcImxpbmVzXCI6IGxpbmVzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHNob3dFcnJvcnMoKSB7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGlmIChyZXBvcnRbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLmNsZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5wcmVzZW50UnVuRXJyb3IocmVwb3J0LnN0dWRlbnQuZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdmlkZVNlY3JldEVycm9yKCkge1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBsZXQgZmVlZGJhY2sgPSB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjaztcbiAgICAgICAgaWYgKCFyZXBvcnRbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBlcnJvckJ1dHRvbiA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktc3R1ZGVudC1lcnJvclwiKTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gZmVlZGJhY2sucHJlc2VudFJ1bkVycm9yKHJlcG9ydC5zdHVkZW50LmVycm9yLCB0cnVlKTtcbiAgICAgICAgICAgIGVycm9yQnV0dG9uLmF0dHIoXCJ0aXRsZVwiLCBcIkNsaWNrIHRvIHNlZSBPcmlnaW5hbCBFcnJvclwiKTtcbiAgICAgICAgICAgIGVycm9yQnV0dG9uLnRvb2x0aXAoe1widHJpZ2dlclwiOiBcImhvdmVyXCIsIFwiY29udGFpbmVyXCI6IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmF0dGFjaG1lbnRQb2ludH0pO1xuICAgICAgICAgICAgZXJyb3JCdXR0b24uY2xpY2soKCkgPT4gdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX1NIT1dfU1RVREVOVF9FUlJPUihtZXNzYWdlKSk7XG4gICAgICAgICAgICBlcnJvckJ1dHRvbi5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiZXhwb3J0IGxldCBGRUVEQkFDS19IVE1MID0gYFxuXG48c3BhbiBjbGFzcz0nYmxvY2tweS1mbG9hdGluZy1mZWVkYmFjayB0ZXh0LW11dGVkLWxlc3MgcHVsbC1yaWdodCBwb3NpdGlvbi1zdGlja3kgc3RpY2t5LXRvcCdcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIiByb2xlPVwicHJlc2VudGF0aW9uXCIgYXJpYS1sYWJlbD1cIk5ldyBGZWVkYmFjayBBbGVydFwiPlxuICAgIE5ldyBmZWVkYmFjayAmdWFycjtcbjwvc3Bhbj5cblxuPGRpdiBjbGFzcz0nYmxvY2tweS1mZWVkYmFjayBjb2wtbWQtNiBibG9ja3B5LXBhbmVsJ1xuICAgICAgICAgICAgcm9sZT1cInJlZ2lvblwiIGFyaWEtbGFiZWw9XCJGZWVkYmFja1wiXG4gICAgICAgICAgICBhcmlhLWxpdmU9XCJwb2xpdGVcIj5cblxuICAgIDwhLS0gRmVlZGJhY2svVHJhY2UgVmlzaWJpbGl0eSBDb250cm9sIC0tPlxuICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJ1xuICAgICAgICAgICAgY2xhc3M9J2J0biBidG4tc20gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGZsb2F0LXJpZ2h0J1xuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnNlY29uZFJvdy5hZHZhbmNlU3RhdGVcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1leWUnPjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdWkuc2Vjb25kUm93LnN3aXRjaExhYmVsXCI+PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuICAgIFxuICAgIDwhLS0gUG9zaXRpdmUgRmVlZGJhY2sgUmVnaW9uIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJibG9ja3B5LWZlZWRiYWNrLXBvc2l0aXZlIGZsb2F0LXJpZ2h0XCI+XG4gICAgICAgIFxuICAgIFxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBBY3R1YWwgRmVlZGJhY2sgUmVnaW9uIC0tPiAgICBcbiAgICA8ZGl2PlxuICAgICAgICA8c3Ryb25nPkZlZWRiYWNrOiA8L3N0cm9uZz5cbiAgICAgICAgPHNwYW4gY2xhc3M9J2JhZGdlIGJsb2NrcHktZmVlZGJhY2stY2F0ZWdvcnkgZmVlZGJhY2stYmFkZ2UnXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHVpLmZlZWRiYWNrLmJhZGdlLFxuICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB1aS5mZWVkYmFjay5jYXRlZ29yeVwiPkZlZWRiYWNrIEtpbmQ8L3NwYW4+XG4gICAgICAgIDxzbWFsbCBkYXRhLWJpbmQ9XCJ0ZXh0OiAoMTAwKnN1Ym1pc3Npb24uc2NvcmUoKSkrJyUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBkaXNwbGF5Lmluc3RydWN0b3IoKSAmJiBleGVjdXRpb24uZmVlZGJhY2subGFiZWwoKVwiXG4gICAgICAgICAgICBjbGFzcz1cInRleHQtbXV0ZWRcIj48L3NtYWxsPlxuICAgIDwvZGl2PlxuICAgIDxkaXY+XG4gICAgICAgIDxzdHJvbmcgY2xhc3M9XCJibG9ja3B5LWZlZWRiYWNrLWxhYmVsXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInRleHQ6IGV4ZWN1dGlvbi5mZWVkYmFjay5sYWJlbFwiPjwvc3Ryb25nPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS1mZWVkYmFjay1tZXNzYWdlXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImh0bWw6IGV4ZWN1dGlvbi5mZWVkYmFjay5tZXNzYWdlXCI+PC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj4gICAgICAgICAgICBcbmA7XG5cbmV4cG9ydCBjbGFzcyBCbG9ja1B5RmVlZGJhY2sge1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHRoYXQgbWFuYWdlcyB0aGUgZmVlZGJhY2sgYXJlYSwgd2hlcmUgdXNlcnMgYXJlIHRvbGQgdGhlIHN0YXRlIG9mIHRoZWlyXG4gICAgICogcHJvZ3JhbSdzIGV4ZWN1dGlvbiBhbmQgZ2l2ZW4gZ3VpZGFuY2UuIEFsc28gbWFuYWdlcyB0aGUgY3JlYXRpb24gb2YgdGhlIFRyYWNlIFRhYmxlLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHRoaXMge0Jsb2NrUHlGZWVkYmFja31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWcgLSBUaGUgSFRNTCBvYmplY3QgdGhpcyBpcyBhdHRhY2hlZCB0by5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG5cbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjaztcblxuICAgICAgICB0aGlzLmNhdGVnb3J5ID0gdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LWZlZWRiYWNrLWNhdGVnb3J5XCIpO1xuICAgICAgICB0aGlzLmxhYmVsID0gdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LWZlZWRiYWNrLWxhYmVsXCIpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktZmVlZGJhY2stbWVzc2FnZVwiKTtcbiAgICAgICAgdGhpcy5wb3NpdGl2ZSA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1mZWVkYmFjay1wb3NpdGl2ZVwiKTtcblxuICAgICAgICAvLyBUT0RPOiBJZiB0aGV5IGNoYW5nZSB0aGUgc3R1ZGVudCBleHRyYSBmaWxlcywgYWxzbyB1cGRhdGUgdGhlIGRpcnR5IGZsYWdcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuZGlydHlTdWJtaXNzaW9uKHRydWUpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIHNjcmVlbiAodGFrZXMgMSBzZWNvbmQpIHRvIG1ha2UgdGhlIEZlZWRiYWNrIGFyZWEgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldygpIHtcbiAgICAgICAgJChcImh0bWwsIGJvZHlcIikuYW5pbWF0ZSh7XG4gICAgICAgICAgICBzY3JvbGxUb3A6IHRoaXMudGFnLm9mZnNldCgpLnRvcFxuICAgICAgICB9LCAxMDAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZmVlZGJhY2sgYXJlYSBpcyBjdXJyZW50bHkgdmlzaWJsZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRmVlZGJhY2tWaXNpYmxlKCkge1xuICAgICAgICBsZXQgdmlzaWJpbGl0eUJ1ZmZlciA9IDEwMDtcbiAgICAgICAgbGV0IHRvcE9mRWxlbWVudCA9IHRoaXMudGFnLm9mZnNldCgpLnRvcDtcbiAgICAgICAgLy9sZXQgYm90dG9tT2ZFbGVtZW50ID0gdGhpcy50YWcub2Zmc2V0KCkudG9wICsgdGhpcy50YWcub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgbGV0IGJvdHRvbU9mRWxlbWVudCA9IHRvcE9mRWxlbWVudCArIHZpc2liaWxpdHlCdWZmZXI7XG4gICAgICAgIGxldCBib3R0b21PZlNjcmVlbiA9ICQod2luZG93KS5zY3JvbGxUb3AoKSArICQod2luZG93KS5oZWlnaHQoKTtcbiAgICAgICAgbGV0IHRvcE9mU2NyZWVuID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuICAgICAgICAvL2JvdHRvbV9vZl9lbGVtZW50IC09IDQwOyAvLyBVc2VyIGZyaWVuZGx5IHBhZGRpbmdcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh0b3BPZkVsZW1lbnQgPCBib3R0b21PZlNjcmVlbikgJiZcbiAgICAgICAgICAgICh0b3BPZlNjcmVlbiA8IGJvdHRvbU9mRWxlbWVudCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYW55IG91dHB1dCBjdXJyZW50bHkgaW4gdGhlIGZlZWRiYWNrIGFyZWEuIEFsc28gcmVzZXRzIHRoZSBwcmludGVyIGFuZFxuICAgICAqIGFueSBoaWdobGlnaHRlZCBsaW5lcyBpbiB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubWVzc2FnZShcIipSZWFkeSpcIik7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5jYXRlZ29yeShudWxsKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxhYmVsKG51bGwpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwuaGlkZGVuKGZhbHNlKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucmVtb3ZlQWxsKCk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc1VuY292ZXJlZC5yZW1vdmVBbGwoKTtcbiAgICAgICAgdGhpcy5jbGVhclBvc2l0aXZlRmVlZGJhY2soKTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGZpbmRGaXJzdEVycm9yTGluZShmZWVkYmFja0RhdGEpIHtcbiAgICAgICAgaWYgKGZlZWRiYWNrRGF0YS5xdWljayRsb29rdXApIHtcbiAgICAgICAgICAgIGxldCBsb2NhdGlvbiA9IGZlZWRiYWNrRGF0YS5xdWljayRsb29rdXAobmV3IFNrLmJ1aWx0aW4uc3RyKFwibG9jYXRpb25cIikpO1xuICAgICAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSBsb2NhdGlvbi50cCRnZXRhdHRyKG5ldyBTay5idWlsdGluLnN0cihcImxpbmVcIikpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb0pzKGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLypmb3IgKGxldCBpID0gZmVlZGJhY2tEYXRhLmxlbmd0aC0xOyBpID49IDA7IGktPSAxKSB7XG4gICAgICAgICAgICBpZiAoXCJwb3NpdGlvblwiIGluIGZlZWRiYWNrRGF0YVtpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZWVkYmFja0RhdGFbaV0ucG9zaXRpb24ubGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDsqL1xuICAgIH07XG5cbiAgICB1cGRhdGVSZWd1bGFyRmVlZGJhY2soKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBtb2RlbCB3aXRoIHRoZXNlIG5ldyBleGVjdXRpb24gcmVzdWx0c1xuICAgICAqIEBwYXJhbSBleGVjdXRpb25SZXN1bHRzXG4gICAgICovXG4gICAgdXBkYXRlRmVlZGJhY2soZXhlY3V0aW9uUmVzdWx0cykge1xuICAgICAgICAvLyBQYXJzZSBvdXQgZGF0YVxuICAgICAgICBsZXQgbWVzc2FnZSA9IFNrLmZmaS5yZW1hcFRvSnMoZXhlY3V0aW9uUmVzdWx0cy5NRVNTQUdFKTtcbiAgICAgICAgbGV0IGNhdGVnb3J5ID0gU2suZmZpLnJlbWFwVG9KcyhleGVjdXRpb25SZXN1bHRzLkNBVEVHT1JZKTtcbiAgICAgICAgbGV0IGxhYmVsID0gU2suZmZpLnJlbWFwVG9KcyhleGVjdXRpb25SZXN1bHRzLkxBQkVMKTtcbiAgICAgICAgbGV0IGhpZGUgPSBTay5mZmkucmVtYXBUb0pzKGV4ZWN1dGlvblJlc3VsdHMuSElERSk7XG4gICAgICAgIGxldCBkYXRhID0gZXhlY3V0aW9uUmVzdWx0cy5EQVRBO1xuICAgICAgICBsZXQgcG9zaXRpdmVzID0gU2suZmZpLnJlbWFwVG9KcyhleGVjdXRpb25SZXN1bHRzLlBPU0lUSVZFKTtcblxuICAgICAgICAvLyBPdmVycmlkZSBiYXNlZCBvbiBhc3NpZ25tZW50cycgc2V0dGluZ3NcbiAgICAgICAgbGV0IGhpZGVTY29yZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmhpZGRlbigpO1xuICAgICAgICBpZiAoaGlkZVNjb3JlICYmIGNhdGVnb3J5LnRvTG93ZXJDYXNlKCkgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgY2F0ZWdvcnkgPSBcIm5vIGVycm9yc1wiO1xuICAgICAgICAgICAgbGFiZWwgPSBcIk5vIGVycm9yc1wiO1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiTm8gZXJyb3JzIHJlcG9ydGVkLlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtYXAgdG8gZXhwZWN0ZWQgQmxvY2tQeSBsYWJlbHNcbiAgICAgICAgaWYgKGNhdGVnb3J5LnRvTG93ZXJDYXNlKCkgPT09IFwiaW5zdHJ1Y3RvclwiICYmIGxhYmVsLnRvTG93ZXJDYXNlKCkgPT09IFwiZXhwbGFpblwiKSB7XG4gICAgICAgICAgICBsYWJlbCA9IFwiSW5zdHJ1Y3RvciBGZWVkYmFja1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgcHJlc2VudCBhIGxhY2sgb2YgZXJyb3IgYXMgYmVpbmcgaW5jb3JyZWN0XG4gICAgICAgIGlmIChjYXRlZ29yeSA9PT0gXCJJbnN0cnVjdG9yXCIgJiYgbGFiZWwgPT09IFwiTm8gZXJyb3JzXCIpIHtcbiAgICAgICAgICAgIGNhdGVnb3J5ID0gXCJubyBlcnJvcnNcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBtb2RlbCBhY2NvcmRpbmdseVxuICAgICAgICBtZXNzYWdlID0gdGhpcy5tYWluLnV0aWxpdGllcy5tYXJrZG93bihtZXNzYWdlKS5yZXBsYWNlKC88cHJlPlxcbi9nLCBcIjxwcmU+XFxuXFxuXCIpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmNhdGVnb3J5KGNhdGVnb3J5KTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxhYmVsKGxhYmVsKTtcbiAgICAgICAgLy9sZXQgaGlnaGxpZ2h0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLm1lc3NhZ2UuZmluZChcInByZSBjb2RlXCIpLm1hcCggKGksIGJsb2NrKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuaGxqcy5oaWdobGlnaHRCbG9jayhibG9jayk7XG4gICAgICAgIH0pO1xuICAgICAgICAvL30sIDQwMCk7XG4gICAgICAgIC8vIFRPRE86IEluc3RlYWQgb2YgdHJhY2tpbmcgc3R1ZGVudCBmaWxlLCBsZXQncyB0cmFjayB0aGUgaW5zdHJ1Y3RvciBmaWxlXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIkludGVydmVudGlvblwiLCBjYXRlZ29yeSwgbGFiZWwsIG1lc3NhZ2UsIFwiYW5zd2VyLnB5XCIpO1xuXG4gICAgICAgIC8vIENsZWFyIG91dCBhbnkgcHJldmlvdXNseSBoaWdobGlnaHRlZCBsaW5lc1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0uY2xlYXJIaWdobGlnaHRlZExpbmVzKCk7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgZXJyb3Igb24gYSBsaW5lIGFuZCByZXBvcnQgdGhhdFxuICAgICAgICBsZXQgbGluZSA9IEJsb2NrUHlGZWVkYmFjay5maW5kRmlyc3RFcnJvckxpbmUoZGF0YSk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc0Vycm9yLnJlbW92ZUFsbCgpO1xuICAgICAgICBpZiAobGluZSAhPT0gbnVsbCAmJiBsaW5lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc0Vycm9yLnB1c2gobGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnZlcnQgdGhlIHNldCBvZiB0cmFjZWQgbGluZXNcbiAgICAgICAgbGV0IHN0dWRlbnRSZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHMuc3R1ZGVudDtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzVW5jb3ZlcmVkLnJlbW92ZUFsbCgpO1xuICAgICAgICBpZiAoc3R1ZGVudFJlcG9ydC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBsZXQgdW5jb3ZlcmVkTGluZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5wYXJzZXIubGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdHVkZW50UmVwb3J0LmxpbmVzLmluZGV4T2YobGluZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuY292ZXJlZExpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGluZXNVbmNvdmVyZWQodW5jb3ZlcmVkTGluZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBvc2l0aXZlcy5sZW5ndGg7IGkrPTEpIHtcbiAgICAgICAgICAgIGxldCBwb3NpdGl2ZURhdGEgPSBwb3NpdGl2ZXNbaV07XG4gICAgICAgICAgICB0aGlzLmFkZFBvc2l0aXZlRmVlZGJhY2socG9zaXRpdmVEYXRhLm1lc3NhZ2UsIFwic3RhclwiLCBcImdyZWVuXCIsICgpID0+IHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5QT1NJVElWRV9GRUVEQkFDS19GVUxMKHBvc2l0aXZlRGF0YS50aXRsZSwgcG9zaXRpdmVEYXRhLm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyUG9zaXRpdmVGZWVkYmFjaygpIHtcbiAgICAgICAgdGhpcy5wb3NpdGl2ZS5lbXB0eSgpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIuZmluZChcIi5ibG9ja3B5LXN0dWRlbnQtZXJyb3JcIikuaGlkZSgpO1xuICAgIH1cblxuICAgIGFkZFBvc2l0aXZlRmVlZGJhY2sodGV4dCwgaWNvbiwgY29sb3IsIG9uY2xpY2ssIHRvRW5kKSB7XG4gICAgICAgIGxldCBwb3NpdGl2ZSA9ICQoXCI8c3Bhbj48L3NwYW4+XCIpO1xuICAgICAgICBwb3NpdGl2ZS5hZGRDbGFzcyhcImJsb2NrcHktZmVlZGJhY2stcG9zaXRpdmUtaWNvbiBmYXMgZmEtXCIraWNvbik7XG4gICAgICAgIHBvc2l0aXZlLmNzcyhcImNvbG9yXCIsIGNvbG9yKTtcbiAgICAgICAgcG9zaXRpdmUuYXR0cihcInRpdGxlXCIsIHRleHQpO1xuICAgICAgICBpZiAodG9FbmQpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpdmUuYXBwZW5kKHBvc2l0aXZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpdmUucHJlcGVuZChwb3NpdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpdmUudG9vbHRpcCh7XCJ0cmlnZ2VyXCI6IFwiaG92ZXJcIiwgXCJjb250YWluZXJcIjogdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uYXR0YWNobWVudFBvaW50fSk7XG4gICAgICAgIGlmIChvbmNsaWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBvc2l0aXZlLmNsaWNrKG9uY2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aXZlLmhvdmVyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRmVlZGJhY2tcIiwgXCJwb3NpdGl2ZVwiLCBcImhvdmVyXCIsIHRleHQsIFwiXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVzZW50IGFueSBhY2N1bXVsYXRlZCBmZWVkYmFja1xuICAgICAqL1xuICAgIHByZXNlbnRGZWVkYmFjayhleGVjdXRpb25SZXN1bHRzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRmVlZGJhY2soZXhlY3V0aW9uUmVzdWx0cyk7XG5cbiAgICAgICAgLy8gVE9ETzogTG9nZ2luZ1xuICAgICAgICAvL3RoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcImZlZWRiYWNrXCIsIGNhdGVnb3J5K1wifFwiK2xhYmVsLCBtZXNzYWdlKTtcblxuICAgICAgICB0aGlzLm5vdGlmeUZlZWRiYWNrVXBkYXRlKCk7XG4gICAgfTtcblxuICAgIG5vdGlmeUZlZWRiYWNrVXBkYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNGZWVkYmFja1Zpc2libGUoKSkge1xuICAgICAgICAgICAgdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LWZsb2F0aW5nLWZlZWRiYWNrXCIpLnNob3coKS5mYWRlT3V0KDcwMDApO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByZXNlbnRSdW5FcnJvcihlcnJvciwganVzdF9yZXR1cm4pIHtcbiAgICAgICAgaWYgKGp1c3RfcmV0dXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGp1c3RfcmV0dXJuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lc3NhZ2UsIGxhYmVsLCBjYXRlZ29yeSwgbGluZW5vO1xuICAgICAgICBsYWJlbCA9IGVycm9yLnRwJG5hbWU7XG4gICAgICAgIGNhdGVnb3J5ID0gXCJydW50aW1lXCI7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLmNvbnZlcnRTa3VscHRFcnJvcihlcnJvcik7XG5cbiAgICAgICAgaWYgKGp1c3RfcmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmNhdGVnb3J5KGNhdGVnb3J5KTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxhYmVsKGxhYmVsKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucmVtb3ZlQWxsKCk7XG4gICAgICAgIGlmIChsaW5lbm8gIT09IHVuZGVmaW5lZCAmJiBsaW5lbm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc0Vycm9yLnB1c2gobGluZW5vKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnZlcnRTa3VscHRFcnJvcihlcnJvciwgZmlsZW5hbWVFeGVjdXRlZCkge1xuICAgICAgICBsZXQgbmFtZSA9IGVycm9yLnRwJG5hbWU7XG4gICAgICAgIGxldCBhcmdzID0gU2suZmZpLnJlbWFwVG9KcyhlcnJvci5hcmdzKTtcbiAgICAgICAgbGV0IHRvcCA9IGAke25hbWV9OiAke2FyZ3NbMF19XFxuPGJyPlxcbjxicj5gO1xuICAgICAgICBsZXQgdHJhY2ViYWNrID0gXCJcIjtcbiAgICAgICAgaWYgKGVycm9yLnRyYWNlYmFjayAmJiBlcnJvci50cmFjZWJhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICB0cmFjZWJhY2sgPSBcIlRyYWNlYmFjazo8YnI+XFxuXCIgKyBlcnJvci50cmFjZWJhY2subWFwKGZyYW1lID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZW5vID0gZnJhbWUubGluZW5vO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZS5maWxlbmFtZS5zbGljZSgwLCAtMykgPT09IGZpbGVuYW1lRXhlY3V0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZW5vIC09IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5pbnN0cnVjdG9yLmxpbmVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBmaWxlID0gYEZpbGUgPGNvZGUgY2xhc3M9XCJmaWxlbmFtZVwiPlwiJHtmcmFtZS5maWxlbmFtZX1cIjwvY29kZT4sIGA7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSBgb24gbGluZSA8Y29kZSBjbGFzcz1cImxpbmVub1wiPiR7bGluZW5vfTwvY29kZT4sIGA7XG4gICAgICAgICAgICAgICAgbGV0IHNjb3BlID0gKGZyYW1lLnNjb3BlICE9PSBcIjxtb2R1bGU+XCIgJiZcbiAgICAgICAgICAgICAgICBmcmFtZS5zY29wZSAhPT0gdW5kZWZpbmVkKSA/IGBpbiBzY29wZSAke2ZyYW1lLnNjb3BlfWAgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGxldCBzb3VyY2UgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZS5zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBgXFxuPHByZT48Y29kZT4ke2ZyYW1lLnNvdXJjZX08L2NvZGU+PC9wcmU+YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGUgKyBsaW5lICsgc2NvcGUgKyBzb3VyY2U7XG4gICAgICAgICAgICB9KS5qb2luKFwiXFxuPGJyPlwiKTtcbiAgICAgICAgICAgIHRyYWNlYmFjayA9IGAke3RyYWNlYmFja31gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3ArXCJcXG5cIit0cmFjZWJhY2s7XG4gICAgfVxuXG4gICAgcHJlc2VudEludGVybmFsRXJyb3IoZXJyb3IsIGZpbGVuYW1lRXhlY3V0ZWQpIHtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5jYXRlZ29yeShcImludGVybmFsXCIpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmxhYmVsKFwiSW50ZXJuYWwgRXJyb3JcIik7XG5cbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIkVycm9yIGluIGluc3RydWN0b3IgZmVlZGJhY2suIFBsZWFzZSBzaG93IHRoZSBmb2xsb3dpbmcgdG8gYW4gaW5zdHJ1Y3Rvcjo8YnI+XFxuXCI7XG4gICAgICAgIG1lc3NhZ2UgKz0gdGhpcy5jb252ZXJ0U2t1bHB0RXJyb3IoZXJyb3IsIGZpbGVuYW1lRXhlY3V0ZWQpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLm1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnlGZWVkYmFja1VwZGF0ZSgpO1xuXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtU3lzdGVtLkVycm9yXCIsIFwiaW50ZXJuYWxcIiwgXCJJbnRlcm5hbCBFcnJvclwiLCBtZXNzYWdlLCBmaWxlbmFtZUV4ZWN1dGVkKTtcbiAgICB9XG59IiwiaW1wb3J0IHtmaXJzdERlZmluZWRWYWx1ZX0gZnJvbSBcInV0aWxpdGllcy5qc1wiO1xuXG4vLyAke21ha2VUYWIoXCI/bW9ja191cmxzLmJsb2NrcHlcIiwgXCJVUkwgRGF0YVwiLCB0cnVlKX1cblxuY29uc3QgbWFrZVRhYiA9IGZ1bmN0aW9uKGZpbGVuYW1lLCBmcmllbmRseU5hbWUsIGhpZGVJZkVtcHR5LCBub3RJbnN0cnVjdG9yKSB7XG4gICAgaWYgKGZyaWVuZGx5TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZyaWVuZGx5TmFtZSA9IGZpbGVuYW1lO1xuICAgIH1cbiAgICBsZXQgaW5zdHJ1Y3RvckZpbGVDbGFzcyA9IFwiXCI7XG4gICAgbGV0IGhpZGVJZk5vdEluc3RydWN0b3IgPSBcInRydWVcIjtcbiAgICBpZiAoIW5vdEluc3RydWN0b3IpIHtcbiAgICAgICAgaW5zdHJ1Y3RvckZpbGVDbGFzcyA9IFwiYmxvY2tweS1maWxlLWluc3RydWN0b3JcIjtcbiAgICAgICAgaGlkZUlmTm90SW5zdHJ1Y3RvciA9IFwiZGlzcGxheS5pbnN0cnVjdG9yKClcIjtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbSAke2luc3RydWN0b3JGaWxlQ2xhc3N9XCI+XG4gICAgICAgIDxhIGNsYXNzPVwibmF2LWxpbmtcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICBkYXRhLXRvZ2dsZT1cInRhYlwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6IGRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gJyR7ZmlsZW5hbWV9J30sXG4gICAgICAgICAgICAgICAgY2xpY2s6IGRpc3BsYXkuZmlsZW5hbWUuYmluZCgkZGF0YSwgJyR7ZmlsZW5hbWV9JyksXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogKCEke2hpZGVJZkVtcHR5fSB8fCB1aS5maWxlcy5oYXNDb250ZW50cygnJHtmaWxlbmFtZX0nKSkgJiYgJHtoaWRlSWZOb3RJbnN0cnVjdG9yfVwiPlxuICAgICAgICAgICAgJHtmcmllbmRseU5hbWV9PC9hPlxuICAgIDwvbGk+YDtcbn07XG5cbmV4cG9ydCBsZXQgRklMRVNfSFRNTCA9IGBcbjxkaXYgY2xhc3M9XCJjb2wtbWQtMTIgYmxvY2tweS1wYW5lbCBibG9ja3B5LWZpbGVzXCJcbiAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5maWxlcy52aXNpYmxlXCI+XG48dWwgY2xhc3M9XCJuYXYgbmF2LXRhYnNcIiByb2xlPVwidGFibGlzdFwiPlxuXG4gICAgPGxpIGNsYXNzPVwibmF2LWl0ZW1cIj5cbiAgICAgICAgPHN0cm9uZz5WaWV3OiA8L3N0cm9uZz5cbiAgICA8L2xpPlxuXG4gICAgJHttYWtlVGFiKFwiYW5zd2VyLnB5XCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKX1cbiAgICAke21ha2VUYWIoXCIhaW5zdHJ1Y3Rpb25zLm1kXCIsIFwiSW5zdHJ1Y3Rpb25zXCIpfVxuICAgICR7bWFrZVRhYihcIiFhc3NpZ25tZW50X3NldHRpbmdzLmJsb2NrcHlcIiwgXCJTZXR0aW5nc1wiKX1cbiAgICAke21ha2VUYWIoXCJec3RhcnRpbmdfY29kZS5weVwiLCBcIlN0YXJ0aW5nIENvZGVcIil9XG4gICAgJHttYWtlVGFiKFwiIW9uX3J1bi5weVwiLCBcIk9uIFJ1blwiKX1cbiAgICAke21ha2VUYWIoXCIhb25fY2hhbmdlLnB5XCIsIFwiT24gQ2hhbmdlXCIsIHRydWUpfVxuICAgICR7bWFrZVRhYihcIiFvbl9ldmFsLnB5XCIsIFwiT24gRXZhbFwiLCB0cnVlKX1cbiAgICAke21ha2VUYWIoXCIhc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHlcIiwgXCJTYW1wbGUgU3VibWlzc2lvbnNcIiwgdHJ1ZSl9XG4gICAgJHttYWtlVGFiKFwiIXRhZ3MuYmxvY2tweVwiLCBcIlRhZ3NcIiwgdHJ1ZSl9XG4gICAgXG4gICAgPCEtLSBrbyBmb3JlYWNoOiBhc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzIC0tPlxuICAgICAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbVwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHsnYmxvY2tweS1maWxlLWluc3RydWN0b3InOiAhZmlsZW5hbWUoKS5zdGFydHNXaXRoKCcmJyl9LFxuICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBmaWxlbmFtZSgpLnN0YXJ0c1dpdGgoJyYnKSB8fCAkcm9vdC5kaXNwbGF5Lmluc3RydWN0b3IoKSBcIj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwibmF2LWxpbmtcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJ0YWJcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogJHJvb3QuZGlzcGxheS5maWxlbmFtZSgpID09PSBmaWxlbmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5lZGl0YWJsZTogZmlsZW5hbWUoKS5zdGFydHNXaXRoKCcmJyl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiAkcm9vdC5kaXNwbGF5LmZpbGVuYW1lLmJpbmQoJGRhdGEsIGZpbGVuYW1lKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICRyb290LnVpLmZpbGVzLmRpc3BsYXlGaWxlbmFtZShmaWxlbmFtZSgpKVwiPlxuICAgICAgICAgICAgPC9hPiAgICAgICAgXG4gICAgICAgIDwvbGk+XG4gICAgPCEtLSAva28gLS0+XG4gICAgPCEtLSBrbyBmb3JlYWNoOiBhc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcyAtLT5cbiAgICAgICAgPGxpIGNsYXNzPVwibmF2LWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogJHJvb3QuZGlzcGxheS5pbnN0cnVjdG9yKClcIj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwibmF2LWxpbmtcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJ0YWJcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogJHJvb3QuZGlzcGxheS5maWxlbmFtZSgpID09PSBmaWxlbmFtZSgpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogJHJvb3QuZGlzcGxheS5maWxlbmFtZS5iaW5kKCRkYXRhLCBmaWxlbmFtZSgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBmaWxlbmFtZVwiPlxuICAgICAgICAgICAgPC9hPiAgICAgICAgXG4gICAgICAgIDwvbGk+XG4gICAgPCEtLSAva28gLS0+XG4gICAgXG4gICAgPCEtLSBrbyBmb3JlYWNoOiBzdWJtaXNzaW9uLmV4dHJhRmlsZXMgLS0+XG4gICAgICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtXCI+XG4gICAgICAgICAgICA8YSBjbGFzcz1cIm5hdi1saW5rXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwidGFiXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gZmlsZW5hbWUoKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUuYmluZCgkZGF0YSwgZmlsZW5hbWUoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJHJvb3QudWkuZmlsZXMuZGlzcGxheUZpbGVuYW1lKGZpbGVuYW1lKCkpXCI+XG4gICAgICAgICAgICA8L2E+ICAgICAgICBcbiAgICAgICAgPC9saT5cbiAgICA8IS0tIC9rbyAtLT5cbiAgXG4gICAgPGxpIGNsYXNzPVwibmF2LWl0ZW0gZHJvcGRvd25cIj5cbiAgICAgICAgPGEgY2xhc3M9XCJuYXYtbGluayBkcm9wZG93bi10b2dnbGVcIiBocmVmPVwiI1wiIGRhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIlxuICAgICAgICAgcm9sZT1cImJ1dHRvblwiIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCI+QWRkIE5ldzwvYT5cbiAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnUgZHJvcGRvd24tbWVudS1yaWdodFwiPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuZmlsZXMuaGFzQ29udGVudHMoJz9tb2NrX3VybHMuYmxvY2tweScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnP21vY2tfdXJscy5ibG9ja3B5JylcIj5VUkwgRGF0YTwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCc/dG9vbGJveC5ibG9ja3B5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICc/dG9vbGJveC5ibG9ja3B5JylcIj5Ub29sYm94PC9hPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5maWxlcy5oYXNDb250ZW50cygnIXRhZ3MuYmxvY2tweScpXCI+VGFnczwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCchc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJyFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweScpXCI+U2FtcGxlIFN1Ym1pc3Npb25zPC9hPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLWRpdmlkZXJcIj48L2Rpdj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IGFzc2lnbm1lbnQub25DaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICchb25fY2hhbmdlLnB5JylcIj5PbiBDaGFuZ2U8L2E+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiBhc3NpZ25tZW50Lm9uRXZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJyFvbl9ldmFsLnB5JylcIj5PbiBFdmFsPC9hPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLWRpdmlkZXJcIj48L2Rpdj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICdzdGFydGluZycpXCI+U3RhcnRpbmcgRmlsZTwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICdpbnN0cnVjdG9yJylcIj5JbnN0cnVjdG9yIEZpbGU8L2E+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW1cIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnc3R1ZGVudCcpXCI+U3R1ZGVudCBGaWxlPC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2xpPlxuICBcbjwvdWw+XG48L2Rpdj5cbmA7XG5cbmNvbnN0IE5FV19JTlNUUlVDVE9SX0ZJTEVfRElBTE9HX0hUTUwgPSBgXG48Zm9ybT5cbjxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgIDwhLS0gRmlsZW5hbWUgLS0+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1maWxlbmFtZVwiPkZpbGVuYW1lOjwvbGFiZWw+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbCBibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZW5hbWVcIlxuICAgICAgICAgICAgaWQ9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZW5hbWVcIj4gICAgXG4gICAgPC9kaXY+XG4gICAgPCEtLSBGaWxldHlwZSAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodCBtdC0yXCI+XG4gICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZXR5cGVcIj5GaWxldHlwZTogPC9sYWJlbD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGV0eXBlXCJcbiAgICAgICAgICAgIGlkPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGV0eXBlXCI+PC9zcGFuPiAgICBcbiAgICA8L2Rpdj5cbiAgICA8IS0tIEluYWNjZXNzaWJsZSB0byBzdHVkZW50PyAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodCBtdC0yXCI+XG4gICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctbmFtZXNwYWNlXCI+TmFtZXNwYWNlOiA8L2xhYmVsPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tNFwiPlxuICAgICAgICA8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sIGJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1uYW1lc3BhY2VcIlxuICAgICAgICAgICAgaWQ9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctbmFtZXNwYWNlXCI+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIVwiPkNvbXBsZXRlbHkgaW5hY2Nlc3NpYmxlPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiP1wiPkhpZGRlbiBmcm9tIHN0dWRlbnQsIGFjY2Vzc2libGUgcHJvZ3JhbWF0aWNhbGx5PC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiJlwiPlZpc2libGUgdG8gc3R1ZGVudCwgYnV0IG5vdCBlZGl0YWJsZTwvb3B0aW9uPlxuICAgICAgICA8L3NlbGVjdD5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuPC9mb3JtPlxuYDtcblxuLyoqXG4gKiBGaWxlbmFtZXMgbGl2ZSBpbiBvbmUgb2YgZml2ZSBwb3NzaWJsZSBuYW1lc3BhY2VzOlxuICogIEluc3RydWN0b3IgKCEpOiBJbnZpc2libGUgdG8gdGhlIHN0dWRlbnQgdW5kZXIgYWxsIGNpcmN1bXN0YW5jZXNcbiAqICBTdGFydCBTcGFjZSAoXik6IFVzZWQgdG8gcmVzZXQgdGhlIHN0dWRlbnQgbmFtZXNwYWNlXG4gKiAgU3R1ZGVudCBTcGFjZSAoKTogVmlzaWJsZSB0byB0aGUgc3R1ZGVudCB3aGVuIGRpc3BsYXkuaGlkZUZpbGVzIGlzIG5vdCB0cnVlLCBhYmxlIHRvIGJlIGVkaXRlZFxuICogIEhpZGRlbiBTcGFjZSAoPyk6IE5vdCBkaXJlY3RseSB2aXNpYmxlIHRvIHRoZSBzdHVkZW50LCBidXQgYWNjZXNzaWJsZSBwcm9ncmFtbWF0aWNhbGx5XG4gKiAgUmVhZC1vbmx5IFNwYWNlICgmKTogQW4gaW5zdHJ1Y3RvciBmaWxlIHR5cGUgdmlzaWJsZSB0byB0aGUgc3R1ZGVudCwgYnV0IGlzIHVuZWRpdGFibGUgYnkgdGhlbVxuICogIFNlY3JldCBTcGFjZSAoJCk6IE5vdCB2aXNpYmxlIGZyb20gdGhlIG1lbnUgYXQgYWxsLCBzb21lIG90aGVyIG1lY2hhbmlzbSBjb250cm9scyBpdFxuICogIEdlbmVyYXRlZCBTcGFjZSAoKik6IFZpc2libGUgdG8gdGhlIHN0dWRlbnQsIGJ1dCBkZXN0cm95ZWQgYWZ0ZXIgRW5naW5lLkNsZWFyLiBDYW4gc2hhZG93IGFuIGFjdHVhbCBmaWxlLlxuICogIENvbmNhdGVuYXRlZCBTcGFjZSAoIyk6IFVzZWQgd2hlbiBidW5kbGluZyBhIHNwYWNlIGZvciB0aGUgc2VydmVyLlxuICovXG5cbmV4cG9ydCBsZXQgU1RBUlRJTkdfRklMRVMgPSBbXG4gICAgLy8gU3VibWlzc2lvblxuICAgIFwiYW5zd2VyLnB5XCIsXG4gICAgLy8gSW5zdHJ1Y3RvciBmaWxlc1xuICAgIFwiIWluc3RydWN0aW9ucy5tZFwiLFxuICAgIFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MuYmxvY2tweVwiLFxuICAgIFwiXnN0YXJ0aW5nX2NvZGUucHlcIixcbiAgICBcIiFvbl9ydW4ucHlcIixcbiAgICBcIiRzZXR0aW5ncy5ibG9ja3B5XCIsXG5dO1xuXG5leHBvcnQgY29uc3QgQkFTSUNfTkVXX0ZJTEVTID0gW1xuICAgIFwiIW9uX2NoYW5nZS5weVwiLFxuICAgIFwiIW9uX2V2YWwucHlcIixcbiAgICBcIj9tb2NrX3VybHMuYmxvY2tweVwiLFxuICAgIFwiP3Rvb2xib3guYmxvY2tweVwiLFxuICAgIFwiIXRhZ3MuYmxvY2tweVwiLFxuICAgIFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCJcbl07XG5cbmNvbnN0IElOU1RSVUNUT1JfRElSRUNUT1JZID0gXCJfaW5zdHJ1Y3Rvci9cIjtcbmNvbnN0IFNUVURFTlRfRElSRUNUT1JZID0gXCJfc3R1ZGVudC9cIjtcblxuY29uc3QgU2VhcmNoTW9kZXMgPSB7XG4gICAgRVZFUllXSEVSRTogXCJFVkVSWVdIRVJFXCIsXG4gICAgU1RBUlRfV0lUSF9JTlNUUlVDVE9SOiBcIlNUQVJUX1dJVEhfSU5TVFJVQ1RPUlwiLFxuICAgIE9OTFlfU1RVREVOVF9GSUxFUzogXCJPTkxZX1NUVURFTlRfRklMRVNcIlxufTtcblxuY29uc3QgREVMRVRBQkxFX1NJTVBMRV9GSUxFUyA9IFtcIiFvbl9jaGFuZ2UucHlcIiwgXCIhb25fZXZhbC5weVwiXTtcblxuZXhwb3J0IGNvbnN0IFVOREVMRVRBQkxFX0ZJTEVTID0gW1wiYW5zd2VyLnB5XCIsIFwiIWluc3RydWN0aW9ucy5tZFwiLCBcIiFhc3NpZ25tZW50X3NldHRpbmdzLnB5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJec3RhcnRpbmdfY29kZS5weVwiLCBcIiFvbl9ydW4ucHlcIiwgXCIkc2V0dGluZ3MuYmxvY2tweVwiXTtcblxuZXhwb3J0IGNvbnN0IFVOUkVOQU1BQkxFX0ZJTEVTID0gW1wiYW5zd2VyLnB5XCIsIFwiIWluc3RydWN0aW9ucy5tZFwiLCBcIiFhc3NpZ25tZW50X3NldHRpbmdzLnB5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJec3RhcnRpbmdfY29kZS5weVwiLCBcIiFvbl9ydW4ucHlcIiwgXCIkc2V0dGluZ3MuYmxvY2tweVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIW9uX2NoYW5nZS5weVwiLCBcIiFvbl9ldmFsLnB5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI/bW9ja191cmxzLmJsb2NrcHlcIiwgXCI/dG9vbGJveC5ibG9ja3B5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIhdGFncy5ibG9ja3B5XCIsIFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCJdO1xuXG5jbGFzcyBCbG9ja1B5RmlsZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgZmlsZW5hbWUsIGNvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5jb250ZW50cyA9IGNvbnRlbnRzIHx8IFwiXCI7XG4gICAgICAgIHRoaXMub3duZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZSA9IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZU1vZGVsRmlsZShmaWxlbmFtZSwgY29udGVudHMpIHtcbiAgICByZXR1cm4ge1wiZmlsZW5hbWVcIjoga28ub2JzZXJ2YWJsZShmaWxlbmFtZSksIGNvbnRlbnRzOiBrby5vYnNlcnZhYmxlKGNvbnRlbnRzIHx8IFwiXCIpfTtcbn1cblxuZnVuY3Rpb24gbWFrZU1vY2tNb2RlbEZpbGUoZmlsZW5hbWUsIGNvbnRlbnRzKSB7XG4gICAgcmV0dXJuIHsgZmlsZW5hbWU6ICgpID0+IGZpbGVuYW1lLCBjb250ZW50czogKCkgPT4gY29udGVudHMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRDb25jYXRlbmF0ZWRGaWxlKGNvbmNhdGVuYXRlZEZpbGUsIG1vZGVsRmlsZUxpc3QpIHtcbiAgICBpZiAoY29uY2F0ZW5hdGVkRmlsZSkge1xuICAgICAgICBsZXQgZmlsZXMgPSBKU09OLnBhcnNlKGNvbmNhdGVuYXRlZEZpbGUpO1xuICAgICAgICBsZXQgbW9kZWxGaWxlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBmaWxlbmFtZSBpbiBmaWxlcykge1xuICAgICAgICAgICAgaWYgKGZpbGVzLmhhc093blByb3BlcnR5KGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgIG1vZGVsRmlsZXMucHVzaChtYWtlTW9kZWxGaWxlKGZpbGVuYW1lLCBmaWxlc1tmaWxlbmFtZV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL2ZpbGVzID0gZmlsZXMubWFwKGZpbGUgPT4gbWFrZU1vZGVsRmlsZShmaWxlLmZpbGVuYW1lLCBmaWxlLmNvbnRlbnRzKSk7XG4gICAgICAgIG1vZGVsRmlsZUxpc3QobW9kZWxGaWxlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWxGaWxlTGlzdChbXSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29uY2F0ZW5hdGVkRmlsZShtb2RlbEZpbGVMaXN0KSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1vZGVsRmlsZUxpc3QoKS5tYXAoZmlsZSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxlbmFtZTogZmlsZS5maWxlbmFtZSgpLFxuICAgICAgICAgICAgY29udGVudHM6IGZpbGUuY29udGVudHMoKVxuICAgICAgICB9O1xuICAgIH0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVDb25jYXRlbmF0ZWRGaWxlKG1vZGVsRmlsZUxpc3QpIHtcbiAgICByZXR1cm4ga28ucHVyZUNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBtb2RlbEZpbGVMaXN0KCkuZm9yRWFjaChmaWxlID0+XG4gICAgICAgICAgICByZXN1bHRbZmlsZS5maWxlbmFtZSgpXSA9IGZpbGUuY29udGVudHMoKSk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFic3RyYWN0cyBhd2F5IGRhdGFiYXNlIGxvZ2ljXG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9ja1B5RmlsZVN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLmZpbGVzXyA9IHt9O1xuICAgICAgICB0aGlzLm1vdW50RmlsZXMoKTtcblxuICAgICAgICB0aGlzLndhdGNoTW9kZWwoKTtcbiAgICAgICAgdGhpcy53YXRjaGVzXyA9IHt9O1xuXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3Iuc3Vic2NyaWJlKCh2aXNpYmxpdHkpPT4ge1xuICAgICAgICAgICAgJChcIi5ibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiKS50b2dnbGUodmlzaWJsaXR5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgd2F0Y2hGaWxlKGZpbGVuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIShmaWxlbmFtZSBpbiB0aGlzLndhdGNoZXNfKSkge1xuICAgICAgICAgICAgdGhpcy53YXRjaGVzX1tmaWxlbmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhdGNoZXNfW2ZpbGVuYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBzdG9wV2F0Y2hpbmdGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLndhdGNoZXNfW2ZpbGVuYW1lXTtcbiAgICB9XG5cbiAgICB3YXRjaE1vZGVsKCkge1xuICAgICAgICBsZXQgZmlsZXN5c3RlbSA9IHRoaXM7XG4gICAgICAgIFt0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzLFxuICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFTdGFydGluZ0ZpbGVzLFxuICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXNdLmZvckVhY2goZmlsZUFycmF5ID0+XG4gICAgICAgICAgICBmaWxlQXJyYXkuc3Vic2NyaWJlKGZ1bmN0aW9uKGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW9kZWxGaWxlID0gY2hhbmdlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnN0YXR1cyA9PT0gXCJhZGRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFjayBuZXcgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGUgPSBmaWxlc3lzdGVtLm5ld0ZpbGUobW9kZWxGaWxlLmZpbGVuYW1lKCksIG1vZGVsRmlsZS5jb250ZW50cygpLCBtb2RlbEZpbGUuY29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXN5c3RlbS5ub3RpZnlXYXRjaGVzKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZS5zdGF0dXMgPT09IFwiZGVsZXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXN5c3RlbS5kZWxldGVGaWxlTG9jYWxseV8obW9kZWxGaWxlLmZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcywgXCJhcnJheUNoYW5nZVwiKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIGFuc3dlci5weVxuICAgIC8vICAgPT4gc3Vic2NyaWJlIHRvIGZpcnN0IGVsZW1lbnQgb2Ygc3VibWlzc2lvbi5jb2RlKVxuICAgIC8vICFvbl9ydW4ucHksICFvbl9jaGFuZ2UucHksICFvbl9ldmFsLnB5XG4gICAgLy8gICA9PiBzdWJzY3JpYmUgdG8gcmVsZXZhbnQgYXNzaWdubWVudC48d2hhdGV2ZXI+XG4gICAgLy8gXnN0YXJ0aW5nX2NvZGUucHlcbiAgICAvLyAgID0+IHN1YnNjcmliZSB0byBmaXJzdCBlbGVtZW50IG9mIGFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlXG4gICAgLy8gXndoYXRldmVyXG4gICAgLy8gICA9PiBzdWJzY3JpYmUgdG8gcmVzdCBvZiB0aGUgZWxlbWVudHMgb2YgYXNzaWdubWVudC5zdGFydGluZ0NvZGVcbiAgICAvLyAhd2hhdGV2ZXIgb3IgP3doYXRldmVyXG4gICAgLy8gICA9PiBzdWJzY3JpYmUgdG8gZWxlbWVudHMgb2YgYXNzaWdubWVudC5leHRyYUZpbGVzXG4gICAgLy8gT3RoZXJ3aXNlOlxuICAgIC8vICAgPT4gc3Vic2NyaWJlIHRvIHJlc3Qgb2YgdGhlIGVsZW1lbnRzIG9mIHN1Ym1pc3Npb24uY29kZVxuICAgIC8qKlxuICAgICAqIE5ldyBzcGVjaWFsIGZpbGVzIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCBoZXJlXG4gICAgICogQHBhcmFtIGZpbGUge0Jsb2NrUHlGaWxlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb2JzZXJ2ZUZpbGVfKGZpbGUpIHtcbiAgICAgICAgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFvbl9ydW4ucHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vblJ1bjtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFvbl9jaGFuZ2UucHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFvbl9ldmFsLnB5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25FdmFsO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIWluc3RydWN0aW9ucy5tZFwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lmluc3RydWN0aW9ucztcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIl5zdGFydGluZ19jb2RlLnB5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiP21vY2tfdXJscy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIj90b29sYm94LmJsb2NrcHlcIikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW5BcnJheV8oZmlsZSwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIXRhZ3MuYmxvY2tweVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnRhZ3M7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhYXNzaWdubWVudF9zZXR0aW5ncy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3M7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zYW1wbGVTdWJtaXNzaW9ucztcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiRzZXR0aW5ncy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZS5zdGFydHNXaXRoKFwiXlwiKSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW5BcnJheV8oZmlsZSwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFTdGFydGluZ0ZpbGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lLnN0YXJ0c1dpdGgoXCIhXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgZmlsZS5maWxlbmFtZS5zdGFydHNXaXRoKFwiP1wiKSB8fFxuICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUuc3RhcnRzV2l0aChcIiZcIikpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb2JzZXJ2ZUluQXJyYXlfKGZpbGUsIGFycmF5KSB7XG4gICAgICAgIGZpbGUub3duZXIgPSBhcnJheTtcbiAgICAgICAgbGV0IGNvZGVCdW5kbGUgPSBmaWxlLm93bmVyKCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IGNvZGVCdW5kbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb2RlQnVuZGxlW2ldLmZpbGVuYW1lKCkgPT09IGZpbGUuZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICBmaWxlLmhhbmRsZSA9IGNvZGVCdW5kbGVbaV0uY29udGVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGUuaGFuZGxlID09PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgbmV3RmlsZSA9IG1ha2VNb2RlbEZpbGUoZmlsZS5maWxlbmFtZSk7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IG5ld0ZpbGUuY29udGVudHM7XG4gICAgICAgICAgICBhcnJheS5wdXNoKG5ld0ZpbGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW91bnRGaWxlcygpIHtcbiAgICAgICAgdGhpcy5uZXdGaWxlKFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICB0aGlzLm5ld0ZpbGUoXCJec3RhcnRpbmdfY29kZS5weVwiKTtcbiAgICAgICAgdGhpcy5uZXdGaWxlKFwiIW9uX3J1bi5weVwiKTtcbiAgICAgICAgdGhpcy5uZXdGaWxlKFwiIWluc3RydWN0aW9ucy5tZFwiKTtcbiAgICAgICAgdGhpcy5uZXdGaWxlKFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MuYmxvY2tweVwiKTtcbiAgICB9XG5cbiAgICBkaXNtb3VudEV4dHJhRmlsZXMoKSB7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5maWxlc18pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbGVzXy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmIChVTkRFTEVUQUJMRV9GSUxFUy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlc19bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndhdGNoZXNfW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzdWJtaXNzaW9uLmNvZGVUT0RPOiBTaG91bGRuJ3Qgd2Ugbm90aWZ5IHRoZSBVSSB0aGF0IHRoZSBmaWxlIHdhcyBkZWxldGVkP1xuICAgIH1cblxuICAgIG5ld0ZpbGUoZmlsZW5hbWUsIGNvbnRlbnRzLCBtb2RlbEZpbGUpIHtcbiAgICAgICAgaWYgKGZpbGVuYW1lIGluIHRoaXMuZmlsZXNfKSB7XG4gICAgICAgICAgICAvLyBGaWxlIGFscmVhZHkgZXhpc3RzISBKdXN0IHVwZGF0ZSBpdHMgaGFuZGxlXG4gICAgICAgICAgICBsZXQgZXhpc3RpbmdGaWxlID0gdGhpcy5maWxlc19bZmlsZW5hbWVdO1xuICAgICAgICAgICAgaWYgKG1vZGVsRmlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlRmlsZV8oZXhpc3RpbmdGaWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdGaWxlLmhhbmRsZSA9IG1vZGVsRmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4aXN0aW5nRmlsZS5oYW5kbGUoY29udGVudHMgfHwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdGaWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlsZSBkb2VzIG5vdCBleGlzdFxuICAgICAgICAgICAgbGV0IG5ld0ZpbGUgPSBuZXcgQmxvY2tQeUZpbGUodGhpcy5tYWluLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZpbGVzX1tmaWxlbmFtZV0gPSBuZXdGaWxlO1xuICAgICAgICAgICAgaWYgKG1vZGVsRmlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlRmlsZV8obmV3RmlsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0ZpbGUuaGFuZGxlID0gbW9kZWxGaWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXdGaWxlLmhhbmRsZShjb250ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3RmlsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlRmlsZShmaWxlbmFtZSwgY29udGVudHMpIHtcbiAgICAgICAgY29udGVudHMgPSBjb250ZW50cyB8fCBcIlwiO1xuICAgICAgICB0aGlzLmZpbGVzX1tmaWxlbmFtZV0uaGFuZGxlKGNvbnRlbnRzKTtcbiAgICB9XG5cbiAgICByZWFkRmlsZShmaWxlbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlc19bZmlsZW5hbWVdLmhhbmRsZSgpO1xuICAgIH1cblxuICAgIGdldEZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXNfW2ZpbGVuYW1lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlbmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufG9iamVjdH0gVGhlIGluZm8gYWJvdXQgdGhlIGZpbGUsIG9yIGZhbHNlIGlmIGl0IGNvdWxkIG5vdCBiZSBkZWxldGVkXG4gICAgICovXG4gICAgZGVsZXRlRmlsZShmaWxlbmFtZSkge1xuICAgICAgICBpZiAoREVMRVRBQkxFX1NJTVBMRV9GSUxFUy5pbmRleE9mKGZpbGVuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBmaWxlID0gdGhpcy5kZWxldGVGaWxlTG9jYWxseV8oZmlsZW5hbWUpO1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUobnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZpbGVzX1tmaWxlbmFtZV0ub3duZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXJzIGEgY2FsbGJhY2sgdG8gZXZlbnR1YWxseSBjYWxsIGRlbGV0ZUZpbGVMb2NhbGx5X1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5maWxlc19bZmlsZW5hbWVdLm93bmVyLnJlbW92ZShtb2RlbEZpbGUgPT4gbW9kZWxGaWxlLmZpbGVuYW1lID09PSBmaWxlbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQgfHwgZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWxldGVGaWxlTG9jYWxseV8oZmlsZW5hbWUpIHtcbiAgICAgICAgbGV0IGZpbGUgPSB0aGlzLmZpbGVzX1tmaWxlbmFtZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzX1tmaWxlbmFtZV07XG4gICAgICAgIGlmIChmaWxlbmFtZSBpbiB0aGlzLndhdGNoZXNfKSB7XG4gICAgICAgICAgICB0aGlzLndhdGNoZXNfW2ZpbGVuYW1lXS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrLmRlbGV0ZWQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfVxuXG4gICAgbm90aWZ5V2F0Y2hlcyhmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLmZpbGVuYW1lIGluIHRoaXMud2F0Y2hlc18pIHtcbiAgICAgICAgICAgIHRoaXMud2F0Y2hlc19bZmlsZS5maWxlbmFtZV0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjay51cGRhdGVkKGZpbGUpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlYXJjaEZvckZpbGUobmFtZSwgc3R1ZGVudFNlYXJjaCkge1xuICAgICAgICAvKlxuICAgICAgICBUT0RPOiBUaGlzIGlzIGNhbGxlZCBxdWl0ZSBhIGJpdCBieSB0aGUgSW1wb3J0IG1lY2hhbmlzbSwgbWlnaHQgbmVlZFxuICAgICAgICAgICAgICB0byBvcHRpbWl6ZSBpdCBzb21lIG1vcmUuIERvIHRpbWluZyB0ZXN0cy5cblxuICAgICAgICBmaWxlcy4qXG4gICAgICAgIF9pbnN0cnVjdG9yL2ZpbGVzLipcbiAgICAgICAgX3N0dWRlbnQvZmlsZXMuKlxuXG4gICAgICAgIElmIGEgc3R1ZGVudCBzZWFyY2hlcyBmb3IgYSBmaWxlLCBpdCBjaGVja3MgdGhlIFwiP1wiLCBcIiZcIiwgXCIqXCIsIFwiXCIgbmFtZXNwYWNlc1xuICAgICAgICAgICAgaW1wb3J0IGhlbHBlciA9PiBcIi4vaGVscGVyLnB5XCJcbiAgICAgICAgICAgIG9wZW4oXCJleHRlcm5hbC5qc29uXCIpID0+IFwiZXh0ZXJuYWwuanNvblwiXG4gICAgICAgIElmIGFuIGluc3RydWN0b3Igc2VhcmNoZXMgZm9yIGEgZmlsZSwgaXQgY2hlY2tzIFwiIVwiLCBcIl5cIiwgXCI/XCIsIFwiJlwiLCBcIipcIiwgXCJcIiBuYW1lc3BhY2VzXG4gICAgICAgICAgICBUbyBleHBsaWNpdGx5IHNlYXJjaCBpbnN0cnVjdG9yIG5hbWVzcGFjZXMgZmlyc3RcbiAgICAgICAgICAgICAgICBpbXBvcnQgX2luc3RydWN0b3IuaGVscGVyID0+IFwiLi9pbnN0cnVjdG9yL2hlbHBlci5weVwiXG4gICAgICAgICAgICAgICAgb3BlbihcIl9pbnN0cnVjdG9yL2V4dGVybmFsLmpzb25cIikgPT4gXCJfaW5zdHJ1Y3Rvci9leHRlcm5hbC5qc29uXCJcbiAgICAgICAgICAgIHRvIGFsbG93IHN0dWRlbnQgZmlsZXMgdG8gb3ZlcnJpZGU6XG4gICAgICAgICAgICAgICAgaW1wb3J0IGhlbHBlciA9PiBcIi4vaGVscGVyLnB5XCJcbiAgICAgICAgICAgICAgICBvcGVuKFwiZXh0ZXJuYWwuanNvblwiKSA9PiBcImV4dGVybmFsLmpzb25cIlxuICAgICAgICAgICAgdG8gb25seSBjaGVjayBzdHVkZW50IGZpbGVzLCBwcmVwZW5kIHdpdGggX3N0dWRlbnRcbiAgICAgICAgICovXG4gICAgICAgIC8vIENob3Agb2ZmIHN0YXJ0aW5nIFwiLi9cIlxuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiLi9cIikpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWFyY2hNb2RlID0gU2VhcmNoTW9kZXMuRVZFUllXSEVSRTtcbiAgICAgICAgLy8gU2hvdWxkIHRoZSBzZWFyY2ggYmUgc3RhcnQgd2l0aCBpbnN0cnVjdG9yIHNpZGU/XG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoSU5TVFJVQ1RPUl9ESVJFQ1RPUlkpKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZShJTlNUUlVDVE9SX0RJUkVDVE9SWS5sZW5ndGgpO1xuICAgICAgICAgICAgc2VhcmNoTW9kZSA9IFNlYXJjaE1vZGVzLlNUQVJUX1dJVEhfSU5TVFJVQ1RPUjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaG91bGQgdGhlIHNlYXJjaCBiZSBsaW1pdGVkIHRvIHRoZSBzdHVkZW50IG1vZGU/XG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoU1RVREVOVF9ESVJFQ1RPUlkpKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZShTVFVERU5UX0RJUkVDVE9SWS5sZW5ndGgpO1xuICAgICAgICAgICAgc2VhcmNoTW9kZSA9IFNlYXJjaE1vZGVzLk9OTFlfU1RVREVOVF9GSUxFUztcbiAgICAgICAgfSBlbHNlIGlmIChzdHVkZW50U2VhcmNoKSB7XG4gICAgICAgICAgICBzZWFyY2hNb2RlID0gU2VhcmNoTW9kZXMuT05MWV9TVFVERU5UX0ZJTEVTO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBpbnN0cnVjdG9yIHZlcnNpb25zXG4gICAgICAgIGxldCBleHRyYVN0dWRlbnRGaWxlcyA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMoKTtcbiAgICAgICAgbGV0IGV4dHJhSW5zdHJ1Y3RvckZpbGVzID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKTtcbiAgICAgICAgbGV0IGV4dHJhU3RhcnRpbmdGaWxlcyA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcygpO1xuICAgICAgICAvLyBDaGVjayBzcGVjaWFsIGZpbGVzIChUT0RPOiBob3cgd291bGQgYW4gaW5zdHJ1Y3RvciBhY2Nlc3MgXCIuL19pbnN0cnVjdG9yL2Fuc3dlci5weVwiP1xuICAgICAgICBsZXQgc3BlY2lhbEZpbGUgPSB0aGlzLnNlYXJjaEZvclNwZWNpYWxGaWxlc18obmFtZSwgc2VhcmNoTW9kZSk7XG4gICAgICAgIGlmIChzcGVjaWFsRmlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlY2lhbEZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgbG9va2luZyB0aHJvdWdoIHBvc3NpYmxlIGZpbGVzXG4gICAgICAgIGxldCBzdHVkZW50VmVyc2lvbiA9IHRoaXMuc2VhcmNoRm9yRmlsZUluTGlzdF8oZXh0cmFTdHVkZW50RmlsZXMsIG5hbWUpO1xuICAgICAgICBsZXQgZ2VuZXJhdGVkVmVyc2lvbiA9IHRoaXMuc2VhcmNoRm9yRmlsZUluTGlzdF8oZXh0cmFTdHVkZW50RmlsZXMsIFwiKlwiK25hbWUpO1xuICAgICAgICBsZXQgZGVmYXVsdFZlcnNpb24gPSB0aGlzLnNlYXJjaEZvckZpbGVJbkxpc3RfKGV4dHJhSW5zdHJ1Y3RvckZpbGVzLCBcIiZcIituYW1lKTtcbiAgICAgICAgaWYgKHNlYXJjaE1vZGUgPT09IFNlYXJjaE1vZGVzLk9OTFlfU1RVREVOVF9GSUxFUykge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0RGVmaW5lZFZhbHVlKGRlZmF1bHRWZXJzaW9uLCBzdHVkZW50VmVyc2lvbiwgZ2VuZXJhdGVkVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluc3RydWN0b3JWZXJzaW9uID0gdGhpcy5zZWFyY2hGb3JGaWxlSW5MaXN0XyhleHRyYUluc3RydWN0b3JGaWxlcywgXCIhXCIrbmFtZSk7XG4gICAgICAgIGxldCBoaWRkZW5WZXJzaW9uID0gdGhpcy5zZWFyY2hGb3JGaWxlSW5MaXN0XyhleHRyYUluc3RydWN0b3JGaWxlcywgXCI/XCIrbmFtZSk7XG4gICAgICAgIGxldCBzdGFydGluZ1ZlcnNpb24gPSB0aGlzLnNlYXJjaEZvckZpbGVJbkxpc3RfKGV4dHJhU3RhcnRpbmdGaWxlcywgXCJeXCIrbmFtZSk7XG4gICAgICAgIGlmIChzZWFyY2hNb2RlID09PSBTZWFyY2hNb2Rlcy5TVEFSVF9XSVRIX0lOU1RSVUNUT1IpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdERlZmluZWRWYWx1ZShpbnN0cnVjdG9yVmVyc2lvbiwgaGlkZGVuVmVyc2lvbiwgc3RhcnRpbmdWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWZXJzaW9uLCBzdHVkZW50VmVyc2lvbiwgZ2VuZXJhdGVkVmVyc2lvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VhcmNoTW9kZSA9PT0gU2VhcmNoTW9kZXMuRVZFUllXSEVSRSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0RGVmaW5lZFZhbHVlKGRlZmF1bHRWZXJzaW9uLCBzdHVkZW50VmVyc2lvbiwgZ2VuZXJhdGVkVmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdG9yVmVyc2lvbiwgaGlkZGVuVmVyc2lvbiwgc3RhcnRpbmdWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlYXJjaEZvckZpbGVJbkxpc3RfKG1vZGVsTGlzdCwgZmlsZW5hbWUpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbW9kZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobW9kZWxMaXN0W2ldLmZpbGVuYW1lKCkgPT09IGZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsTGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHNlYXJjaEZvclNwZWNpYWxGaWxlc18oZmlsZW5hbWUsIHNlYXJjaE1vZGUpIHtcbiAgICAgICAgaWYgKHNlYXJjaE1vZGUgPT09IFNlYXJjaE1vZGVzLk9OTFlfU1RVREVOVF9GSUxFUykge1xuICAgICAgICAgICAgaWYgKGZpbGVuYW1lID09PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VNb2NrTW9kZWxGaWxlKFwiX2luc3RydWN0b3IvYW5zd2VyLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhbnN3ZXIucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9hbnN3ZXIucHlcIiwgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZSgpKTtcbiAgICAgICAgICAgIGNhc2UgXCJvbl9ydW4ucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9vbl9ydW4ucHlcIiwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKSk7XG4gICAgICAgICAgICBjYXNlIFwib25fY2hhbmdlLnB5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VNb2NrTW9kZWxGaWxlKFwiX2luc3RydWN0b3Ivb25fY2hhbmdlLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlKCkpO1xuICAgICAgICAgICAgY2FzZSBcIm9uX2V2YWwucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9vbl9ldmFsLm1kXCIsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCgpKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdGlvbnMubWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9pbnN0cnVjdGlvbnMubWRcIiwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zKCkpO1xuICAgICAgICAgICAgY2FzZSBcInN0YXJ0aW5nX2NvZGUucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9zdGFydGluZ19jb2RlLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnN0YXJ0aW5nQ29kZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG5ld0ZpbGVEaWFsb2coa2luZCkge1xuICAgICAgICBsZXQgYm9keSA9ICQoTkVXX0lOU1RSVUNUT1JfRklMRV9ESUFMT0dfSFRNTCk7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IGJvZHkuZmluZChcIi5ibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZW5hbWVcIik7XG4gICAgICAgIGxldCBmaWxldHlwZSA9IGJvZHkuZmluZChcIi5ibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZXR5cGVcIik7XG4gICAgICAgIGxldCBuYW1lc3BhY2UgPSBib2R5LmZpbmQoXCIuYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLW5hbWVzcGFjZVwiKTtcbiAgICAgICAgbGV0IGV4dGVuc2lvblJlZ2V4ID0gLyg/OlxcLihbXi5dKykpPyQvO1xuICAgICAgICBmaWxlbmFtZS5vbihcImlucHV0XCIsICgpID0+IHtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb24gPSBleHRlbnNpb25SZWdleC5leGVjKGZpbGVuYW1lLnZhbCgpKVsxXTtcbiAgICAgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbiA9PT0gdW5kZWZpbmVkID8gXCJObyBleHRlbnNpb25cIiA6IGV4dGVuc2lvbjtcbiAgICAgICAgICAgIC8vVE9ETzogdGhpcy5tYWluLmNvbXBvbmVudHMuZWRpdG9ycy5nZXRFZGl0b3JGcm9tRXh0ZW5zaW9uKGV4dGVuc2lvbik7XG4gICAgICAgICAgICBmaWxldHlwZS50ZXh0KGV4dGVuc2lvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgeWVzID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHByZWZpeCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJpbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBuYW1lc3BhY2UudmFsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwic3RhcnRpbmdcIikge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiXlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlsZW5hbWUudmFsKCkpIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IHByZWZpeCtmaWxlbmFtZS52YWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5ld0ZpbGUoZmlsZW5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBib2R5LnN1Ym1pdCgoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgeWVzKCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5jb25maXJtKFwiTWFrZSBOZXcgRmlsZVwiLCBib2R5LCB5ZXMsICgpPT57fSwgXCJBZGRcIik7XG4gICAgfVxufSIsIi8vVE9ETzogTW92ZSBnZXQgbGluayBkb3duIHRvIGZvb3RlciwgcmVtb3ZlIHZlcnRpY2FsIGJhciBmcm9tIHF1aWNrLW1lbnVcbmV4cG9ydCBsZXQgRk9PVEVSX0hUTUwgPSBgXG48ZGl2IGNsYXNzPVwiY29sLW1kLTEyIGJsb2NrcHktcGFuZWwgYmxvY2tweS1zdGF0dXNcIj5cbiAgICA8ZGl2PlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdsb2FkQXNzaWdubWVudCcpXCI+TG9hZCBBc3NpZ25tZW50XG4gICAgICAgICAgICA8IS0tIGtvIGlmOiBkaXNwbGF5Lmluc3RydWN0b3IgLS0+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIlxuICAgICAgICAgICAgY2xhc3M9XCJibG9ja3B5LWZvcmNlLWxvYWQtYXNzaWdubWVudC1maWxlIGJsb2NrcHktaGlkZGVuLWZpbGVcIlxuICAgICAgICAgICAgYWNjZXB0PVwiYXBwbGljYXRpb24vSlNPTlwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJldmVudDoge2NoYW5nZTogdWkuc2VydmVyLmZvcmNlLmxvYWRBc3NpZ25tZW50fVwiPlxuICAgICAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgIDwvbGFiZWw+LCBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdzYXZlQXNzaWdubWVudCcpXCI+U2F2ZSBBc3NpZ25tZW50PC9zcGFuPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygnbG9hZEZpbGUnKVwiPkxvYWQgRmlsZTwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ3NhdmVGaWxlJylcIj5TYXZlIEZpbGU8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdsb2FkRGF0YXNldCcpXCI+TG9hZCBEYXRhc2V0PC9zcGFuPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygnbG9nRXZlbnQnKVwiPkxvZyBFdmVudDwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ3VwZGF0ZVN1Ym1pc3Npb24nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuc2VydmVyLmZvcmNlLnVwZGF0ZVN1Ym1pc3Npb25cIj5VcGRhdGUgU3VibWlzc2lvbjwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ29uRXhlY3V0aW9uJylcIj5FeGVjdXRpb248L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdlxuICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1aS5zZXJ2ZXIubWVzc2FnZXNcIj48L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdj5cbiAgICAgICAgPHNwYW4+VXNlcjogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5pZFwiPjwvc3Bhbj4gKDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVzZXIubmFtZVwiPjwvc3Bhbj4sIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVzZXIucm9sZVwiPjwvc3Bhbj4pPC9zcGFuPiwgXG4gICAgICAgIDxzcGFuPkNvdXJzZTogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5jb3Vyc2VJZFwiPjwvc3Bhbj48L3NwYW4+LFxuICAgICAgICA8c3Bhbj5Hcm91cDogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5ncm91cElkXCI+PC9zcGFuPjwvc3Bhbj4sXG4gICAgICAgIDxzcGFuPkFzc2lnbm1lbnQ6IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IGFzc2lnbm1lbnQuaWRcIj48L3NwYW4+PC9zcGFuPixcbiAgICAgICAgPHNwYW4+QXNzaWdubWVudCBWZXJzaW9uOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBhc3NpZ25tZW50LnZlcnNpb25cIj48L3NwYW4+PC9zcGFuPixcbiAgICAgICAgPHNwYW4+U3VibWlzc2lvbjogXG4gICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdWJtaXNzaW9uLmlkXCI+PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwiaWY6IHN1Ym1pc3Npb24ub3duZXJJZCgpICE9IHVzZXIuaWQoKVwiPlxuICAgICAgICAgICAgICAgIChPd25lciBJRDogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogc3VibWlzc2lvbi5vd25lcklkKClcIj48L3NwYW4+KVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4+U3VibWlzc2lvbiBWZXJzaW9uOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdWJtaXNzaW9uLnZlcnNpb25cIj48L3NwYW4+PC9zcGFuPixcbiAgICAgICAgPHNwYW4+RWRpdG9yIFZlcnNpb246IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IGRpc3BsYXkuZWRpdG9yVmVyc2lvblwiPjwvc3Bhbj48L3NwYW4+XG4gICAgPC9kaXY+XG48L2Rpdj5cbmA7IiwiLy8gVE9ETzogU2hvdWxkIGRpc2FibGUgYnV0dG9ucyBpZiB3ZSBjYW4ndCBhY3RpdmF0ZSB0aGVtLlxuXG5leHBvcnQgY29uc3QgSElTVE9SWV9UT09MQkFSX0hUTUwgPSBgXG48ZGl2IGNsYXNzPVwiYmxvY2tweS1oaXN0b3J5LXRvb2xiYXIgY29sLW1kLTEyXCIgZGF0YS1iaW5kPVwidmlzaWJsZTogZGlzcGxheS5oaXN0b3J5TW9kZVwiPlxuXG4gICAgPGZvcm0gY2xhc3M9XCJmb3JtLWlubGluZVwiPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYmxvY2tweS1oaXN0b3J5LXN0YXJ0IGJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgbXItMlwiIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLmhpc3Rvcnkuc3RhcnRcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtc3RlcC1iYWNrd2FyZCc+PC9zcGFuPiBTdGFydFxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgbXItMlwiIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLmhpc3RvcnkucHJldmlvdXNcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtYmFja3dhcmQnPjwvc3Bhbj4gUHJldmlvdXNcbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxzZWxlY3QgY2xhc3M9XCJibG9ja3B5LWhpc3Rvcnktc2VsZWN0b3IgZm9ybS1jb250cm9sIGN1c3RvbS1zZWxlY3QgbXItMlwiIGFyaWEtdGl0bGU9XCJIaXN0b3J5IFNlbGVjdG9yXCI+XG4gICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBtci0yXCIgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uaGlzdG9yeS51c2VcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZmlsZS1pbXBvcnQnPjwvc3Bhbj4gVXNlXG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBtci0yXCIgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uaGlzdG9yeS5uZXh0XCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWZvcndhcmQnPjwvc3Bhbj4gTmV4dFxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi5oaXN0b3J5Lm1vc3RSZWNlbnRcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtc3RlcC1mb3J3YXJkJz48L3NwYW4+IE1vc3QgUmVjZW50XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIDwvZm9ybT5cbjwvZGl2PlxuYDtcblxuLyoqXG4gKiBBbiBvYmplY3QgZm9yIGRpc3BsYXlpbmcgdGhlIHVzZXIncyBjb2RpbmcgbG9ncyAodGhlaXIgaGlzdG9yeSkuXG4gKiBBIGxpZ2h0d2VpZ2h0IGNvbXBvbmVudCwgaXRzIG9ubHkgam9iIGlzIHRvIG9wZW4gYSBkaWFsb2cuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdGhpcyB7QmxvY2tQeUhpc3Rvcnl9XG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrUHlIaXN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuY3VycmVudElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gW107XG4gICAgICAgIHRoaXMuZWRpdEV2ZW50cyA9IFtdO1xuICAgIH1cblxuICAgIGxvYWQoaGlzdG9yeSkge1xuICAgICAgICB0aGlzLmhpc3RvcnkgPSBoaXN0b3J5O1xuICAgICAgICB0aGlzLmVkaXRFdmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9ICQoXCIuYmxvY2tweS1oaXN0b3J5LXNlbGVjdG9yXCIpLmVtcHR5KCk7XG4gICAgICAgIGxldCBlZGl0SWQgPSAwO1xuICAgICAgICBoaXN0b3J5XG4gICAgICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT4gKFxuICAgICAgICAgICAgICAgICFlbnRyeS5maWxlX3BhdGguc3RhcnRzV2l0aChcIl9pbnN0cnVjdG9yLlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5ldmVudF90eXBlICE9PSBcIkNvbXBpbGVcIiAmJlxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5ldmVudF90eXBlICE9PSBcIkludGVydmVudGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgICghdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKCkgfHwgZW50cnkuZXZlbnRfdHlwZSAhPT0gXCJYLVN1Ym1pc3Npb24uTE1TXCIpXG4gICAgICAgICAgICApKVxuICAgICAgICAgICAgLmZvckVhY2goKGVudHJ5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBldmVudF90eXBlID0gUkVNQVBfRVZFTlRfVFlQRVNbZW50cnkuZXZlbnRfdHlwZV0gfHwgZW50cnkuZXZlbnRfdHlwZTtcbiAgICAgICAgICAgICAgICBsZXQgZGlzcGxheWVkID0gcHJldHR5UHJpbnREYXRlVGltZShlbnRyeS5jbGllbnRfdGltZXN0YW1wKSArXCIgLSBcIitldmVudF90eXBlO1xuICAgICAgICAgICAgICAgIGxldCBkaXNhYmxlID0gKGVudHJ5LmV2ZW50X3R5cGUgIT09IFwiRmlsZS5FZGl0XCIpO1xuICAgICAgICAgICAgICAgIGxldCBvcHRpb24gPSAkKFwiPG9wdGlvbj48L29wdGlvbj5cIiwge3RleHQ6IGRpc3BsYXllZCwgZGlzYWJsZWQ6IGRpc2FibGV9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0VkaXRFdmVudChlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLmF0dHIoXCJ2YWx1ZVwiLCBlZGl0SWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRFdmVudHMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRJZCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yLmFwcGVuZChvcHRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKE1hdGgubWF4KDAsIGVkaXRJZC0xKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IuY2hhbmdlKChldnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vdmVUb1N0YXJ0KCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnZhbCgwKTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IoKTtcbiAgICB9XG5cbiAgICBtb3ZlUHJldmlvdXMoKSB7XG4gICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKE1hdGgubWF4KDAsIGN1cnJlbnRJZC0xKSk7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKCk7XG4gICAgfVxuXG4gICAgbW92ZU5leHQoKSB7XG4gICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKE1hdGgubWluKHRoaXMuZWRpdEV2ZW50cy5sZW5ndGgtMSwgY3VycmVudElkKzEpKTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IoKTtcbiAgICB9XG5cbiAgICBtb3ZlVG9Nb3N0UmVjZW50KCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnZhbCh0aGlzLmVkaXRFdmVudHMubGVuZ3RoLTEpO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcigpO1xuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdEV2ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0uc2V0Q29kZSh0aGlzLmVkaXRFdmVudHNbY3VycmVudElkXS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdEV2ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgICAgICBsZXQgY29kZSA9IHRoaXMuZWRpdEV2ZW50c1tjdXJyZW50SWRdLm1lc3NhZ2U7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwudWkuZWRpdG9ycy5weXRob24udHVybk9mZkhpc3RvcnlNb2RlKCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuZmlsZS5oYW5kbGUoY29kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0VkaXRFdmVudChlbnRyeSkge1xuICAgICAgICByZXR1cm4gKChlbnRyeS5ldmVudF90eXBlID09PSBcIkZpbGUuRWRpdFwiIHx8XG4gICAgICAgICAgICAgICAgIGVudHJ5LmV2ZW50X3R5cGUgPT09IFwiRmlsZS5DcmVhdGVcIikgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5maWxlbmFtZSgpID09PSBlbnRyeS5maWxlX3BhdGgpO1xuICAgIH1cblxufVxuXG5jb25zdCBSRU1BUF9FVkVOVF9UWVBFUyA9IHtcbiAgICBcIlNlc3Npb24uU3RhcnRcIjogXCJCZWdhbiBzZXNzaW9uXCIsXG4gICAgXCJYLUlQLkNoYW5nZVwiOiBcIkNoYW5nZWQgSVAgYWRkcmVzc1wiLFxuICAgIFwiRmlsZS5FZGl0XCI6IFwiRWRpdGVkIGNvZGVcIixcbiAgICBcIkZpbGUuQ3JlYXRlXCI6IFwiU3RhcnRlZCBhc3NpZ25tZW50XCIsXG4gICAgXCJSdW4uUHJvZ3JhbVwiOiBcIlJhbiBwcm9ncmFtXCIsXG4gICAgXCJDb21waWxlLkVycm9yXCI6IFwiU3ludGF4IGVycm9yXCIsXG4gICAgXCJYLVN1Ym1pc3Npb24uTE1TXCI6IFwiVXBkYXRlZCBncmFkZVwiXG59O1xuXG5jb25zdCBtb250aE5hbWVzID0gW1xuICAgIFwiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsXG4gICAgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLFxuICAgIFwiQXVnXCIsIFwiU2VwdFwiLCBcIk9jdFwiLFxuICAgIFwiTm92XCIsIFwiRGVjXCJcbl07XG5jb25zdCB3ZWVrRGF5cyA9IFtcbiAgICBcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLFxuICAgIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsXG4gICAgXCJTYXRcIlxuXTtcblxuZnVuY3Rpb24gaXNTYW1lRGF5KGZpcnN0LCBzZWNvbmQpIHtcbiAgICByZXR1cm4gZmlyc3QuZ2V0RGF0ZSgpID09PSBzZWNvbmQuZ2V0RGF0ZSgpICYmXG4gICAgICAgIGZpcnN0LmdldE1vbnRoKCkgPT09IHNlY29uZC5nZXRNb250aCgpICYmXG4gICAgICAgIGZpcnN0LmdldEZ1bGxZZWFyKCkgPT09IHNlY29uZC5nZXRGdWxsWWVhcigpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBhIGRhdGUvdGltZSBzdHJpbmcgYW5kIHJld3JpdGUgaXQgYXMgc29tZXRoaW5nXG4gKiBtb3JlIGh1bWFuIHJlYWRhYmxlLlxuICogQHBhcmFtIHtTdHJpbmd9IHRpbWVTdHJpbmcgLSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRpbWUgKFwiWVlZWU1NREQgSEhNTVNTXCIpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIEEgaHVtYW4tcmVhZGFibGUgdGltZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHByZXR0eVByaW50RGF0ZVRpbWUodGltZVN0cmluZykge1xuICAgIC8qbGV0IHllYXIgPSB0aW1lU3RyaW5nLnNsaWNlKDAsIDQpLFxuICAgICAgICBtb250aCA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc2xpY2UoNCwgNiksIDEwKS0xLFxuICAgICAgICBkYXkgPSB0aW1lU3RyaW5nLnNsaWNlKDYsIDgpLFxuICAgICAgICBob3VyID0gdGltZVN0cmluZy5zbGljZSg5LCAxMSksXG4gICAgICAgIG1pbnV0ZXMgPSB0aW1lU3RyaW5nLnNsaWNlKDExLCAxMyksXG4gICAgICAgIHNlY29uZHMgPSB0aW1lU3RyaW5nLnNsaWNlKDEzLCAxNSk7Ki9cbiAgICAvLyBUT0RPOiBIYW5kbGUgdGltZXpvbmVzIGNvcnJlY3RseVxuICAgIGlmICh0aW1lU3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFwiVW5kZWZpbmVkIFRpbWVcIjtcbiAgICB9XG4gICAgbGV0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgbGV0IHBhc3QgPSBuZXcgRGF0ZShwYXJzZUludCh0aW1lU3RyaW5nLCAxMCkpO1xuICAgIGlmIChpc1NhbWVEYXkobm93LCBwYXN0KSkge1xuICAgICAgICByZXR1cm4gXCJUb2RheSBhdCBcIitwYXN0LnRvTG9jYWxlVGltZVN0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBkYXlTdHIgPSB3ZWVrRGF5c1twYXN0LmdldERheSgpXTtcbiAgICAgICAgbGV0IG1vbnRoU3RyID0gbW9udGhOYW1lc1twYXN0LmdldE1vbnRoKCldO1xuICAgICAgICBsZXQgZGF0ZSA9IGRheVN0ciArIFwiLCBcIiArIG1vbnRoU3RyICsgXCIgXCIgKyBwYXN0LmdldERhdGUoKTtcbiAgICAgICAgaWYgKG5vdy5nZXRGdWxsWWVhcigpID09PSBwYXN0LmdldEZ1bGxZZWFyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlICsgXCIgYXQgXCIrcGFzdC50b0xvY2FsZVRpbWVTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlICsgXCIsIFwiK3Bhc3QuZ2V0RnVsbFllYXIoKSArIFwiIGF0IFwiK3Bhc3QudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuLyoqXG4gKiBPcGVucyB0aGUgaGlzdG9yeSBkaWFsb2cgYm94LiBUaGlzIHJlcXVpcmVzIGEgdHJpcCB0byB0aGUgc2VydmVyIGFuZFxuICogb2NjdXJzIGFzeW5jaHJvbm91c2x5LiBUaGUgdXNlcnMnIGNvZGUgaXMgc2hvd24gaW4gcHJlZm9ybWF0dGVkIHRleHRcbiAqIHRhZ3MgKG5vIGNvZGUgaGlnaGxpZ2h0aW5nIGN1cnJlbnRseSkgYWxvbmcgd2l0aCB0aGUgdGltZXN0YW1wLlxuICovXG5CbG9ja1B5SGlzdG9yeS5wcm90b3R5cGUub3BlbkRpYWxvZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkaWFsb2cgPSB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2c7XG4gICAgdmFyIGJvZHkgPSBcIjxwcmU+YSA9IDA8L3ByZT5cIjtcbiAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIuZ2V0SGlzdG9yeShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBib2R5ID0gZGF0YS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChjb21wbGV0ZSwgZWxlbSkgeyBcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZV9zdHIgPSBwcmV0dHlQcmludERhdGVUaW1lKGVsZW0udGltZSk7XG4gICAgICAgICAgICB2YXIgbmV3X2xpbmUgPSBcIjxiPlwiK2NvbXBsZXRlX3N0citcIjwvYj48YnI+PHByZT5cIitlbGVtLmNvZGUrXCI8L3ByZT5cIjtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZStcIlxcblwiK25ld19saW5lO1xuICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgZGlhbG9nLnNob3coXCJXb3JrIEhpc3RvcnlcIiwgYm9keSwgZnVuY3Rpb24oKSB7fSk7XG4gICAgfSk7XG59OyIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDb250YWlucyBtYWluIEhUTUwgb2YgQmxvY2tQeSBpbnRlcmZhY2UsIGFuZCBoZWxwZXIgZnVuY3Rpb25zLlxuICogQ29tYmluZXMgYSBsb3Qgb2YgSFRNTCBmcm9tIGNvbXBvbmVudHMuXG4gKlxuICogSGVyZSdzIHRoZSBsYXlvdXQ6XG4gKiAgUm93IDE6IEhlYWRlciBhbmQgUXVpY2sgTWVudVxuICogIFJvdyAyOiBDb25zb2xlIGFuZCBGZWVkYmFja1xuICogIFJvdyAzOiBGaWxlIE5hdmlnYXRpb25cbiAqICBSb3cgNDogVmlldyBSb3dcbiAqICBSb3cgNTogRm9vdGVyIFJvd1xuICovXG5cbmltcG9ydCB7VFJBQ0VfSFRNTH0gZnJvbSBcInRyYWNlLmpzXCI7XG5pbXBvcnQge0RJQUxPR19IVE1MfSBmcm9tIFwiZGlhbG9nLmpzXCI7XG5pbXBvcnQge0ZFRURCQUNLX0hUTUx9IGZyb20gXCJmZWVkYmFjay5qc1wiO1xuaW1wb3J0IHtGSUxFU19IVE1MfSBmcm9tIFwiZmlsZXMuanNcIjtcbmltcG9ydCB7Rk9PVEVSX0hUTUx9IGZyb20gXCJmb290ZXIuanNcIjtcbmltcG9ydCB7RURJVE9SU19IVE1MfSBmcm9tIFwiZWRpdG9ycy5qc1wiO1xuaW1wb3J0IHtDT05TT0xFX0hUTUx9IGZyb20gXCJjb25zb2xlLmpzXCI7XG5cbi8qKlxuICogVGhlIGRpZmZlcmVudCBsYXlvdXQgb3B0aW9ucyBvZiB0aGUgcGFuZXMgaW4gdGhlIHNlY29uZCByb3cgb2YgdGhlIGxheW91dC5cbiAqIEBlbnVtIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBsZXQgU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zID0ge1xuICAgIEZFRURCQUNLOiBcImZlZWRiYWNrXCIsXG4gICAgVFJBQ0U6IFwidHJhY2VcIixcbiAgICBOT05FOiBcIm5vbmVcIlxufTtcblxuLyoqXG4gKiBTZXR1cCBhbnkgYWRkaXRpb25hbCBLbm9ja291dCBzdWJzY3JpcHRpb25zIHRvIGZpcmUgb24gaW50ZXJmYWNlIGNoYW5nZXMuXG4gKiBAcGFyYW0gc2VsZlxuICogQHBhcmFtIG1vZGVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRXh0cmFJbnRlcmZhY2VTdWJzY3JpcHRpb25zKHNlbGYsIG1vZGVsKSB7XG4gICAgLy8gSGlnaGxpZ2h0IE1hcmtkb3duIHdoZW4gaW5zdHJ1Y3Rpb25zIHVwZGF0ZVxuICAgIGxldCBoaWdobGlnaHRUaW1lb3V0ID0gbnVsbDtcbiAgICBtb2RlbC51aS5pbnN0cnVjdGlvbnMuY3VycmVudC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICBpZiAoaGlnaGxpZ2h0VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhpZ2hsaWdodFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGhpZ2hsaWdodFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1pbnN0cnVjdGlvbnMgcHJlIGNvZGVcIikubWFwKCAoaSwgYmxvY2spID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuaGxqcy5oaWdobGlnaHRCbG9jayhibG9jayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgNDAwKTtcbiAgICB9KTtcbiAgICAvLyBQcm92aWRlIEZ1bGxzY3JlZW4gc3VwcG9ydFxuICAgIG1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbi5zdWJzY3JpYmUoKGlzRnVsbHNjcmVlbikgPT4ge1xuICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1EaXNwbGF5LkZ1bGxzY3JlZW4uUmVxdWVzdFwiLCBcIlwiLCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVsbHNjcmVlbi50b1N0cmluZygpLCBcIlwiKTtcbiAgICAgICAgaWYgKGlzRnVsbHNjcmVlbikge1xuICAgICAgICAgICAgLy8gTk9URTogbmF2aWdhdGlvblVJIGNvdWxkIGFsbG93IHVzIHRvIGZvcmNlIGNvbnRyb2xzIHRvIHNob3dcbiAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyLnBhcmVudCgpWzBdLnJlcXVlc3RGdWxsc2NyZWVuKCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGBFcnJvciBhdHRlbXB0aW5nIHRvIGVuYWJsZSBmdWxsLXNjcmVlbiBtb2RlOiAke2Vyci5tZXNzYWdlfSAoJHtlcnIubmFtZX0pYDtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1EaXNwbGF5LkZ1bGxzY3JlZW4uRXJyb3JcIiwgXCJcIiwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsICBcIlwiKTtcbiAgICAgICAgICAgICAgICBhbGVydChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLURpc3BsYXkuRnVsbHNjcmVlbi5TdWNjZXNzXCIsIFwiXCIsIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIuY3NzKFwib3ZlcmZsb3cteVwiLCBcImF1dG9cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRGlzcGxheS5GdWxsc2NyZWVuLkV4aXRcIiwgXCJcIiwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVsbHNjcmVlbi50b1N0cmluZygpLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4oZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLy8gVE9ETzogR2V0IHNoYXJlYWJsZSBsaW5rIGJ1dHRvblxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUludGVyZmFjZShtYWluKSB7XG4gICAgcmV0dXJuIGBcbjxkaXYgY2xhc3M9J2Jsb2NrcHktY29udGVudCBjb250YWluZXItZmx1aWQnPlxuXG4gICAgPCEtLSBEaWFsb2cgLS0+XG4gICAgJHtESUFMT0dfSFRNTH1cbiAgICBcbiAgICA8IS0tIEhpZGRlbiBDYXB0dXJlIENhbnZhcyAtLT5cbiAgICA8Y2FudmFzIGlkPSdjYXB0dXJlLWNhbnZhcycgY2xhc3M9J2Qtbm9uZScgcm9sZT1cInByZXNlbnRhdGlvblwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2FudmFzPlxuICAgIFxuICAgIDwhLS0gUm93IDE6IEhlYWRlciBhbmQgUXVpY2sgTWVudSAtLT5cbiAgICA8ZGl2IGNsYXNzPSdyb3cnPlxuICAgICAgICAgXG4gICAgICAgICA8IS0tIERlc2NyaXB0aW9uIC0tPlxuICAgICAgICAgPGRpdiBjbGFzcz0nY29sLW1kLTEwIGJsb2NrcHktcGFuZWwgYmxvY2tweS1oZWFkZXInXG4gICAgICAgICAgICAgICByb2xlPSdoZWFkaW5nJyBhcmlhLWxhYmVsPSdBc3NpZ25tZW50IERlc2NyaXB0aW9uJz5cbiAgICAgICAgIFxuICAgICAgICAgICAgPCEtLSBBc3NpZ25tZW50IE5hbWUgLS0+XG4gICAgICAgICAgICA8c3BhbiByb2xlPSdoZWFkaW5nJyBhcmlhLWxldmVsPScxJ1xuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJibG9ja3B5LW5hbWVcIj5cbiAgICAgICAgICAgICAgICA8c3Ryb25nPkJsb2NrUHk6IDwvc3Ryb25nPiBcbiAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9J3RleHQ6IGFzc2lnbm1lbnQubmFtZSc+PC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8IS0tIFJlc2V0IEluc3RydWN0aW9ucyBCdXR0b24gLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS1pbnN0cnVjdGlvbnMtcmVzZXRcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmluc3RydWN0aW9ucy5pc0NoYW5nZWRcIj5cbiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cImZsb2F0LXJpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmluc3RydWN0aW9ucy5yZXNldFwiXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCJcIj5cbiAgICAgICAgICAgICAgICAgICAgUmVzZXQgaW5zdHJ1Y3Rpb25zPC9hPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDwhLS0gSW5zdHJ1Y3Rpb25zIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz0nYmxvY2tweS1pbnN0cnVjdGlvbnMnXG4gICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImh0bWw6IHVpLmluc3RydWN0aW9ucy5jdXJyZW50XCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPSdjb2wtbWQtMiBibG9ja3B5LXBhbmVsIGJsb2NrcHktcXVpY2stbWVudSdcbiAgICAgICAgICAgICByb2xlPSdtZW51YmFyJyBhcmlhLWxhYmVsPSdRdWljayBNZW51JyB0aXRsZT1cIlF1aWNrIE1lbnVcIj5cbiAgICAgICAgICAgIDwhLS0gR2V0IFNoYXJlYWJsZSBMaW5rIC0tPlxuICAgICAgICAgICAgPCEtLTxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGJ0bi1zbVwiPlxuICAgICAgICAgICAgICAgIEdldCBzaGFyZWFibGUgbGluazwvYnV0dG9uPi0tPlxuICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwidmlzaWJsZTogdWkubWVudS5pc1N1Ym1pdHRlZFwiPlxuICAgICAgICAgICAgICAgIFlvdXIgc3VibWlzc2lvbiBpcyByZWFkeSB0byBiZSByZXZpZXdlZCE8L3NwYW4+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tc21cIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLm1lbnUuY2FuTWFya1N1Ym1pdHRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHVpLm1lbnUudGV4dE1hcmtTdWJtaXR0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkubWVudS5jbGlja01hcmtTdWJtaXR0ZWRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgIDwhLS0gVmlldyBhcyBpbnN0cnVjdG9yIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIlxuICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5yb2xlLmlzR3JhZGVyXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwiXCIgaWQ9XCJibG9ja3B5LWFzLWluc3RydWN0b3JcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBkaXNwbGF5Lmluc3RydWN0b3JcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1hcy1pbnN0cnVjdG9yXCI+XG4gICAgICAgICAgICAgICAgICAgIFZpZXcgYXMgaW5zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwhLS0gUmVhZG9ubHkgbW9kZSBmb3Igc3B5aW5nIC0tPlxuICAgICAgICAgICAgPGRpdiBkYXRhLWJpbmQ9XCJpZjogc3VibWlzc2lvbi5vd25lcklkKCkgIT0gdXNlci5pZCgpXCI+XG4gICAgICAgICAgICAgICAgT3duZXI6IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHN1Ym1pc3Npb24ub3duZXJJZFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCIgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJibG9ja3B5LXJlYWQtb25seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBkaXNwbGF5LnJlYWRPbmx5XCI+XG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXJlYWQtb25seVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZG9ubHk/XG4gICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tc21cIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5tZW51LmNsaWNrRnVsbHNjcmVlblwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJGdWxsIFNjcmVlblwiXG4gICAgICAgICAgICA+PHNwYW4gY2xhc3M9J2ZhcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGFzczogdWkubWVudS50ZXh0RnVsbHNjcmVlblwiXG4gICAgICAgICAgICA+PC9zcGFuPjwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLXNtXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkubWVudS5lZGl0SW5wdXRzLCB2aXNpYmxlOiB1aS5tZW51LnNob3dRdWV1ZWRJbnB1dHNcIiB0aXRsZT1cIkVkaXQgSW5wdXRzXCJcbiAgICAgICAgICAgID48c3BhbiBjbGFzcz0nZmFzIGZhLWxpc3QtYWx0Jz48L3NwYW4+PC9idXR0b24+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImJsb2NrcHktc3R1ZGVudC1lcnJvciBmYXMgZmEtYnVnXCI+PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgIDwvZGl2PlxuICAgIFxuICAgIDwhLS0gUm93IDI6IENvbnNvbGUgYW5kIEZlZWRiYWNrIC0tPlxuICAgIDwhLS0ga28gaWY6IHVpLnNlY29uZFJvdy5pc0FsbFZpc2libGUgLS0+XG4gICAgPGRpdiBjbGFzcz0ncm93Jz5cbiAgICBcbiAgICAgICAgPCEtLSBDb25zb2xlIC0tPlxuICAgICAgICAke0NPTlNPTEVfSFRNTH1cbiAgICAgICAgIFxuICAgICAgICA8IS0tIEZlZWRiYWNrIC0tPlxuICAgICAgICA8IS0tIGtvIGlmOiB1aS5zZWNvbmRSb3cuaXNGZWVkYmFja1Zpc2libGUgLS0+XG4gICAgICAgICR7RkVFREJBQ0tfSFRNTH1cbiAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgIFxuICAgICAgICA8IS0tIFRyYWNlIC0tPlxuICAgICAgICA8IS0tIGtvIGlmOiB1aS5zZWNvbmRSb3cuaXNUcmFjZVZpc2libGUgLS0+XG4gICAgICAgICR7VFJBQ0VfSFRNTH1cbiAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgICBcbiAgICA8L2Rpdj5cbiAgICA8IS0tIC9rbyAtLT5cbiAgICBcbiAgICA8IS0tIFJvdyAzOiBGaWxlIE5hdmlnYXRpb24gLS0+XG4gICAgPCEtLSBrbyBpZjogdWkuZmlsZXMudmlzaWJsZSAtLT5cbiAgICA8ZGl2IGNsYXNzPSdyb3cnPlxuICAgICAgICAke0ZJTEVTX0hUTUx9XG4gICAgPC9kaXY+XG4gICAgPCEtLSAva28gLS0+XG4gICAgXG4gICAgPCEtLSBSb3cgNDogVmlldyBSb3cgLS0+XG4gICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAke0VESVRPUlNfSFRNTH1cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gUm93IDU6IEZvb3RlciBSb3cgLS0+ICAgIFxuICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgJHtGT09URVJfSFRNTH1cbiAgICA8L2Rpdj5cbiAgICBcbjwvZGl2PlxuICAgIGA7XG59IiwiaW1wb3J0IHtMb2NhbFN0b3JhZ2VXcmFwcGVyfSBmcm9tIFwiLi9zdG9yYWdlXCI7XG5pbXBvcnQge2xvYWRBc3NpZ25tZW50U2V0dGluZ3MsIHNhdmVBc3NpZ25tZW50U2V0dGluZ3N9IGZyb20gXCIuL2VkaXRvci9hc3NpZ25tZW50X3NldHRpbmdzXCI7XG5cbi8qKlxuICpcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBsZXQgU3RhdHVzU3RhdGUgPSB7XG4gICAgUkVBRFk6IFwicmVhZHlcIixcbiAgICBBQ1RJVkU6IFwiYWN0aXZlXCIsXG4gICAgUkVUUllJTkc6IFwicmV0cnlpbmdcIixcbiAgICBGQUlMRUQ6IFwiZmFpbGVkXCIsXG4gICAgT0ZGTElORTogXCJvZmZsaW5lXCJcbn07XG5cbi8qKlxuICogT2JqZWN0IGZvciBjb21tdW5pY2F0aW5nIHdpdGggdGhlIGV4dGVybmFsIHNlcnZlcnMuIFRoaXMgaW5jbHVkZXMgZnVuY3Rpb25hbGl0eSBmb3JcbiAqIHNhdmluZyBhbmQgbG9hZGluZyBmaWxlcywgbG9nZ2luZyBldmVudHMsIHNhdmluZyBjb21wbGV0aW9ucywgYW5kIHJldHJpZXZpbmcgaGlzdG9yeS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtCbG9ja1B5U2VydmVyfVxuICogQHBhcmFtIHtPYmplY3R9IG1haW4gLSBUaGUgbWFpbiBCbG9ja1B5IGluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBCbG9ja1B5U2VydmVyKG1haW4pIHtcbiAgICB0aGlzLm1haW4gPSBtYWluO1xuXG4gICAgLy8gU2F2ZSBVUkxzIGxvY2FsbHkgZm9yIHF1aWNrZXIgYWNjZXNzXG4gICAgdGhpcy51cmxzID0gbWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnVybHM7XG5cbiAgICAvLyBBZGQgdGhlIExvY2FsU3RvcmFnZSBjb25uZWN0aW9uXG4gICAgdGhpcy5zdG9yYWdlID0gbmV3IExvY2FsU3RvcmFnZVdyYXBwZXIoXCJCTE9DS1BZXCIpO1xuXG4gICAgLy8gRmF1bHRSZXNpc3RhbnRDYWNoZVxuICAgIHRoaXMucXVldWUgPSB7XG4gICAgICAgIFwibG9nRXZlbnRcIjogSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0RGVmYXVsdChcImxvZ0V2ZW50XCIsIFwiW11cIikpLFxuICAgICAgICBcInVwZGF0ZVN1Ym1pc3Npb25cIjogSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0RGVmYXVsdChcInVwZGF0ZVN1Ym1pc3Npb25cIiwgXCJbXVwiKSlcbiAgICB9O1xuICAgIHRoaXMuTUFYX1FVRVVFX1NJWkUgPSB7XG4gICAgICAgIFwibG9nRXZlbnRcIjogMjAwLFxuICAgICAgICBcInVwZGF0ZVN1Ym1pc3Npb25cIjogNTBcbiAgICB9O1xuXG4gICAgdGhpcy5USU1FUl9ERUxBWSA9IDEwMDA7XG4gICAgdGhpcy5GQUlMX0RFTEFZID0gMjAwMDtcblxuICAgIHRoaXMudGltZXJzID0ge307XG5cbiAgICB0aGlzLm92ZXJsYXkgPSBudWxsO1xuICAgIHRoaXMuYmxvY2tpbmdBdHRlbXB0cyA9IDA7XG5cbiAgICB0aGlzLmNhY2hlZEZpbGVuYW1lcyA9IFtdO1xuICAgIHRoaXMuY3JlYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgIHRoaXMuY2hlY2tDYWNoZXMoKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgSVAgYWRkcmVzcyBoYXMgY2hhbmdlZCwgbG9nZ2luZyBhbiBldmVudCBpZiB0aGF0IG9jY3Vycy5cbiAqIEBwYXJhbSByZXNwb25zZVxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jaGVja0lQID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5oYXMoXCJJUFwiKSkge1xuICAgICAgICAgICAgbGV0IG9sZElQID0gdGhpcy5zdG9yYWdlLmdldChcIklQXCIpO1xuICAgICAgICAgICAgaWYgKG9sZElQICE9PSByZXNwb25zZS5pcCkge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBcIm9sZFwiOiBvbGRJUCxcbiAgICAgICAgICAgICAgICAgICAgXCJuZXdcIjogcmVzcG9uc2UuaXBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ0V2ZW50KFwiWC1JUC5DaGFuZ2VcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoXCJJUFwiLCByZXNwb25zZS5pcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KFwiSVBcIiwgcmVzcG9uc2UuaXApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZXJlIGhhdmUgYmVlbiBwcmV2aW91cyBmYWlsdXJlcyBjYWNoZWQsIGFuZCBpZiBzbyByZXRyaWVzIHRoZW0uXG4gKiBUT0RPOiB1cGRhdGVcbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuY2hlY2tDYWNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc3RvcmFnZS5oYXMoXCJzYXZlQXNzaWdubWVudFwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldChcInNhdmVBc3NpZ25tZW50XCIpKTtcbiAgICAgICAgdGhpcy5fcG9zdExhdGVzdFJldHJ5KGRhdGEsIFwiYXNzaWdubWVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzYXZlQXNzaWdubWVudFwiLCB0aGlzLlRJTUVSX0RFTEFZKTtcbiAgICB9XG4gICAgdGhpcy5jYWNoZWRGaWxlbmFtZXMuZm9yRWFjaCgoZmlsZW5hbWUpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5oYXMoXCJzYXZlRmlsZVwiICsgZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldChcInNhdmVGaWxlXCIgKyBmaWxlbmFtZSkpO1xuICAgICAgICAgICAgdGhpcy5fcG9zdExhdGVzdFJldHJ5KGRhdGEsIGZpbGVuYW1lLCBcInNhdmVGaWxlXCIsIHRoaXMuVElNRVJfREVMQVkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHNlcnZlciA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXModGhpcy5xdWV1ZSkuZm9yRWFjaChmdW5jdGlvbiAoZW5kcG9pbnQpIHtcbiAgICAgICAgKGZ1bmN0aW9uIHB1c2hBbnlRdWV1ZWQocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlci5xdWV1ZVtlbmRwb2ludF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShzZXJ2ZXIucXVldWVbZW5kcG9pbnRdLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IHNlcnZlci51cmxzW2VuZHBvaW50XTtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLl9wb3N0UmV0cnkoZGF0YSwgZW5kcG9pbnQsIDEwMDAsIHB1c2hBbnlRdWV1ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoe1wic3VjY2Vzc1wiOiB0cnVlfSk7XG4gICAgfSk7XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKG1vZGVsLCBmaWxlbmFtZSkge1xuICAgIG1vZGVsLnN1YnNjcmliZSgoY29udGVudHMpID0+XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmF1dG9TYXZlKCkgPyB0aGlzLnNhdmVGaWxlKGZpbGVuYW1lLCBjb250ZW50cykgOiBmYWxzZSwgdGhpcyk7XG4gICAgdGhpcy5jYWNoZWRGaWxlbmFtZXMucHVzaChmaWxlbmFtZSk7XG59O1xuXG4vKipcbiAqIFRPRE86IGZpeFxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jcmVhdGVTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwuc3VibWlzc2lvbi5jb2RlLCBcImFuc3dlci5weVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwuYXNzaWdubWVudC5vblJ1biwgXCIhb25fcnVuLnB5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCwgXCIhb25fZXZhbC5weVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZSwgXCIhb25fY2hhbmdlLnB5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC5hc3NpZ25tZW50Lmluc3RydWN0aW9ucywgXCIhaW5zdHJ1Y3Rpb25zLm1kXCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC5hc3NpZ25tZW50LnN0YXJ0aW5nQ29kZSwgXCJec3RhcnRpbmdfY29kZS5weVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwudWkuZmlsZXMuZXh0cmFTdHVkZW50RmlsZXMsIFwiI2V4dHJhX3N0dWRlbnRfZmlsZXMuYmxvY2tweVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwudWkuZmlsZXMuZXh0cmFTdGFydGluZ0ZpbGVzLCBcIiNleHRyYV9zdGFydGluZ19maWxlcy5ibG9ja3B5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC51aS5maWxlcy5leHRyYUluc3RydWN0b3JGaWxlcywgXCIjZXh0cmFfaW5zdHJ1Y3Rvcl9maWxlcy5ibG9ja3B5XCIpO1xufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuY3JlYXRlRXZlbnRMb2dzID0gZnVuY3Rpb24oKSB7XG4gICAgd2luZG93Lm9uYmx1ciA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5sb2dFdmVudChcIlNlc3Npb24uRW5kXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIH07XG4gICAgd2luZG93Lm9uZm9jdXMgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nRXZlbnQoXCJTZXNzaW9uLlN0YXJ0XCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBBZGQgaW4gYmVhY29uP1xufTtcblxuLyoqXG4gKlxuICogU29tZSBzdWJzY3JpcHRpb25zIGhhdmUgdG8gaGFwcGVuIGFmdGVyIG90aGVyIHRoaW5ncyBoYXZlIGJlZW4gbG9hZGVkLlxuICogUmlnaHQgbm93IHRoaXMgaXMganVzdCBhZnRlciBDT1JHSVMgbGlicmFyaWVzIGhhdmUgYmVlbiBsb2FkZWQsIGJ1dCBtYXliZVxuICogd2UnbGwgYWRkIG1vcmUgbGF0ZXIgYW5kIHRoaXMgd2lsbCBuZWVkIHRvIGJlIHJlZmFjdG9yZWQuXG4gKlxuICogVE9ETzogZml4XG4gKlxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5maW5hbGl6ZVN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy90aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kYXRhc2V0cy5zdWJzY3JpYmUodGhpcy5zYXZlQXNzaWdubWVudC5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgZGVmYXVsdCBwYXlsb2FkIGZvciBhbnkgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBzZXJ2ZXIgQVBJXG4gKiBAcmV0dXJucyB7e2Fzc2lnbm1lbnRfaWQ6ICosIGNvdXJzZV9pZDogKiwgZ3JvdXBfaWQ6ICosIHVzZXJfaWQ6ICosIHRpbWV6b25lOiAqLCB2ZXJzaW9uOiAqLCB0aW1lc3RhbXA6ICp9fVxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jcmVhdGVTZXJ2ZXJEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBhc3NpZ25tZW50ID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQ7XG4gICAgbGV0IHVzZXIgPSB0aGlzLm1haW4ubW9kZWwudXNlcjtcbiAgICBsZXQgc3VibWlzc2lvbiA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uO1xuICAgIGxldCBkaXNwbGF5ID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXk7XG4gICAgbGV0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgbGV0IG1pY3Jvc2Vjb25kcyA9IG5vdy5nZXRUaW1lKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJhc3NpZ25tZW50X2lkXCI6IGFzc2lnbm1lbnQuaWQoKSxcbiAgICAgICAgXCJhc3NpZ25tZW50X2dyb3VwX2lkXCI6IHVzZXIuZ3JvdXBJZCgpLFxuICAgICAgICBcImNvdXJzZV9pZFwiOiB1c2VyLmNvdXJzZUlkKCksXG4gICAgICAgIFwic3VibWlzc2lvbl9pZFwiOiBzdWJtaXNzaW9uLmlkKCksXG4gICAgICAgIFwidXNlcl9pZFwiOiB1c2VyLmlkKCksXG4gICAgICAgIFwidmVyc2lvblwiOiBhc3NpZ25tZW50LnZlcnNpb24oKSxcbiAgICAgICAgXCJ0aW1lc3RhbXBcIjogbWljcm9zZWNvbmRzLFxuICAgICAgICBcInRpbWV6b25lXCI6IG5vdy5nZXRUaW1lem9uZU9mZnNldCgpLFxuICAgICAgICBcInBhc3Njb2RlXCI6IGRpc3BsYXkucGFzc2NvZGUoKVxuICAgIH07XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHN0YXR1cyBhbmQgbWVzc2FnZSBmb3IgdGhlIHJlbGV2YW50IGVuZHBvaW50LlxuICogQHBhcmFtIGVuZHBvaW50IHtzdHJpbmd9IG9uZSBvZiB0aGUgVVJMIGVuZHBvaW50c1xuICogQHBhcmFtIHN0YXR1cyB7U3RhdHVzU3RhdGV9XG4gKiBAcGFyYW0gbWVzc2FnZSB7c3RyaW5nP31cbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuc2V0U3RhdHVzID0gZnVuY3Rpb24gKGVuZHBvaW50LCBzdGF0dXMsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzW2VuZHBvaW50XShzdGF0dXMpO1xuICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXNbZW5kcG9pbnQgKyBcIk1lc3NhZ2VcIl0obWVzc2FnZSB8fCBcIlwiKTtcbn07XG5cbi8qKlxuICogUmVuZGVycyBhbiBvdmVybGF5IG9uIHRoZSBzY3JlZW4gdGhhdCBibG9ja3Mgb3BlcmF0aW9uIHVudGlsIHRoZSBzeXN0ZW0gaXMgcmVhZHkuXG4gKiBUaGUgb3ZlcmxheSBnZXRzIHByb2dyZXNzaXZlbHkgZGFya2VyIHRvIGluZGljYXRlIHJlcGVhdGVkIGZhaWx1cmVzLlxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5zaG93T3ZlcmxheSA9IGZ1bmN0aW9uIChhdHRlbXB0KSB7XG4gICAgdGhpcy5ibG9ja2luZ0F0dGVtcHRzICs9IDE7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiYmxvY2tweS1vdmVybGF5XCIpLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSAkKCc8ZGl2IGNsYXNzPVwiYmxvY2tweS1vdmVybGF5XCI+IDwvZGl2PicpO1xuICAgICAgICB0aGlzLm92ZXJsYXkuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XG4gICAgfVxuICAgIHN3aXRjaCAoYXR0ZW1wdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiM5ODhcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5vdmVybGF5LmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCIjNjU1XCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheS5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiIzMzM1wiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5vdmVybGF5LmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCJibGFja1wiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbi8qKlxuICogVW5kbyBhIGxldmVsIG9mIG92ZXJsYXk7IGlmIHRoaXMgd2FzIHRoZSBsYXN0IGxldmVsLCByZW1vdmVzIGl0IGZyb20gdGhlIHNjcmVlbi5cbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuaGlkZU92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ibG9ja2luZ0F0dGVtcHRzIC09IDE7XG4gICAgaWYgKHRoaXMuYmxvY2tpbmdBdHRlbXB0cyA8PSAwKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheS5yZW1vdmUoKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fZW5xdWV1ZURhdGEgPSBmdW5jdGlvbiAoY2FjaGUsIGRhdGEpIHtcbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBub3Qgb3ZlcmZpbGxlZCB0aGUgcXVldWVcbiAgICBsZXQgbGVuZ3RoID0gdGhpcy5xdWV1ZVtjYWNoZV0ubGVuZ3RoO1xuICAgIGxldCBtYXggPSB0aGlzLk1BWF9RVUVVRV9TSVpFW2NhY2hlXTtcbiAgICBpZiAobGVuZ3RoID4gbWF4KSB7XG4gICAgICAgIHRoaXMucXVldWVbY2FjaGVdID0gdGhpcy5xdWV1ZVtjYWNoZV0uc2xpY2UobGVuZ3RoIC0gbWF4LCBtYXgpO1xuICAgIH1cbiAgICAvLyBPbmx5IGFkZCB0aGUgZWxlbWVudCBpZiBpdCdzIG5ld1xuICAgIGxldCBrZXkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICBsZXQgaW5kZXggPSB0aGlzLnF1ZXVlW2NhY2hlXS5pbmRleE9mKGtleSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aGlzLnF1ZXVlW2NhY2hlXS5wdXNoKGtleSk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoY2FjaGUsIEpTT04uc3RyaW5naWZ5KHRoaXMucXVldWVbY2FjaGVdKSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuX2RlcXVldWVEYXRhID0gZnVuY3Rpb24gKGNhY2hlLCBkYXRhKSB7XG4gICAgbGV0IGtleSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIGxldCBpbmRleCA9IHRoaXMucXVldWVbY2FjaGVdLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB0aGlzLnF1ZXVlW2NhY2hlXS5zcGxpY2UoaW5kZXgpO1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KGNhY2hlLCBKU09OLnN0cmluZ2lmeSh0aGlzLnF1ZXVlW2NhY2hlXSkpO1xuICAgIH1cbn07XG5cblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuX3Bvc3RSZXRyeSA9IGZ1bmN0aW9uIChkYXRhLCBlbmRwb2ludCwgZGVsYXksIGNhbGxiYWNrKSB7XG4gICAgLy8gVHJpZ2dlciByZXF1ZXN0XG4gICAgbGV0IHBvc3RSZXF1ZXN0ID0gKCkgPT4ge1xuICAgICAgICAvLyBNYWtlIGEgYmFja3VwIG9mIHRoZSBjdXJyZW50IHBvc3RcbiAgICAgICAgdGhpcy5fZW5xdWV1ZURhdGEoZW5kcG9pbnQsIGRhdGEpO1xuICAgICAgICAkLnBvc3QodGhpcy51cmxzW2VuZHBvaW50XSwgZGF0YSlcbiAgICAgICAgICAgIC5kb25lKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlcXVldWVEYXRhKGVuZHBvaW50LCBkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuRkFJTEVELCByZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0lQKHJlc3BvbnNlLmlwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy8gSWYgc2VydmVyIHJlcXVlc3QgaXMgdGhlIGxhdGVzdCBvbmUsIHRoZW4gbGV0J3MgdHJ5IGl0IGFnYWluIGluIGEgYml0XG4gICAgICAgICAgICAuZmFpbCgoZXJyb3IsIHRleHRTdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVUUllJTkcsIHRleHRTdGF0dXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zdFJldHJ5KGRhdGEsIGVuZHBvaW50LCBkZWxheSArIHRoaXMuRkFJTF9ERUxBWSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoZGVsYXkgPT09IG51bGwpIHtcbiAgICAgICAgcG9zdFJlcXVlc3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KHBvc3RSZXF1ZXN0LCBkZWxheSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNYWtlIGEgQUpBWCByZXF1ZXN0IHRoYXQsIHVwb24gZmFpbHVyZSwgd2lsbCBjaGVjayB0byBzZWUgaWYgdGhpcyB3YXMgdGhlXG4gKiBsYXRlc3QgYXR0ZW1wdCBmb3IgdGhpcyBgY2FjaGVgIG1hcmtlci4gSWYgc28sIGl0IHdpbGwgYXR0ZW1wdCBhZ2FpbiB1bnRpbFxuICogc3VjY2Vzc2Z1bDsgb3RoZXJ3aXNlLCBpdCBnaXZlcyB1cCB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBBSkFYLXJlYWR5IGRhdGEgdG8gYmUgcG9zdGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWUgLSBUaGUgdW5pcXVlIG5hbWUgZ2l2ZW4gdG8gdGhlIHJlbGV2YW50IHRpbWVyXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcG9pbnQgLSBUaGUgdW5pcXVlIG5hbWUgZ2l2ZW4gdG8gdGhlIHJlbGV2YW50IGNhY2hlIGVudHJ5XG4gKiBAcGFyYW0ge0ludGVnZXJ9IGRlbGF5IC0gVGhlIGN1cnJlbnQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZVxuIHRyeWluZyB0aGUgcmVxdWVzdCBhZ2Fpbi5cbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuX3Bvc3RMYXRlc3RSZXRyeSA9IGZ1bmN0aW9uIChkYXRhLCBmaWxlbmFtZSwgZW5kcG9pbnQsIGRlbGF5KSB7XG4gICAgbGV0IGNhY2hlID0gZW5kcG9pbnQgKyBmaWxlbmFtZTtcbiAgICBsZXQgcmVxdWVzdCA9ICgpID0+IHtcbiAgICAgICAgLy8gTWFrZSBhIGJhY2t1cCBvZiB0aGUgY3VycmVudCBwb3N0XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoY2FjaGUsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgbGV0IHRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICAgICAgJC5wb3N0KHRoaXMudXJsc1tlbmRwb2ludF0sIGRhdGEpXG4gICAgICAgICAgICAuZG9uZSgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrSVAocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZXJ2ZXIgcmVxdWVzdCBpcyB0aGUgbGF0ZXN0IG9uZSwgY2xlYXIgaXQgZnJvbSB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNhY2hlZFRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGNhY2hlZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUoY2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjb25uZWN0ZWQgYnV0IGZhaWxlZCwgZG9uJ3QgdHJ5IGFnYWluIGJ1dCBsZXQgdGhlIHVzZXIga25vdyB3aHkuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIHRoZSBsYXRlc3Qgb25lLCBjbGVhciBpdCBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhY2hlZFRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBjYWNoZWRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnJlbW92ZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZhaWwoKGVycm9yLCB0ZXh0U3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoZW5kcG9pbnQsIFN0YXR1c1N0YXRlLlJFVFJZSU5HLCB0ZXh0U3RhdHVzLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIC8vIElmIHNlcnZlciByZXF1ZXN0IGlzIHRoZSBsYXRlc3Qgb25lLCB0aGVuIGxldCdzIHRyeSBpdCBhZ2FpbiBpbiBhIGJpdFxuICAgICAgICAgICAgICAgIGxldCBjYWNoZWRUaW1lID0gdGhpcy5zdG9yYWdlLmdldFRpbWUoY2FjaGUpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGNhY2hlZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9zdExhdGVzdFJldHJ5KGRhdGEsIGZpbGVuYW1lLCBlbmRwb2ludCwgZGVsYXkgKyB0aGlzLkZBSUxfREVMQVkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH07XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzW2NhY2hlXSk7XG4gICAgaWYgKGRlbGF5ID09PSBudWxsKSB7XG4gICAgICAgIHJlcXVlc3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRpbWVyc1tjYWNoZV0gPSBzZXRUaW1lb3V0KHJlcXVlc3QsIGRlbGF5KTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fcG9zdEJsb2NraW5nID0gZnVuY3Rpb24gKGVuZHBvaW50LCBkYXRhLCBhdHRlbXB0cywgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgIHRoaXMuc2hvd092ZXJsYXkoYXR0ZW1wdHMpO1xuICAgICQucG9zdCh0aGlzLnVybHNbZW5kcG9pbnRdLCBkYXRhKVxuICAgICAgICAuZG9uZSgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGlkZU92ZXJsYXkoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICBzdWNjZXNzKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tJUChyZXNwb25zZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5mYWlsKChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAgICAgaWYgKGF0dGVtcHRzIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoZW5kcG9pbnQsIFN0YXR1c1N0YXRlLkZBSUxFRCwgdGV4dFN0YXR1cy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRVRSWUlORywgdGV4dFN0YXR1cy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9zdEJsb2NraW5nKGVuZHBvaW50LCBkYXRhLCBhdHRlbXB0cyAtIDEsIHN1Y2Nlc3MsIGZhaWx1cmUpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMuRkFJTF9ERUxBWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xufTtcblxuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5sb2FkQXNzaWdubWVudCA9IGZ1bmN0aW9uIChhc3NpZ25tZW50X2lkKSB7XG4gICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIGlmIChtb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImxvYWRBc3NpZ25tZW50XCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJhc3NpZ25tZW50X2lkXCJdID0gYXNzaWdubWVudF9pZDtcbiAgICAgICAgdGhpcy5fcG9zdEJsb2NraW5nKFwibG9hZEFzc2lnbm1lbnRcIiwgZGF0YSwgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5sb2FkQXNzaWdubWVudERhdGFfKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcImxvYWRBc3NpZ25tZW50XCIsIFN0YXR1c1N0YXRlLkZBSUxFRCwgcmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9MT0FESU5HX0FTU0lHTk1ORU5UKHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfTE9BRElOR19BU1NJR05NTkVOVCh0ZXh0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwibG9hZEFzc2lnbm1lbnRcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuc2F2ZUFzc2lnbm1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIGlmIChtb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcInNhdmVBc3NpZ25tZW50XCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJoaWRkZW5cIl0gPSBtb2RlbC5hc3NpZ25tZW50LmhpZGRlbigpO1xuICAgICAgICBkYXRhW1wicmV2aWV3ZWRcIl0gPSBtb2RlbC5hc3NpZ25tZW50LnJldmlld2VkKCk7XG4gICAgICAgIGRhdGFbXCJwdWJsaWNcIl0gPSBtb2RlbC5hc3NpZ25tZW50LnB1YmxpYygpO1xuICAgICAgICBkYXRhW1widXJsXCJdID0gbW9kZWwuYXNzaWdubWVudC51cmwoKTtcbiAgICAgICAgZGF0YVtcImlwX3Jhbmdlc1wiXSA9IG1vZGVsLmFzc2lnbm1lbnQuaXBSYW5nZXMoKTtcbiAgICAgICAgZGF0YVtcIm5hbWVcIl0gPSBtb2RlbC5hc3NpZ25tZW50Lm5hbWUoKTtcbiAgICAgICAgZGF0YVtcInNldHRpbmdzXCJdID0gc2F2ZUFzc2lnbm1lbnRTZXR0aW5ncyhtb2RlbCk7XG5cbiAgICAgICAgdGhpcy5fcG9zdEJsb2NraW5nKFwic2F2ZUFzc2lnbm1lbnRcIiwgZGF0YSwgMywgKCkgPT4gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9TQVZJTkdfQVNTSUdOTU5FTlQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwic2F2ZUFzc2lnbm1lbnRcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSwgXCJTZXJ2ZXIgaXMgbm90IGNvbm5lY3RlZCEgKFNhdmUgQXNzaWdubWVudClcIik7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubG9hZEhpc3RvcnkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibG9hZEhpc3RvcnlcIikpIHtcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoXCJsb2FkSGlzdG9yeVwiLCBkYXRhLCAyLCBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9MT0FESU5HX0hJU1RPUlkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmxvZ0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50X3R5cGUsIGNhdGVnb3J5LCBsYWJlbCwgbWVzc2FnZSwgZmlsZV9wYXRoKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2dFdmVudFwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibG9nRXZlbnRcIikpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgZGF0YVtcImV2ZW50X3R5cGVcIl0gPSBldmVudF90eXBlO1xuICAgICAgICBkYXRhW1wiY2F0ZWdvcnlcIl0gPSBjYXRlZ29yeTtcbiAgICAgICAgZGF0YVtcImxhYmVsXCJdID0gbGFiZWw7XG4gICAgICAgIGRhdGFbXCJtZXNzYWdlXCJdID0gbWVzc2FnZTtcbiAgICAgICAgZGF0YVtcImZpbGVfcGF0aFwiXSA9IGZpbGVfcGF0aDtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2dFdmVudFwiLCBTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICAvLyBUcmlnZ2VyIHJlcXVlc3RcbiAgICAgICAgdGhpcy5fcG9zdFJldHJ5KGRhdGEsIFwibG9nRXZlbnRcIiwgMCwgKCkgPT4ge1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImxvZ0V2ZW50XCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnNhdmVJbWFnZSA9IGZ1bmN0aW9uIChkaXJlY3RvcnksIGltYWdlKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlSW1hZ2VcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcInNhdmVJbWFnZVwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiZGlyZWN0b3J5XCJdID0gZGlyZWN0b3J5O1xuICAgICAgICBkYXRhW1wiaW1hZ2VcIl0gPSBpbWFnZTtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlSW1hZ2VcIiwgU3RhdHVzU3RhdGUuQUNUSVZFKTtcbiAgICAgICAgLy8gVHJpZ2dlciByZXF1ZXN0XG4gICAgICAgIHRoaXMuX3Bvc3RMYXRlc3RSZXRyeShkYXRhLCBcInR1cnRsZV9vdXRwdXRcIiwgXCJzYXZlSW1hZ2VcIiwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlSW1hZ2VcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUudXBkYXRlU3VibWlzc2lvblN0YXR1cyA9IGZ1bmN0aW9uKG5ld1N0YXR1cykge1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5yZWFkT25seSgpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwidXBkYXRlU3VibWlzc2lvblN0YXR1c1wiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwidXBkYXRlU3VibWlzc2lvblN0YXR1c1wiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wic3RhdHVzXCJdID0gbmV3U3RhdHVzO1xuICAgICAgICBsZXQgcG9zdFN0YXR1c0NoYW5nZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uc3VibWlzc2lvblN0YXR1cyhuZXdTdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoXCJ1cGRhdGVTdWJtaXNzaW9uU3RhdHVzXCIsIGRhdGEsIDIsIHBvc3RTdGF0dXNDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfVVBEQVRJTkdfU1VCTUlTU0lPTl9TVEFUVVMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBsb2FkIGZpbGVzIGFuZCB3ZWIgcmVzb3VyY2VzLlxuICpcbiAqIERFUFJFQ0FURURcbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubG9hZEZpbGUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIHR5cGUsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIHZhciBzZXJ2ZXIgPSB0aGlzO1xuICAgIGlmIChtb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImxvYWRfZmlsZVwiKSkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiZmlsZW5hbWVcIl0gPSBmaWxlbmFtZTtcbiAgICAgICAgZGF0YVtcInR5cGVcIl0gPSB0eXBlO1xuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcodGhpcy51cmxzLmxvYWRfZmlsZSwgZGF0YSwgNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2socmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlci5zZXRTdGF0dXMoXCJsb2FkRmlsZVwiLCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKFwiU2VydmVyIGZhaWx1cmUhIFJlcG9ydCB0byBpbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhcIk5vIGZpbGUgc2VydmVyIGF2YWlsYWJsZS5cIik7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwibG9hZEZpbGVcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSwgXCJTZXJ2ZXIgaXMgbm90IGNvbm5lY3RlZCEgKExvYWQgRmlsZSlcIik7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuc2F2ZUZpbGUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGNvbnRlbnRzLCBkZWxheSkge1xuICAgIGlmIChkZWxheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGF5ID0gdGhpcy5USU1FUl9ERUxBWTtcbiAgICB9XG4gICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIGlmIChtb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlRmlsZVwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJzYXZlRmlsZVwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiZmlsZW5hbWVcIl0gPSBmaWxlbmFtZTtcbiAgICAgICAgZGF0YVtcImNvZGVcIl0gPSBjb250ZW50cztcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlRmlsZVwiLCBTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICB0aGlzLl9wb3N0TGF0ZXN0UmV0cnkoZGF0YSwgZmlsZW5hbWUsIFwic2F2ZUZpbGVcIiwgZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwic2F2ZUZpbGVcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUudXBkYXRlU3VibWlzc2lvbiA9IGZ1bmN0aW9uIChzY29yZSwgY29ycmVjdCwgaGlkZGVuT3ZlcnJpZGUsIGZvcmNlVXBkYXRlKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJ1cGRhdGVTdWJtaXNzaW9uXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjYWxsYmFjayA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNhbGxiYWNrcy5zdWNjZXNzO1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJ1cGRhdGVTdWJtaXNzaW9uXCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJzY29yZVwiXSA9IHNjb3JlO1xuICAgICAgICBkYXRhW1wiY29ycmVjdFwiXSA9IGNvcnJlY3Q7XG4gICAgICAgIGRhdGFbXCJoaWRkZW5fb3ZlcnJpZGVcIl0gPSBoaWRkZW5PdmVycmlkZTtcbiAgICAgICAgZGF0YVtcImZvcmNlX3VwZGF0ZVwiXSA9IGZvcmNlVXBkYXRlO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0uYmxvY2tFZGl0b3IuZ2V0UG5nRnJvbUJsb2NrcygocG5nRGF0YSwgaW1nKSA9PiB7XG4gICAgICAgICAgICBkYXRhW1wiaW1hZ2VcIl0gPSBwbmdEYXRhO1xuICAgICAgICAgICAgaWYgKGltZy5yZW1vdmUpIHtcbiAgICAgICAgICAgICAgICBpbWcucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wb3N0UmV0cnkoZGF0YSwgXCJ1cGRhdGVTdWJtaXNzaW9uXCIsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcInVwZGF0ZVN1Ym1pc3Npb25cIiwgU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJ1cGRhdGVTdWJtaXNzaW9uXCIsIFN0YXR1c1N0YXRlLkZBSUxFRCwgcmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoaWRkZW5PdmVycmlkZSAmJiBjb3JyZWN0ICYmIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhW1wiYXNzaWdubWVudF9pZFwiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTsiLCJleHBvcnQgY29uc3QgJHNrX21vZF9jb3ZlcmFnZSA9IGBcblwiXCJcIlxuSGlkZW91cyBmaWxsLWluIHJlcGxhY2VtZW50IGZvciBDb3ZlcmFnZSwgbGV2ZXJhZ2luZyBzb21lIG1hZ2ljIGZyb20gdGhlXG5VdGlsaXR5IGZ1bmN0aW9uLiBUaGUgZGF0YSB0aGlzIHJldHVybnMgaXMgZmFsc2UgLSBpdCBkb2Vzbid0IGFjdHVhbGx5XG5kZXNjcmliZSB0aGUgbWlzc2luZyBsaW5lcyBhbmQgYWxsIGxpbmVzOyBpdCBqdXN0IGRlc2NyaWJlcyB0aGUgdHJhY2VkIGxpbmVzLlxuQnV0IHNpbmNlIFBlZGFsIGRvZXNuJ3QgbmVlZCB0aGUgb3RoZXIgdHdvLCBpdCB3b3JrcyBvdXQgZmluZSB3aGVuIHlvdSBkbzpcblxuc3RhdGVtZW50cyAtIG1pc3NpbmdcblwiXCJcIlxuXG5pbXBvcnQgdXRpbGl0eVxuXG5jbGFzcyBDb3ZlcmFnZTpcbiAgICBkZWYgc3RhcnQoc2VsZik6XG4gICAgICAgIHBhc3NcblxuICAgIGRlZiBzdG9wKHNlbGYpOlxuICAgICAgICBwYXNzXG5cbiAgICBkZWYgc2F2ZShzZWxmKTpcbiAgICAgICAgcGFzc1xuXG4gICAgZGVmIF9hbmFseXplKHNlbGYsIGZpbGVuYW1lOiBzdHIpOlxuICAgICAgICBsaW5lcyA9IHNldCh1dGlsaXR5LnRyYWNlX2xpbmVzKCkpXG4gICAgICAgICMgbGluZXMgd2lsbCBiZSB0aGUgbGluZXMgdGhhdCB3ZXJlIGFjdHVhbGx5IGV4ZWN1dGVkXG4gICAgICAgIHJldHVybiBBbmFseXNpcyhOb25lLCBsZW4obGluZXMpLCBOb25lLCBzZXQoKSwgbGluZXMpXG5cblxuY2xhc3MgTnVtYmVyczpcbiAgICBkZWYgX19pbml0X18oc2VsZiwgbl9taXNzaW5nLCBuX3N0YXRlbWVudHMsIHBjX2NvdmVyZWQpOlxuICAgICAgICBzZWxmLm5fbWlzc2luZyA9IG5fbWlzc2luZ1xuICAgICAgICBzZWxmLm5fc3RhdGVtZW50cyA9IG5fc3RhdGVtZW50c1xuICAgICAgICBzZWxmLnBjX2NvdmVyZWQgPSBwY19jb3ZlcmVkXG5cblxuY2xhc3MgQW5hbHlzaXM6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIG5fbWlzc2luZywgbl9zdGF0ZW1lbnRzLCBwY19jb3ZlcmVkLCBtaXNzaW5nLCBzdGF0ZW1lbnRzKTpcbiAgICAgICAgc2VsZi5taXNzaW5nID0gbWlzc2luZ1xuICAgICAgICBzZWxmLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzXG4gICAgICAgIHNlbGYubnVtYmVycyA9IE51bWJlcnMobl9taXNzaW5nLCBuX3N0YXRlbWVudHMsIHBjX2NvdmVyZWQpXG5cblxuY2xhc3MgcHl0aG9uOlxuICAgIGRlZiBnZXRfcHl0aG9uX3NvdXJjZShzZWxmKTpcbiAgICAgICAgcmV0dXJuIE5vbmVcbmA7IiwiZXhwb3J0IHZhciAkYnVpbHRpbm1vZHVsZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbW9kLCBzYW1wbGVXcmFwcGVyO1xuICAgIG1vZCA9IHtfX25hbWVfXzogXCJpbWFnZVwifTtcblxuICAgIGlmICghU2suUElMKSB7XG4gICAgICAgIFNrLlBJTCA9IHthc3NldHM6IHt9fTtcbiAgICB9XG5cbiAgICAvLyBJbnN0YW50UHJvbWlzZSBpcyBhIHdvcmthcm91bmQgdG8gYWxsb3cgdXNhZ2Ugb2YgdGhlIGNsZWFuIHByb21pc2Utc3R5bGVcbiAgICAvLyB0aGVuL2NhdGNoIHN5bnRheCBidXQgdG8gaW5zdGFudGx5IGNhbGwgcmVzb2x2ZSB0aGUgdGhlbi9jYXRjaCBjaGFpbiBzbyB3ZVxuICAgIC8vIGNhbiBhdm9pZCBjcmVhdGluZyBTdXNwZW5zaW9ucyBpbiB1bm5lY2Vzc2FyeSBjYXNlcy4gIFRoaXMgaXMgZGVzaXJhYmxlXG4gICAgLy8gYmVjYXVzZSBTdXNwZW5zaW9ucyBoYXZlIGEgZmFpcmx5IGxhcmdlIG5lZ2F0aXZlIGltcGFjdCBvbiBvdmVyYWxsXG4gICAgLy8gcGVyZm9ybWFuY2UuICBUaGVzZSAnaW5zdGFudCBwcm9taXNlcycgY29tZSBpbnRvIHBsYXkgd2hlbiBhIHRyYWNlcigpXG4gICAgLy8gY2FsbCBpcyBtYWRlIHdpdGggYSB2YWx1ZSBvdGhlciB0aGFuIDEuICBXaGVuIHRyYWNlciBpcyAwIG9yIGdyZWF0ZXIgdGhhbiAxXG4gICAgLy8gLCB3ZSBjYW4gYnlwYXNzIHRoZSBjcmVhdGlvbiBvZiBhIFN1c3BlbnNpb24gYW5kIHByb2NlZWQgdG8gdGhlIG5leHQgbGluZSBvZlxuICAgIC8vIGNvZGUgaW1tZWRpYXRlbHkgaWYgdGhlIGN1cnJlbnQgbGluZSBpcyBub3QgZ29pbmcgdG8gaW52b2x2ZSBhIHNjcmVlblxuICAgIC8vIHVwZGF0ZS4gV2UgZGV0ZXJtaW5lIGlmIGEgcmVhbCBwcm9taXNlIG9yIEluc3RhbnRQcm9taXNlIGlzIG5lY2Vzc2FyeSBieVxuICAgIC8vIGNoZWNraW5nIEZyYW1lTWFuYWdlci53aWxsUmVuZGVyTmV4dCgpXG4gICAgZnVuY3Rpb24gSW5zdGFudFByb21pc2UoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgdGhpcy5sYXN0UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLmxhc3RFcnJvciAgPSBlcnI7XG4gICAgfVxuXG4gICAgSW5zdGFudFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihjYikge1xuICAgICAgICBpZiAodGhpcy5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IGNiKHRoaXMubGFzdFJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlID8gdGhpcy5sYXN0UmVzdWx0IDogdGhpcztcbiAgICB9O1xuXG4gICAgSW5zdGFudFByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdEVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IGNiKHRoaXMubGFzdEVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RFcnJvciAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UgPyB0aGlzLmxhc3RSZXN1bHQgOiB0aGlzO1xuICAgIH07XG5cbiAgICB2YXIgYnVpbGRJbWFnZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldEFzc2V0KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKFNrLlBJTC5hc3NldHNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vcmV0dXJuIFNrLlBJTC5hc3NldHNbbmFtZV07XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShTay5QSUwuYXNzZXRzW25hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIGltZy5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7XG4gICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgU2suUElMLmFzc2V0c1tuYW1lXSA9IGltZztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgYXNzZXQ6IFwiICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuYW1lKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGltZy5zcmMgPSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2UgPSBmdW5jdGlvbigkZ2JsLCAkbG9jKSB7XG4gICAgICAgIC8vIG9wZW4oZmlsZW5hbWUpIG9yIG9wZW4odXJsKVxuICAgICAgICAvLyBzaG93KClcblxuICAgICAgICAkbG9jLl9faW5pdF9fID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwgZmlsZV9vcl91cmwpIHtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJfX2luaXRfX1wiLCBhcmd1bWVudHMsIDIsIDIpO1xuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrVHlwZShcImZpbGVfb3JfdXJsXCIsIFwic3RyaW5nXCIsIFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZmlsZV9vcl91cmwpKTtcbiAgICAgICAgICAgIHNlbGYuZmlsZV9vcl91cmwgPSBmaWxlX29yX3VybDtcbiAgICAgICAgICAgIC8vIFRPRE86IENoYW5nZSB0byBzdXNwZW5zaW9uXG4gICAgICAgICAgICB2YXIgaW1hZ2VQcm9taXNlID0gZ2V0QXNzZXQoU2suZmZpLnJlbWFwVG9KcyhmaWxlX29yX3VybCkpO1xuICAgICAgICAgICAgdmFyIHN1c3AgPSBuZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbigpO1xuICAgICAgICAgICAgc2VsZi5pbWFnZSA9IFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcbiAgICAgICAgICAgIHN1c3AucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1c3AuZGF0YVtcImVycm9yXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSU9FcnJvcihzdXNwLmRhdGFbXCJlcnJvclwiXS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc3VzcC5kYXRhW1wiZXJyb3JcIl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gc2VsZi5pbWFnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3VzcC5kYXRhID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiU2sucHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgIHByb21pc2U6IGltYWdlUHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW1hZ2UgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcy53aWR0aCA9IHNlbGYuaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzLmhlaWdodCA9IHNlbGYuaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuZHJhd0ltYWdlKHNlbGYuaW1hZ2UsIDAsIDAsIHNlbGYuaW1hZ2Uud2lkdGgsIHNlbGYuaW1hZ2UuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5waXhlbHMgPSBzZWxmLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKDAsIDAsIHNlbGYuaW1hZ2Uud2lkdGgsIHNlbGYuaW1hZ2UuaGVpZ2h0KS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbWFnZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gZXJyO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gc3VzcDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJGxvYy5zaG93ID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICBpZiAoU2suY29uc29sZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uTmFtZUVycm9yKFwiQ2FuIG5vdCByZXNvbHZlIGRyYXdpbmcgYXJlYS4gU2suY29uc29sZSBpcyB1bmRlZmluZWQhXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29uc29sZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW1hZ2U6IHNlbGYuaW1hZ2UsXG4gICAgICAgICAgICAgICAgZmlsZV9vcl91cmw6IHNlbGYuZmlsZV9vcl91cmxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNrLmNvbnNvbGUucHJpbnRQSUxJbWFnZShjb25zb2xlRGF0YSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRsb2MuZmxpcCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgc2VsZi5pbWFnZS5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlWCgtMSlcIjtcbiAgICAgICAgICAgIGlmIChTay5jb25zb2xlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5OYW1lRXJyb3IoXCJDYW4gbm90IHJlc29sdmUgZHJhd2luZyBhcmVhLiBTay5jb25zb2xlIGlzIHVuZGVmaW5lZCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBtb2QuSW1hZ2UgPSBTay5taXNjZXZhbC5idWlsZENsYXNzKG1vZCwgaW1hZ2UsIFwiSW1hZ2VcIiwgW10pO1xuXG4gICAgcmV0dXJuIG1vZDtcbn07IiwiZXhwb3J0IGNvbnN0ICRwZWRhbF90cmFjZXIgPSBgXHJcblxyXG5cIlwiXCJcclxuV3JhcHMgdGhlIHRyYWNlciBtb2R1bGUgaW4gUGVkYWxcclxuXCJcIlwiXHJcblxyXG5pbXBvcnQgb3NcclxuaW1wb3J0IHV0aWxpdHlcclxuICAgICAgICBcclxuY2xhc3MgU2FuZGJveEJhc2ljVHJhY2VyOlxyXG4gICAgXCJcIlwiXHJcblxyXG4gICAgXCJcIlwiXHJcbiAgICBkZWYgX19pbml0X18oc2VsZik6XHJcbiAgICAgICAgc3VwZXIoKS5fX2luaXRfXygpXHJcbiAgICAgICAgc2VsZi5maWxlbmFtZSA9IFwic3R1ZGVudC5weVwiXHJcbiAgICAgICAgc2VsZi5jb2RlID0gTm9uZVxyXG5cclxuICAgIGRlZiBhc19maWxlbmFtZShzZWxmLCBmaWxlbmFtZSwgY29kZSk6XHJcbiAgICAgICAgaWYgb3MucGF0aC5pc2FicyhmaWxlbmFtZSk6XHJcbiAgICAgICAgICAgIHNlbGYuZmlsZW5hbWUgPSBmaWxlbmFtZVxyXG4gICAgICAgIGVsc2U6XHJcbiAgICAgICAgICAgIHNlbGYuZmlsZW5hbWUgPSBvcy5wYXRoLmFic3BhdGgoZmlsZW5hbWUpXHJcbiAgICAgICAgc2VsZi5jb2RlID0gY29kZVxyXG4gICAgICAgIHJldHVybiBzZWxmXHJcblxyXG4gICAgZGVmIF9fZW50ZXJfXyhzZWxmKTpcclxuICAgICAgICBwYXNzXHJcblxyXG4gICAgZGVmIF9fZXhpdF9fKHNlbGYsIGV4Y190eXBlLCBleGNfdmFsLCB0cmFjZWJhY2spOlxyXG4gICAgICAgIHBhc3NcclxuXHJcbmNsYXNzIFNhbmRib3hOYXRpdmVUcmFjZXIoU2FuZGJveEJhc2ljVHJhY2VyKTpcclxuICAgIFwiXCJcIlxyXG4gICAgVHJhY2tzIGxpbmVzIGNvdmVyZWQgYW5kIGZ1bmN0aW9uIGNhbGxzLiBQb3NzaWJseSBvdGhlciB0aGluZ3M/IFdlIGNvdWxkIHRyYWNrIHZhcmlhYmxlcywgaWYgdGhhdFxyXG4gICAgd2FzIHNvbWV0aGluZyBwZW9wbGUgd2FudGVkLlxyXG5cclxuICAgIFRPRE86IEhhbmRsZSBtdWx0aXBsZSBzdWJtaXNzaW9uIGZpbGVzP1xyXG4gICAgXCJcIlwiXHJcbiAgICBkZWYgX19pbml0X18oc2VsZik6XHJcbiAgICAgICAgc3VwZXIoKS5fX2luaXRfXygpXHJcbiAgICAgICAgc2VsZi5jYWxscyA9IHV0aWxpdHkudHJhY2VfY2FsbHMoKVxyXG4gICAgICAgIHNlbGYubGluZXMgPSB1dGlsaXR5LnRyYWNlX2xpbmVzKClcclxuICAgICAgICBzZWxmLnN0ZXBfaW5kZXggPSBsZW4odXRpbGl0eS50cmFjZV9saW5lcygpKVxyXG5cclxuVFJBQ0VSX1NUWUxFUyA9IHtcclxuICAgICdub25lJzogU2FuZGJveEJhc2ljVHJhY2VyLFxyXG4gICAgJ25hdGl2ZSc6IFNhbmRib3hOYXRpdmVUcmFjZXJcclxufVxyXG5cclxuYDsiLCIvKipcbiAqIFNrdWxwdCBNb2R1bGUgZm9yIGhvbGRpbmcgdGhlIEluc3RydWN0b3IgQVBJLlxuICpcbiAqIFRoaXMgbW9kdWxlIGlzIGxvYWRlZCBpbiBieSBnZXR0aW5nIHRoZSBmdW5jdGlvbnMnIHNvdXJjZSBjb2RlIGZyb20gdG9TdHJpbmcuXG4gKiBJc24ndCB0aGF0IGNyYXp5P1xuICpcbiAqXG4gKi9cbmV4cG9ydCBsZXQgJHNrX21vZF9pbnN0cnVjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gTWFpbiBtb2R1bGUgb2JqZWN0IHRoYXQgZ2V0cyByZXR1cm5lZCBhdCB0aGUgZW5kLlxuICAgIGxldCBtb2QgPSB7fTtcbiAgICBsZXQgbm9uZSA9IFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcbiAgICBcbiAgICBsZXQgcHJpb3IgPSBudWxsO1xuICAgIG1vZC50aW1laXQgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInRpbWVpdFwiLCBhcmd1bWVudHMsIDEsIDEpO1xuICAgICAgICBsZXQgZGlmZmVyZW5jZTtcbiAgICAgICAgaWYgKHByaW9yID09PSBudWxsKSB7XG4gICAgICAgICAgICBkaWZmZXJlbmNlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBEYXRlLm5vdygpIC0gcHJpb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coU2suZmZpLnJlbWFwVG9KcyhuYW1lKSwgZGlmZmVyZW5jZS8xMDAwKTtcbiAgICAgICAgcHJpb3IgPSBEYXRlLm5vdygpO1xuICAgIH0pO1xuICAgIFxuICAgIC8qKlxuICAgICAqIExvZ3MgZmVlZGJhY2sgdG8gamF2YXNjcmlwdCBjb25zb2xlXG4gICAgICovXG4gICAgbW9kLmNvbnNvbGVfbG9nID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS5sb2coKFsuLi5hcmd1bWVudHNdKS5tYXAoU2suZmZpLnJlbWFwVG9KcykpO1xuICAgIH0pO1xuICAgIFxuICAgIC8qKlxuICAgICAqIExvZ3MgZGVidWcgdG8gamF2YXNjcmlwdCBjb25zb2xlXG4gICAgICovXG4gICAgbW9kLmNvbnNvbGVfZGVidWcgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjb3ZlcnRzIHRoZSBvdXRwdXQgaW4gdGhlIHN0dWRlbnQgcmVwb3J0IHRvIGEgcHl0aG9uIFxuICAgICAqIGxpc3QgYW5kIHJldHVybnMgaXQuXG4gICAgKiovXG4gICAgbW9kLmdldF9vdXRwdXQgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZ2V0X291dHB1dFwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgbGV0IG91dHB1dCA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdW1wib3V0cHV0XCJdKCk7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQubWFwKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0udG9Ta3VscHQoKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChvdXRwdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoW10pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiByZXNldHMgdGhlIG91dHB1dCwgcGFydGljdWxhcmx5IHVzZWZ1bCBpZiB0aGUgc3R1ZGVudFxuICAgICAqIGNvZGUgaXMgZ29pbmcgdG8gYmUgcmVydW4uXG4gICAgICovXG4gICAgbW9kLnJlc2V0X291dHB1dCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJyZXNldF9vdXRwdXRcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLm91dHB1dC5yZW1vdmVBbGwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkO1xuICAgIH0pO1xuICAgIFxuICAgIC8qbW9kLnF1ZXVlX2lucHV0ID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInF1ZXVlX2lucHV0XCIsIGFyZ3VtZW50cywgMSwgSW5maW5pdHkpO1xuICAgICAgICBsZXQgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgZm9yIChsZXQgaSA9IGFyZ3MubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBhcmdzW2ldO1xuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrVHlwZShcImlucHV0XCIsIFwic3RyaW5nXCIsIFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoaW5wdXQpKTtcbiAgICAgICAgICAgIFNrLnF1ZXVlZElucHV0LnB1c2goU2suZmZpLnJlbWFwVG9KcyhpbnB1dCkpO1xuICAgICAgICB9XG4gICAgfSk7Ki9cbiAgICBcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBpbnN0cnVjdG9ycyB0byBnZXQgdGhlIHN0dWRlbnRzJyBjb2RlIGFzIGEgc3RyaW5nLlxuICAgICoqL1xuICAgIG1vZC5nZXRfcHJvZ3JhbSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfcHJvZ3JhbVwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShTay5leGVjdXRpb25SZXBvcnRzW1widmVyaWZpZXJcIl0uY29kZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBpbnN0cnVjdG9ycyB0byBnZXQgdGhlIHN0dWRlbnRzJyBjb2RlIGFzIGEgc3RyaW5nLlxuICAgICoqL1xuICAgIG1vZC5nZXRfZXZhbHVhdGlvbiA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfZXZhbHVhdGlvblwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5ldmFsdWF0aW9uIHx8IFwiXCIpO1xuICAgIH0pO1xuICAgIFxuICAgIG1vZC50cmFjZV9saW5lcyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5yZWFsTGluZXM7XG4gICAgICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShsaW5lcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChbXSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZC50cmFjZV9jYWxscyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiLS1cIiwgU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0pO1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgbGV0IGNhbGxzID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uY2FsbHM7XG4gICAgICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShjYWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmRpY3QoW10pO1xuICAgIH0pO1xuICAgIFxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgbW9kLmdldF9zdHVkZW50X2Vycm9yID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9zdHVkZW50X2Vycm9yXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW25vbmUsIG5vbmVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLmVycm9yLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IudHJhY2ViYWNrICYmIGVycm9yLnRyYWNlYmFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25bXCJsaW5lXCJdID0gZXJyb3IudHJhY2ViYWNrWzBdLmxpbmVubztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBub25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zaXRpb24gPSBTay5mZmkucmVtYXBUb1B5KHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbZXJyb3IsIHBvc2l0aW9uXSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFxuICAgIG1vZC5oYWRfZXhlY3V0aW9uX3RpbWVfZXJyb3IgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiaGFkX2V4ZWN1dGlvbl90aW1lX2Vycm9yXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIHJldHVybiAhU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2VzcyAmJiBcbiAgICAgICAgICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5lcnJvciAmJlxuICAgICAgICAgICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLmVycm9yLnRwJG5hbWUgPT09IFwiVGltZUxpbWl0RXJyb3JcIjtcbiAgICB9KTtcbiAgICBcbiAgICBsZXQgYmFja3VwVGltZSA9IHVuZGVmaW5lZDtcbiAgICBtb2QubGltaXRfZXhlY3V0aW9uX3RpbWUgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwibGltaXRfZXhlY3V0aW9uX3RpbWVcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgYmFja3VwVGltZSA9IFNrLmV4ZWNMaW1pdDtcbiAgICAgICAgaWYgKFNrLmV4ZWNMaW1pdEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBTay5leGVjTGltaXQgPSBTay5leGVjTGltaXRGdW5jdGlvbigpO1xuICAgICAgICAgICAgU2suZXhlY1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG1vZC51bmxpbWl0X2V4ZWN1dGlvbl90aW1lID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInVubGltaXRfZXhlY3V0aW9uX3RpbWVcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgU2suZXhlY0xpbWl0ID0gYmFja3VwVGltZTtcbiAgICAgICAgU2suZXhlY1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB9KTtcbiAgICBcbiAgICBtb2Quc3VwcHJlc3Nfc2Nyb2xsaW5nID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInN1cHByZXNzX3Njcm9sbGluZ1wiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzLmluc3RydWN0b3Iuc2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIFxuICAgIC8qXG4gICAgZGVmIGhpc3Qoc2VsZiwgZGF0YSwgKiprd2FyZ3MpOlxuICAgICAgICBsYWJlbCA9IGt3YXJncy5nZXQoJ2xhYmVsJywgTm9uZSlcbiAgICAgICAgc2VsZi5hY3RpdmVfcGxvdFsnZGF0YSddLmFwcGVuZCh7J3R5cGUnOiAnSGlzdG9ncmFtJywgJ3ZhbHVlcyc6IGRhdGEsICdsYWJlbCc6IGxhYmVsfSlcbiAgICBkZWYgcGxvdChzZWxmLCB4cywgeXM9Tm9uZSwgKiprd2FyZ3MpOlxuICAgICAgICBsYWJlbCA9IGt3YXJncy5nZXQoJ2xhYmVsJywgTm9uZSlcbiAgICAgICAgaWYgeXMgPT0gTm9uZTpcbiAgICAgICAgICAgIHNlbGYuYWN0aXZlX3Bsb3RbJ2RhdGEnXS5hcHBlbmQoeyd0eXBlJzogJ0xpbmUnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3gnOiByYW5nZShsZW4oeHMpKSwgJ3knOiB4cywgJ2xhYmVsJzogbGFiZWx9KVxuICAgICAgICBlbHNlOlxuICAgICAgICAgICAgc2VsZi5hY3RpdmVfcGxvdFsnZGF0YSddLmFwcGVuZCh7J3R5cGUnOiAnTGluZScsICd4JzogeHMsICd5JzogeXMsICdsYWJlbCc6IGxhYmVsfSlcbiAgICBkZWYgc2NhdHRlcihzZWxmLCB4cywgeXMsICoqa3dhcmdzKTpcbiAgICAgICAgbGFiZWwgPSBrd2FyZ3MuZ2V0KCdsYWJlbCcsIE5vbmUpXG4gICAgICAgIHNlbGYuYWN0aXZlX3Bsb3RbJ2RhdGEnXS5hcHBlbmQoeyd0eXBlJzogJ1NjYXR0ZXInLCAneCc6IHhzLCAneSc6IHlzLCAnbGFiZWwnOiBsYWJlbH0pXG4gICAgKi9cbiAgICBtb2QuZ2V0X3Bsb3RzID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9wbG90c1wiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgbGV0IG91dHB1dHMgPSBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXVtcIm91dHB1dFwiXSgpO1xuICAgICAgICAgICAgb3V0cHV0cyA9IG91dHB1dHMuZmlsdGVyKGZ1bmN0aW9uKG91dHB1dCkgeyBcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0LnR5cGUgPT09IFwicGxvdFwiO1xuICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uKGdyYXBoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcImRhdGFcIjogZ3JhcGguY29udGVudC5tYXAoZnVuY3Rpb24ocGxvdCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UGxvdCA9IHsgXCJ0eXBlXCI6IHBsb3QudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGFiZWxcIjogXCJcIiB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxvdC50eXBlID09PSBcImxpbmVcIiB8fCBwbG90LnR5cGUgPT09IFwic2NhdHRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQbG90W1wieFwiXSA9IHBsb3QuZGF0YS5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdi54OyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bsb3RbXCJ5XCJdID0gcGxvdC5kYXRhLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB2Lnk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsb3QudHlwZSA9PT0gXCJoaXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bsb3RbXCJ2YWx1ZXNcIl0gPSBwbG90LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Bsb3Q7XG4gICAgICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgICAgIFwieGxhYmVsXCI6IFwiXCIsIFwieWxhYmVsXCI6IFwiXCIsIFxuICAgICAgICAgICAgICAgIFwidGl0bGVcIjogXCJcIiwgXCJsZWdlbmRcIjogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShvdXRwdXRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KFtdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgXG4gICAgLy8gUHJvdmlkZXMgYHN0dWRlbnRgIGFzIGFuIG9iamVjdCB3aXRoIGFsbCB0aGUgZGF0YSB0aGF0IHRoZSBzdHVkZW50IGRlY2xhcmVkLlxuICAgIG1vZC5TdHVkZW50RGF0YSA9IFNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MobW9kLCBmdW5jdGlvbigkZ2JsLCAkbG9jKSB7XG4gICAgICAgICRsb2MuX19pbml0X18gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgICAgIC8vc2VsZi5kYXRhID0gU2suYnVpbHRpbi5kaWN0KCk7XG4gICAgICAgICAgICBsZXQgbmV3RGljdCA9IG5ldyBTay5idWlsdGluLmRpY3QoKTtcbiAgICAgICAgICAgIFNrLmFic3RyLnNhdHRyKHNlbGYsIG5ldyBTay5idWlsdGluLnN0cihcImRhdGFcIiksIG5ld0RpY3QsIHRydWUpO1xuICAgICAgICAgICAgc2VsZi5tb2R1bGUgPSBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5yZXN1bHRzO1xuICAgICAgICAgICAgaWYgKHNlbGYubW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZSA9IHNlbGYubW9kdWxlLiRkO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBzZWxmLm1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2R1bGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgU2suYWJzdHIub2JqZWN0U2V0SXRlbShuZXdEaWN0LCBTay5mZmkucmVtYXBUb1B5KFNrLnVuZml4UmVzZXJ2ZWQoa2V5KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubW9kdWxlW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjYWxsX2YgPSBmdW5jdGlvbihrd2EpIHtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXCJjYWxsXCIsIGFyZ3VtZW50cy5sZW5ndGgsIDEsIEluZmluaXR5LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIHZhciBrd2FyZ3MgPSBuZXcgU2suYnVpbHRpbnMuZGljdChrd2EpO1xuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IGFyZ3NbMF07XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gYXJnc1sxXTtcbiAgICAgICAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDIpO1xuXG4gICAgICAgICAgICB2YXIgaW5wdXRzID0ga3dhcmdzLm1wJGxvb2t1cChuZXcgU2suYnVpbHRpbi5zdHIoXCJpbnB1dHNcIikpO1xuICAgICAgICAgICAgaWYgKGlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzID0gU2suZmZpLnJlbWFwVG9KcyhpbnB1dHMpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dHMuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFNrLnF1ZXVlZElucHV0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFNrLnF1ZXVlZElucHV0LnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZWxmLnRwJGdldGF0dHIobmV3IFNrLmJ1aWx0aW4uc3RyKFwiZGF0YVwiKSk7XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25PYmplY3QgPSBkYXRhLm1wJGxvb2t1cChmdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uT2JqZWN0LnRwJGNhbGwoYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBjYWxsX2YuY29fa3dhcmdzID0gdHJ1ZTtcbiAgICAgICAgLy9jYWxsX2YuY29fdmFybmFtZXMgPSBbXCJzZWxmXCIsIFwiZnVuY3Rpb25cIl07XG4gICAgICAgIGNhbGxfZi5jb19uYW1lPSBuZXcgU2suYnVpbHRpbi5zdHIoXCJjYWxsXCIpO1xuICAgICAgICAkbG9jW1wiY2FsbF8kcm4kXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhjYWxsX2YpO1xuXG4gICAgICAgICRsb2NbXCJfX3JlcHJfX1wiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIlwiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJGxvYy5nZXRfbmFtZXNfYnlfdHlwZSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZiwgdHlwZSwgZXhjbHVkZV9idWlsdGlucykge1xuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9uYW1lc19ieV90eXBlXCIsIGFyZ3VtZW50cywgMiwgMyk7XG4gICAgICAgICAgICBpZiAoZXhjbHVkZV9idWlsdGlucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZV9idWlsdGlucyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXCJleGNsdWRlX2J1aWx0aW5zXCIsIFwiYm9vbGVhblwiLCBTay5idWlsdGluLmNoZWNrQm9vbChleGNsdWRlX2J1aWx0aW5zKSk7XG4gICAgICAgICAgICAgICAgZXhjbHVkZV9idWlsdGlucyA9IFNrLmZmaS5yZW1hcFRvSnMoZXhjbHVkZV9idWlsdGlucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBzZWxmLm1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vZHVsZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubW9kdWxlW3Byb3BlcnR5XS50cCRuYW1lID09PSB0eXBlLnRwJG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZXhjbHVkZV9idWlsdGlucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZV9idWlsdGlucyAmJiBwcm9wZXJ0eS5zdGFydHNXaXRoKFwiX19cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFNrLmZmaS5yZW1hcFRvUHkoU2sudW5maXhSZXNlcnZlZChwcm9wZXJ0eSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICAkbG9jLmdldF92YWx1ZXNfYnlfdHlwZSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZiwgdHlwZSwgZXhjbHVkZV9idWlsdGlucykge1xuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF92YWx1ZXNfYnlfdHlwZVwiLCBhcmd1bWVudHMsIDIsIDMpO1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVfYnVpbHRpbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVfYnVpbHRpbnMgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwiZXhjbHVkZV9idWlsdGluc1wiLCBcImJvb2xlYW5cIiwgU2suYnVpbHRpbi5jaGVja0Jvb2woZXhjbHVkZV9idWlsdGlucykpO1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVfYnVpbHRpbnMgPSBTay5mZmkucmVtYXBUb0pzKGV4Y2x1ZGVfYnVpbHRpbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gc2VsZi5tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2R1bGUuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vZHVsZVtwcm9wZXJ0eV0udHAkbmFtZSA9PT0gdHlwZS50cCRuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZV9idWlsdGlucyAmJiBwcm9wZXJ0eS5zdGFydHNXaXRoKFwiX19cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNlbGYubW9kdWxlW3Byb3BlcnR5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9LCBcIlN0dWRlbnREYXRhXCIpO1xuICAgIG1vZC5zdHVkZW50ID0gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZChtb2QuU3R1ZGVudERhdGEpO1xuICAgIFxuICAgIG1vZC5nZXRfc3R1ZGVudF9kYXRhID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9zdHVkZW50X2RhdGFcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIG1vZC5zdHVkZW50O1xuICAgIH0pO1xuXG4gICAgbW9kLnNldF9pbnN0cnVjdGlvbnMgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKG5ld0luc3RydWN0aW9ucykge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwic2V0X2luc3RydWN0aW9uc1wiLCBhcmd1bWVudHMsIDEsIDIpO1xuICAgICAgICBuZXdJbnN0cnVjdGlvbnMgPSBTay5mZmkucmVtYXBUb0pzKG5ld0luc3RydWN0aW9ucyk7XG4gICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJtb2RlbFwiXS5kaXNwbGF5LmNoYW5nZWRJbnN0cnVjdGlvbnMobmV3SW5zdHJ1Y3Rpb25zKTtcbiAgICB9KTtcblxuICAgIG1vZC5nZXRfbW9kZWxfaW5mbyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oa2V5cykge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZ2V0X21vZGVsX2luZm9cIiwgYXJndW1lbnRzLCAxLCAxKTtcbiAgICAgICAgbGV0IG1vZGVsID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcIm1vZGVsXCJdO1xuICAgICAgICBrZXlzID0gU2suZmZpLnJlbWFwVG9KcyhrZXlzKS5zcGxpdChcIi5cIik7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1vZGVsID0gbW9kZWxba2V5c1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkobW9kZWwoKSk7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIG1vZDtcbn07XG4iLCJsZXQgTE9DQUxfU1RPUkFHRV9SRUY7XG50cnkge1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGID0gbG9jYWxTdG9yYWdlO1xuICAgIGxldCBtb2QgPSBcIkJMT0NLUFlfTE9DQUxTVE9SQUdFX1RFU1RcIjtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRi5zZXRJdGVtKG1vZCwgbW9kKTtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRi5yZW1vdmVJdGVtKG1vZCk7XG59IGNhdGNoKGUpIHtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRiA9IHtcbiAgICAgICAgX2RhdGEgICAgICAgOiB7fSxcbiAgICAgICAgc2V0SXRlbSAgICAgOiBmdW5jdGlvbihpZCwgdmFsKSB7IHJldHVybiB0aGlzLl9kYXRhW2lkXSA9IFN0cmluZyh2YWwpOyB9LFxuICAgICAgICBnZXRJdGVtICAgICA6IGZ1bmN0aW9uKGlkKSB7IHJldHVybiB0aGlzLl9kYXRhLmhhc093blByb3BlcnR5KGlkKSA/IHRoaXMuX2RhdGFbaWRdIDogbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlSXRlbSAgOiBmdW5jdGlvbihpZCkgeyByZXR1cm4gZGVsZXRlIHRoaXMuX2RhdGFbaWRdOyB9LFxuICAgICAgICBjbGVhciAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fZGF0YSA9IHt9OyB9XG4gICAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgb2JqZWN0IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBMb2NhbFN0b3JhZ2UuIFRoZSBMb2NhbFN0b3JhZ2VcbiAqIGJyb3dzZXIgQVBJIGFsbG93cyBmb3Igb2ZmbGluZSBzdG9yYWdlLiBUaGF0IEFQSSBpcyB2ZXJ5IHVuc29waGlzdGljYXRlZCxcbiAqIGFuZCBpcyBlc3NlbnRpYWxseSBhIGxhbWUga2V5LXZhbHVlIHN0b3JlLiBUaGlzIG9iamVjdCBzaXRzIG9uIHRvcFxuICogYW5kIHByb3ZpZGVzIGEgbnVtYmVyIG9mIHVzZWZ1bCB1dGlsaXRpZXMsIGluY2x1ZGluZyBydWRpbWVudGFyeWNhY2hlXG4gKiBjYWNoZSBleHBpcmF0aW9uLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0xvY2FsU3RvcmFnZVdyYXBwZXJ9XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIC0gQSBuYW1lc3BhY2UgdG8gdXNlIGluIGdyb3VwaW5nIGFjY2VzcyB0byBsb2NhbHN0b3JhZ2UuIFRoaXMga2VlcHMgYWNjZXNzIGNsZWFuIGFuZCBvcmdhbml6ZWQsIHdoaWxlIGFsc28gbWFraW5nIGl0IHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgTG9jYWxTdG9yYWdlIGNvbm5lY3Rpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gTG9jYWxTdG9yYWdlV3JhcHBlcihuYW1lc3BhY2UpIHtcbiAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbn1cbi8qKlxuICogQSBtZXRob2QgZm9yIGFkZGluZyBhIGtleS92YWx1ZSBwYWlyIHRvIExvY2FsU3RvcmFnZS5cbiAqIE5vdGUgdGhhdCBib3RoIHBhcmFtZXRlcnMgbXVzdCBiZSBzdHJpbmdzIChKU09OLnN0cmluZ2lmeSBpcyB5b3VyIGZyaWVuZCkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUuXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnNldCA9ICBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYuc2V0SXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdmFsdWVcIiwgdmFsdWUpO1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGLnNldEl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3RpbWVzdGFtcFwiLCAkLm5vdygpKTtcbn07XG5cbi8qKlxuICogQSBtZXRob2QgZm9yIHJlbW92aW5nIGEga2V5IGZyb20gTG9jYWxTdG9yYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUgbmFtZSBvZiB0aGUga2V5IHRvIHJlbW92ZS5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYucmVtb3ZlSXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdmFsdWVcIik7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYucmVtb3ZlSXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdGltZXN0YW1wXCIpO1xufTtcblxuLyoqXG4gKiBBIG1ldGhvZCBmb3IgcmV0cmlldmluZyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBrZXkgdG8gcmV0cmlldmUgdGhlIHZhbHVlIGZvci5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIExPQ0FMX1NUT1JBR0VfUkVGLmdldEl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3ZhbHVlXCIpO1xufTtcblxuLyoqXG4gKiBBIG1ldGhvZCBmb3IgcmV0cmlldmluZyB0aGUgdGltZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIG5hbWUgb2YgdGhlIGtleSB0byByZXRyaWV2ZSB0aGUgdGltZSBmb3IuXG4gKiBAcmV0dXJucyB7SW50ZWdlcn0gLSBUaGUgdGltZXN0YW1wIChsb2NhbCBlcG9jaCkgd2hlbiB0aGUga2V5IHdhcyBsYXN0IHNldC5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBwYXJzZUludChMT0NBTF9TVE9SQUdFX1JFRi5nZXRJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl90aW1lc3RhbXBcIikpO1xufTtcblxuLyoqXG4gKiBBIG1ldGhvZCBmb3IgcmV0cmlldmluZyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuXG4gKiBJZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LCB0aGVuIHRoZSBkZWZhdWx0IHZhbHVlIGlzIHVzZWQgaW5zdGVhZC5cbiAqIFRoaXMgZGVmYXVsdCB3aWxsIGJlIHNldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIG5hbWUgb2YgdGhlIGtleSB0byByZXRyaWV2ZSB0aGUgdmFsdWUgZm9yLlxuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRWYWx1ZSAtIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHVzZS4gTXVzdCBiZSBhIHN0cmluZy5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXQoa2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogQSB0ZXN0IGZvciB3aGV0aGVyIHRoZSBnaXZlbiBrZXkgaXMgaW4gTG9jYWxTdG9yYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIHRlc3QgZXhpc3RlbmNlIGZvci5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIExPQ0FMX1NUT1JBR0VfUkVGLmdldEl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3ZhbHVlXCIpICE9PSBudWxsO1xufTtcblxuLyoqXG4gKiBBIHRlc3QgZm9yIHdoZXRoZXIgdGhlIHNlcnZlciBoYXMgdGhlIG5ld2VyIHZlcnNpb24uIFRoaXMgZnVuY3Rpb25cbiAqIGFzc3VtZXMgdGhhdCB0aGUgc2VydmVyIHRyaXAgdGFrZXMgYWJvdXQgNSBzZWNvbmRzLiBUaGlzIG1ldGhvZFxuICogaXMgbGFyZ2VseSBkZXByZWNhdGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHBhcmFtIHtJbnRlZ2VyfSBzZXJ2ZXJfdGltZSAtIFRoZSBzZXJ2ZXIncyB0aW1lIGFzIGFuIGVwb2NoIChpbiBtaWxsaXNlY29uZHMpXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmlzX25ldyA9IGZ1bmN0aW9uKGtleSwgc2VydmVyX3RpbWUpIHtcbiAgICB2YXIgc3RvcmVkX3RpbWUgPSBMT0NBTF9TVE9SQUdFX1JFRi5nZXRJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl90aW1lc3RhbXBcIik7XG4gICAgcmV0dXJuIChzZXJ2ZXJfdGltZSA+PSBzdG9yZWRfdGltZSs1MDAwKTtcbn07XG4iLCJleHBvcnQgY29uc3QgVFJBQ0VfSFRNTCA9IGBcblxuPGRpdiBjbGFzcz1cImJsb2NrcHktdHJhY2UgY29sLW1kLTYgYmxvY2tweS1wYW5lbFwiXG4gICAgICAgICAgICByb2xlPVwicmVnaW9uXCIgYXJpYS1sYWJlbD1cIlRyYWNlXCI+XG4gICAgXG4gICAgPGRpdiBjbGFzcz1cImNsZWFyZml4XCI+XG4gICAgICAgIDxzdHJvbmc+VHJhY2U6IDwvc3Ryb25nPlxuICAgICAgICBcbiAgICAgICAgPCEtLSBGZWVkYmFjay9UcmFjZSBWaXNpYmlsaXR5IENvbnRyb2wgLS0+XG4gICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJ1xuICAgICAgICAgICAgICAgIGNsYXNzPSdidG4gYnRuLXNtIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBmbG9hdC1yaWdodCBibG9ja3B5LWhpZGUtdHJhY2UnXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnNlY29uZFJvdy5hZHZhbmNlU3RhdGVcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZXllJz48L3NwYW4+IEhpZGUgVHJhY2VcbiAgICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAgbWItMyBibG9ja3B5LXRyYWNlLWNvbnRyb2xzXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1wcmVwZW5kXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4tb3V0bGluZS1zZWNvbmRhcnknXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnRyYWNlLmZpcnN0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1zdGVwLWJhY2t3YXJkJz48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSdcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkudHJhY2UuYmFja3dhcmRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWJhY2t3YXJkJz48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiPlN0ZXA6PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC10ZXh0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPSd0ZXh0OiBleGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgLyA8c3BhbiBkYXRhLWJpbmQ9J3RleHQ6IGV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwJz48L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYXBwZW5kXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4tb3V0bGluZS1zZWNvbmRhcnknXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnRyYWNlLmZvcndhcmRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWZvcndhcmQnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5J1xuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS50cmFjZS5sYXN0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1zdGVwLWZvcndhcmQnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC10ZXh0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPSd0ZXh0OiB1aS50cmFjZS5saW5lJz48L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIFxuICAgIDx0YWJsZSBjbGFzcz0ndGFibGUgdGFibGUtc20gdGFibGUtc3RyaXBlZCB0YWJsZS1ib3JkZXJlZCB0YWJsZS1ob3Zlcic+XG4gICAgICAgIDxjYXB0aW9uPkN1cnJlbnQgdmFyaWFibGVzIGF0IHRoaXMgc3RlcDwvY2FwdGlvbj5cbiAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgPHRyPjx0aD5OYW1lPC90aD48dGg+VHlwZTwvdGg+PHRoPlZhbHVlPC90aD48L3RyPlxuICAgICAgICA8L3RoZWFkPlxuICAgICAgICA8dGJvZHkgZGF0YS1iaW5kPVwiZm9yZWFjaDogdWkudHJhY2UuZGF0YSgpLnByb3BlcnRpZXNcIj5cbiAgICAgICAgICAgIDx0ciBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiBuYW1lICE9ICdfX2ZpbGVfXycgJiYgbmFtZSAhPSAnX19wYXRoX18nXCI+XG4gICAgICAgICAgICAgICAgPHRkIGRhdGEtYmluZD1cInRleHQ6IG5hbWVcIj48L3RkPlxuICAgICAgICAgICAgICAgIDx0ZCBkYXRhLWJpbmQ9XCJ0ZXh0OiB0eXBlXCI+PC90ZD5cbiAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgIDxjb2RlIGRhdGEtYmluZD1cInRleHQ6IHZhbHVlXCI+PC9jb2RlPlxuICAgICAgICAgICAgICAgICAgICA8IS0tIGtvIGlmOiB0eXBlID09IFwiTGlzdFwiIC0tPlxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cIlwiIGRhdGEtYmluZD1cImNsaWNrOiAvLyRyb290LnZpZXdFeGFjdFZhbHVlKHR5cGUsIGV4YWN0X3ZhbHVlKVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZ2x5cGhpY29uIGdseXBoaWNvbi1uZXctd2luZG93Jz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvdHI+XG4gICAgICAgIDwvdGJvZHk+XG4gICAgPC90YWJsZT5cbiAgICBcbjwvZGl2PlxuYDtcblxuZXhwb3J0IGNsYXNzIEJsb2NrUHlUcmFjZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG5cbiAgICAgICAgdGhpcy5JR05PUkVEX0dMT0JBTFMgPSBbXCJfX25hbWVfX1wiLCBcIl9fZG9jX19cIiwgXCJfX3BhY2thZ2VfX1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzbWV0aG9kXCIsIFwicHJvcGVydHlcIiwgXCJzdGF0aWNtZXRob2RcIl07XG5cbiAgICAgICAgLy8gdGhpcy50cmFjZS5jbGljayh0aGlzLmJ1aWxkVHJhY2VUYWJsZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdW1lIGEgc2V0IG9mIHZhcmlhYmxlcyB0cmFjZWQgZnJvbSB0aGUgZXhlY3V0aW9uIGFuZCBwYXJzZSBvdXQgYW55XG4gICAgICogZ2xvYmFsIHZhcmlhYmxlcyBhbmQgbW9kdWxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YXJpYWJsZXMgLSBhIG1hcHBpbmcgb2YgdmFyaWFibGUgbmFtZXMgdG8gdGhlaXIgU2t1cHQgdmFsdWUuXG4gICAgICovXG4gICAgcGFyc2VHbG9iYWxzKHZhcmlhYmxlcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBtb2R1bGVzID0gW107XG4gICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkudHJhY2VFeGVjdXRpb24oKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdmFyaWFibGVzW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5JR05PUkVEX0dMT0JBTFMuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkucmVwbGFjZShcIl8kcnckXCIsIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIl8kcm4kXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyc2VkO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gQmxvY2tQeVRyYWNlLnBhcnNlVmFsdWUocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSB7XCJuYW1lXCI6IHByb3BlcnR5LCBcInR5cGVcIjogXCJVbmtub3duXCIsIFwidmFsdWVcIjogdmFsdWUudG9TdHJpbmcoKX07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gU2suYnVpbHRpbi5tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZXMucHVzaCh2YWx1ZS4kZC5fX25hbWVfXy52KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1wicHJvcGVydGllc1wiOiByZXN1bHQsIFwibW9kdWxlc1wiOiBtb2R1bGVzfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIFNrdWxwdCB2YWx1ZSBpbnRvIGEgbW9yZSBlYXNpbHkgcHJpbnRhYmxlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIHRoZSBza3VscHQgdmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VWYWx1ZShwcm9wZXJ0eSwgdmFsdWUsIGZ1bGxMZW5ndGgpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlVua25vd25cIixcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiVW5kZWZpbmVkXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLmZ1bmM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICh2YWx1ZS5mdW5jX2NvZGUuY29fdmFybmFtZXMgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgQXJndW1lbnRzOiBcIit2YWx1ZS5mdW5jX2NvZGUuY29fdmFybmFtZXMuam9pbihcIiwgXCIpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBObyBhcmd1bWVudHNcIilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLm1vZHVsZTogcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uc3RyOlxuICAgICAgICAgICAgICAgIGlmIChmdWxsTGVuZ3RoIHx8IHZhbHVlLnYubGVuZ3RoIDw9IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiU3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiU3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiW1wiK3ZhbHVlLnNxJGxlbmd0aCgpK1wiIGNoYXJhY3RlcnMgbm90IHNob3duXVwiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLm5vbmU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIk5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIk5vbmVcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uYm9vbDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiQm9vbGVhblwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4ubm1iZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImludFwiID09PSB2YWx1ZS5za1R5cGUgPyBcIkludGVnZXJcIjogXCJGbG9hdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uaW50XzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiSW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uZmxvYXRfOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJGbG9hdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4udHVwbGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlR1cGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIoKS52XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5saXN0OlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS52Lmxlbmd0aCA8PSAyMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkxpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIoKS52LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJleGFjdF92YWx1ZVwiOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiTGlzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIlsuLi4gXCIrdmFsdWUudi5sZW5ndGgrXCIgZWxlbWVudHMgLi4uXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJleGFjdF92YWx1ZVwiOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5kaWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJEaWN0aW9uYXJ5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIoKS52XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogdmFsdWUgJSAxID09PSAwID8gXCJJbnRlZ2VyXCIgOiBcIkZsb2F0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiQm9vbGVhblwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6ICh2YWx1ZSA/IFwiVHJ1ZVwiOiBcIkZhbHNlXCIpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiB2YWx1ZS50cCRuYW1lID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHZhbHVlLnRwJG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIgPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogdmFsdWUuJHIoKS52XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8vIFRPRE86IHZpZXdFeGFjdFZhbHVlIiwiLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBlbGVtZW50IGlzIGluIHRoZSBsaXN0LlxuICogQHBhcmFtIHthbnl0aGluZ30gbmVlZGxlIC0gVGhlIGVsZW1lbnQgdG8gbG9vayBmb3IuXG4gKiBAcGFyYW0ge0FycmF5fSBoYXlzdGFjayAtIFRoZSBsaXN0IHRvIHNlYXJjaC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGVsZW1lbnQgZXhpc3RzXG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnMobmVlZGxlLCBoYXlzdGFjaykge1xuICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSkgPiAtMTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgZHVwbGljYXRlIHZhbHVlcyBmcm9tIGFuIGFycmF5LCBwcmVzZXJ2aW5nIG9yZGVyLlxuICogQ3JlYXRlcyBhIG5ldyBhcnJheSwgc28gaXMgbm9uLWRlc3RydWN0aXZlLlxuICogQ291cnRlc3k6XG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTg0MzcwL2hvdy10by1tZXJnZS10d28tYXJyYXlzLWluLWphdmFzY3JpcHQtYW5kLWRlLWR1cGxpY2F0ZS1pdGVtc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIHVuaXF1aWZ5LiBFbGVtZW50cyBjb21wYXJlZCB3aXRoID09PS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlVbmlxdWUoYXJyYXkpIHtcbiAgICB2YXIgYSA9IGFycmF5LmNvbmNhdCgpO1xuICAgIGZvcih2YXIgaT0wOyBpPGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZm9yKHZhciBqPWkrMTsgajxhLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBpZihhW2ldID09PSBhW2pdKSB7YS5zcGxpY2Uoai0tLCAxKTt9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZXh0ZW5kaW5nIGFuIGFycmF5IGJhc2VkXG4gKiBvbiBhbiBcImFkZEFycmF5XCIgYW5kIFwicmVtb3ZlQXJyYXlcIi4gQW55IGVsZW1lbnRcbiAqIGZvdW5kIGluIHJlbW92ZUFycmF5IGlzIHJlbW92ZWQgZnJvbSB0aGUgZmlyc3QgYXJyYXlcbiAqIGFuZCBhbGwgdGhlIGVsZW1lbnRzIG9mIGFkZEFycmF5IGFyZSBhZGRlZC5cbiAqIEFueSBkdXBsaWNhdGUgaXRlbXMgYXJlIHJlbW92ZWQuXG4gKiBDcmVhdGVzIGEgbmV3IGFycmF5LCBzbyBpcyBub24tZGVzdHJ1Y3RpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gbWFuaXB1bGF0ZVxuICogQHBhcmFtIHtBcnJheX0gYWRkQXJyYXkgLSB0aGUgZWxlbWVudHMgdG8gYWRkIHRvIHRoZSBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gcmVtb3ZlQXJyYXkgLSB0aGUgZWxlbWVudHMgdG8gcmVtb3ZlIGZyb20gdGhlIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIG1vZGlmaWVkIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGV4cGFuZEFycmF5KGFycmF5LCBhZGRBcnJheSwgcmVtb3ZlQXJyYXkpIHtcbiAgICB2YXIgY29weUFycmF5ID0gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUFycmF5LmluZGV4T2YoaXRlbSkgPT09IC0xO1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheVVuaXF1ZShjb3B5QXJyYXkuY29uY2F0KGFkZEFycmF5KSk7XG59XG5cbi8qKlxuICogRGVlcGx5IGNsb25lcyBhIG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBBIG5vZGUgdG8gY2xvbmVcbiAqIEByZXR1cm4ge05vZGV9IEEgY2xvbmUgb2YgdGhlIGdpdmVuIG5vZGUgYW5kIGFsbCBpdHMgY2hpbGRyZW5cbiAqL1xuZnVuY3Rpb24gY2xvbmVOb2RlKG5vZGUpIHtcbiAgICAvLyBJZiB0aGUgbm9kZSBpcyBhIHRleHQgbm9kZSwgdGhlbiByZS1jcmVhdGUgaXQgcmF0aGVyIHRoYW4gY2xvbmUgaXRcbiAgICB2YXIgY2xvbmUgPSBub2RlLm5vZGVUeXBlID09IDMgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLm5vZGVWYWx1ZSkgOiBub2RlLmNsb25lTm9kZShmYWxzZSk7XG4gXG4gICAgLy8gUmVjdXJzZSAgICAgXG4gICAgdmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgIHdoaWxlKGNoaWxkKSB7XG4gICAgICAgIGNsb25lLmFwcGVuZENoaWxkKGNsb25lTm9kZShjaGlsZCkpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICAgXG4gICAgcmV0dXJuIGNsb25lO1xufVxuXG4vKipcbiAqIEluZGVudHMgdGhlIGdpdmVuIHN0cmluZyBieSA0IHNwYWNlcy4gVGhpcyBjb3JyZWN0bHkgaGFuZGxlcyBtdWx0aS1saW5lIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gYmUgbWFuaXB1bGF0ZWQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHdpdGggZm91ciBzcGFjZXMgYWRkZWQgYXQgdGhlIHN0YXJ0IG9mIGV2ZXJ5IG5ldyBsaW5lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5kZW50KHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXig/PS4pL2dtLCBcIiAgICBcIik7XG59XG5cbi8qKlxuICogVHVybnMgc3BhY2VzIGludG8gdW5kZXJzY29yZXMgaW4gdGhlIHN0cmluZywgbWFrZXMgaXQgbG93ZXJjYXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHRoZSBzdHJpbmcgdG8gYmUgbWFuaXB1bGF0ZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbHVnKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxzL2csIFwiX1wiKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiBhIHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzIC0gVGhlIHN0cmluZyB0byBiZSBjYXBpdGFsaXplZC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXBpdGFsaXplKHMpIHtcbiAgICBpZiAodHlwZW9mIHMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIFtgbWluYCwgYG1heGBdLlxuICogXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIGxvd2VzdCBwb3NzaWJsZSBpbnRlZ2VyLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBoaWdoZXN0IHBvc3NpYmxlIGludGVnZXIgKGluY2x1c2l2ZSkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiByYW5kb21JbnRlZ2VyKG1pbixtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihtYXgtbWluKzEpK21pbik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBzb21lIHRleHQgc28gdGhhdCBpdCBjYW4gYmUgc2FmZWx5IHdyaXR0ZW4gaW50byBhbiBIVE1MIGJveC5cbiAqIFRoaXMgaW5jbHVkZXMgcmVwbGFjaW5nIHNwZWNpYWwgSFRNTCBjaGFyYWN0ZXJzICgmLCA8LCA+LCBldGMuKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHRleHQgdG8gYmUgY29udmVydGVkLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgSFRNTC1zYWZlIHRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVIVE1MKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpXG4gICAgICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxuICAgICAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIilcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpXG4gICAgICAgIC5yZXBsYWNlKC8nL2csIFwiJmFwb3M7XCIpO1xufVxuXG4vKipcbiAqIFNodWZmbGUgdGhlIGJsb2NrcyBpbiB0aGUgd29ya3NwYWNlXG4gKi9cbmlmICh0eXBlb2YgQmxvY2tseSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIEJsb2NrbHkuV29ya3NwYWNlU3ZnLnByb3RvdHlwZS5zaHVmZmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtZXRyaWNzID0gdGhpcy5nZXRNZXRyaWNzKCk7XG4gICAgICAgIHZhciB3aWR0aCA9IG1ldHJpY3Mudmlld1dpZHRoIC8gMixcbiAgICAgICAgICAgIGhlaWdodCA9IG1ldHJpY3Mudmlld0hlaWdodDtcbiAgICAgICAgdmFyIGJsb2NrcyA9IHRoaXMuZ2V0VG9wQmxvY2tzKGZhbHNlKTtcbiAgICAgICAgdmFyIHkgPSA1LCB4ID0gMCxcbiAgICAgICAgICAgIG1heGltYWxfaW5jcmVhc2UgPSBoZWlnaHQvYmxvY2tzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgLy8gR2V0IGEgYmxvY2tcbiAgICAgICAgICAgIHZhciBibG9jayA9IGJsb2Nrc1tpXTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gYmxvY2suZ2V0UmVsYXRpdmVUb1N1cmZhY2VYWSgpO1xuICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgICAgICAgIHggPSA1O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gLXByb3BlcnRpZXMueCtyYW5kb21JbnRlZ2VyKDEwLCB3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jay5tb3ZlQnkoeCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgLXByb3BlcnRpZXMueSt5KTtcbiAgICAgICAgICAgIHkgPSB5ICsgcmFuZG9tSW50ZWdlcig1LCBtYXhpbWFsX2luY3JlYXNlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKlxuICogTW92ZSBlbGVtZW50cyBmcm9tIG9uZSBhcnJheSB0byBhbm90aGVyIGJhc2VkIG9uIGEgY29uZGl0aW9uYWwgY2hlY2suXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMTg4Nzk2Ny9qYXZhc2NyaXB0LW1vdmUtb2JqZWN0cy1mcm9tLW9uZS1hcnJheS10by1hbm90aGVyLWJlc3QtYXBwcm9hY2hcbiAqL1xuZnVuY3Rpb24gbW92ZUVsZW1lbnRzKHNvdXJjZSwgdGFyZ2V0LCBtb3ZlQ2hlY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKG1vdmVDaGVjayhlbGVtZW50KSkge1xuICAgICAgICAgICAgc291cmNlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfSBcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZmlyc3REZWZpbmVkVmFsdWUoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBvbmUgb2YgdGhlIFNrLmJ1aWx0aW4gb2JqZWN0c1xuICogVE9ETzogbWFrZSB0aGlzIHNvIHdlIGRvbid0IGhhdmUgdG8gZXhwbGljaXRseSBwdXQgb3V0IGV2ZXJ5IG9wdGlvblxuICogICAgICAgICAgb25lIHBvc3NpYmxlIHRoaW5nIHdlIGNvdWxkIGRvIGlzIGdldCBhIHN0cmluZyB2ZXJzaW9uIG9mIHRoZSBcbiAqICAgICAgICAgIG9mIHRoZSBjb25zdHJ1Y3RvciBhbmQgbG9vayBmb3IgdGhlIHN1YnN0cmluZyBcInJldHVybiBuZXcgU2suYnVpbHRpblwiXG4gKiAgICAgICAgICBCdXQgSSBkb24ndCBrbm93IGhvdyByZWxpYWJsZSB0aGF0IGlzLiAgUmF0aGVyLCBpdCdzIGtpbmQgb2YgaGFja2lzaC5cbiAqICAgICAgICAgIFNob3VsZCB0ZWhvcmV0aWNhbGx5IGJlbG9uZyBpbiBTay5mZmlcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGJlIGV4YW1pbmVkXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgaXMgb25lIG9mIHRoZSBTay5idWlsdGluIHR5cGVzXG4qKi9cbmZ1bmN0aW9uIGlzU2tCdWlsdGluKG9iail7XG4gICAgcmV0dXJuIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3QpIHx8XG4gICAgICAgIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLmxpc3QpIHx8XG4gICAgICAgIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLnR1cGxlKSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5ib29sKSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRfKSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF8pIHx8XG4gICAgICAgIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLnN0cikgfHxcbiAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nKTtcbiAgICAvL3ZhciBjb25zX3N0ciA9IG9iai5jb25zdHJ1Y3RvciArIFwiXCI7XG4gICAgLy9yZXR1cm4gY29uc19zdHIuaW5kZXhPZihcInJldHVybiBuZXcgU2suYnVpbHRpblwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGlzQXN0Tm9kZShvYmope1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBPYmplY3QgJiYgXCJfYXN0bmFtZVwiIGluIG9iajtcbn1cblxuLyoqXG4gKiBTaG91bGQgdGhlb3JldGljYWxseSBiZWxvbmcgaW4gU2suZmZpLCBidXQgSSBwdXQgaXQgaGVyZSBpbnN0ZWFkIHRvIG5vdCBtZXNzIHVwIHRoZSBza3VscHQgZmlsZXNcbiAqIGxpa2UgdGhlIG5vcm1hbCBTay5mZmkucmVtYXBUb1B5LCBpdCBkb2Vzbid0IHdvcmsgZm9yIGZ1bmN0aW9ucyBvciBtb3JlIGNvbXBsZXggb2JqZWN0cywgYnV0IGl0IGhhbmRsZXNcbiAqIGNhc2VzIHdoZXJlIHRoZSB0eXBlcyBpbiBvYmogYXJlIGEgbWl4IG9mIHB5dGhvbiBTSU1QTEUgb2JqZWN0cyBhbmQgU0lNUExFIG5vcm1hbCBqYXZhc2NyaXB0IG9iamVjdHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGJlIGNvbnZlcnRlZFxuICogQHJldHVybiB7U2suYnVpbHRpbi4/Pz99IC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBweXRob24gb2JqZWN0LCBkcm9wcGluZyBhbGwgZnVuY3Rpb25zIGFuZCB0aGluZ3MgaXQgY2FuJ3QgY29udmVydFxuKiovXG5mdW5jdGlvbiBtaXhlZFJlbWFwVG9QeShvYmope1xuICAgIHZhciBrO1xuICAgIHZhciBrdnM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGFycjtcbiAgICAvL0BUT0RPOiBzaG91bGQgdGhlb3JldGljYWxseSBjaGVjayBpZiB0aGUgb2JqZWN0IGlzIGEgcHlob24gZGljdCBvciBhcnJheSB3aXRoIGpzIG9iamVjdHNcbiAgICBpZiAoaXNTa0J1aWx0aW4ob2JqKSl7XG4gICAgICAgIC8vb2JqZWN0IGlzIGFscmVhZHkgcHl0aG9uIHJlYWR5XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgIC8vb2JqZWN0IGlzIGFjdHVhbGx5IGEgamF2YXNjcmlwdCBhcnJheVxuICAgICAgICBhcnIgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgLy9mb3IgZWFjaCBvYmplY3QsIGNvbnZlcnQgaXQgdG8gYSBweXRob24gb2JqZWN0IGlmIGl0IGlzbid0IG9uZSBhbHJlYWR5XG4gICAgICAgICAgICB2YXIgc3VidmFsID0gb2JqW2ldO1xuICAgICAgICAgICAgaWYoIWlzU2tCdWlsdGluKHN1YnZhbCkpe1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKG1peGVkUmVtYXBUb1B5KHN1YnZhbCkpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goc3VidmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChhcnIpO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSBudWxsKSB7Ly9udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZighaXNTa0J1aWx0aW4ob2JqKSl7XG4gICAgICAgICAgICAvL2Fzc3VtaW5nIGl0J3MgYSBzdGFuZGFyZCBkaWN0aW9uYXJ5XG4gICAgICAgICAgICBrdnMgPSBbXTsvL1NrLmJ1aWx0aW4uZGljdCB1c2VzIGFuIGFycmF5IG9mIGtleS12YWx1ZSxrZXktdmFsdWUuLi5cbiAgICAgICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgdGhlIGtleSBpZiBpdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWRcbiAgICAgICAgICAgICAgICBrdnMucHVzaChtaXhlZFJlbWFwVG9QeShrKSk7XG4gICAgICAgICAgICAgICAgLy9jb3ZlcnQgY29ycmVzcG9uZGluZyB2YWx1ZSBpZiBpdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWRcbiAgICAgICAgICAgICAgICBrdnMucHVzaChtaXhlZFJlbWFwVG9QeShvYmpba10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY3JlYXRlIHRoZSBuZXcgZGljdGlvbmFyeVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmRpY3Qoa3ZzKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIob2JqKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW4uYXNzayQob2JqKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKG9iaik7XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKG9iai5uYW1lKTtcbiAgICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfanF1ZXJ5X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2tub2Nrb3V0X187Il0sInNvdXJjZVJvb3QiOiIifQ==